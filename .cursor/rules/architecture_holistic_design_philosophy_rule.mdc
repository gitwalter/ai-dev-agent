# System Architecture Integration Rule

## Description
Build software systems with systematic architecture validation and rapid integration. Design components with clear interfaces, proper integration points, and systematic validation. Always validate component design against the overall system architecture to ensure coherence and maintainability. Focus on practical implementation that speeds up development while maintaining quality.

## Core Requirements

### 1. Rapid Component Architecture Design
**MANDATORY**: Apply systematic architecture principles for fast, efficient component development:

#### **Fast Component Design Pattern**
```python
class RapidArchitectureManager:
    """Manages rapid system architecture development."""
    
    def __init__(self):
        self.architecture_validator = ArchitectureValidator()
        self.integration_checker = IntegrationChecker()
        self.pattern_matcher = PatternMatcher()
    
    def design_component_fast(self, component_spec: dict) -> dict:
        """
        Design component architecture rapidly using systematic principles.
        
        Speed-focused approach:
        - Quick architecture validation
        - Rapid integration checking
        - Fast pattern matching
        - Immediate feedback loop
        """
        # Step 1: Quick architecture validation (30 seconds)
        component["architecture_valid"] = self._quick_architecture_check(component_spec)
        
        # Step 2: Rapid integration assessment (30 seconds)
        component["integration_ready"] = self._rapid_integration_check(component_spec)
        
        # Step 3: Fast pattern matching (30 seconds)
        component["pattern_compliant"] = self._fast_pattern_match(component_spec)
        
        # Step 4: Immediate feedback (15 seconds)
        component["feedback"] = self._generate_immediate_feedback(component)
        
        return component
    
    def _quick_architecture_check(self, spec: dict) -> bool:
        """Quick architecture validation - 30 second check."""
        checks = [
            spec.get("interface") is not None,
            spec.get("responsibilities") is not None,
            spec.get("dependencies") is not None,
            spec.get("integration_points") is not None
        ]
        return all(checks)
    
    def _rapid_integration_check(self, spec: dict) -> bool:
        """Rapid integration assessment - 30 second check."""
        integration_checks = [
            self._check_interface_compatibility(spec),
            self._check_dependency_resolution(spec),
            self._check_error_handling(spec),
            self._check_performance_impact(spec)
        ]
        return all(integration_checks)
    
    def _fast_pattern_match(self, spec: dict) -> dict:
        """Fast pattern matching - 30 second analysis."""
        return {
            "design_pattern": self._identify_design_pattern(spec),
            "architectural_pattern": self._identify_architectural_pattern(spec),
            "integration_pattern": self._identify_integration_pattern(spec),
            "recommendations": self._generate_pattern_recommendations(spec)
        }
```

### 2. Rapid Implementation Quality Assurance
**MANDATORY**: Ensure high-quality implementation with speed-focused quality checks:

#### **Fast Quality Assurance**
```python
class RapidQualityEngineer:
    """Ensures high-quality implementation with speed-focused checks."""
    
    def __init__(self):
        self.quality_checker = QualityChecker()
        self.standards_validator = StandardsValidator()
    
    def ensure_quality_fast(self, component: dict) -> dict:
        """
        Ensure implementation quality with rapid checks.
        
        Fast quality validation:
        - Quick naming validation
        - Rapid structure check
        - Fast error handling review
        - Immediate documentation check
        """
        # Quality check 1: Naming (15 seconds)
        component["naming_quality"] = self._quick_naming_check(component)
        
        # Quality check 2: Structure (30 seconds)
        component["structure_quality"] = self._rapid_structure_check(component)
        
        # Quality check 3: Error handling (30 seconds)
        component["error_handling_quality"] = self._fast_error_check(component)
        
        # Quality check 4: Documentation (15 seconds)
        component["documentation_quality"] = self._quick_doc_check(component)
        
        return component
    
    def _quick_naming_check(self, component: dict) -> dict:
        """Quick naming validation - 15 second check."""
        naming_issues = []
        
        # Check class names
        if component.get("class_name"):
            if not component["class_name"][0].isupper():
                naming_issues.append("Class name should be PascalCase")
        
        # Check method names
        if component.get("methods"):
            for method in component["methods"]:
                if not method["name"].startswith("_"):
                    if not method["name"].islower():
                        naming_issues.append(f"Method {method['name']} should be snake_case")
        
        return {
            "valid": len(naming_issues) == 0,
            "issues": naming_issues,
            "fixes": self._generate_naming_fixes(naming_issues)
        }
    
    def _rapid_structure_check(self, component: dict) -> dict:
        """Rapid structure validation - 30 second check."""
        structure_issues = []
        
        # Check separation of concerns
        if component.get("methods"):
            responsibilities = set()
            for method in component["methods"]:
                responsibilities.add(method.get("responsibility", ""))
            
            if len(responsibilities) > 3:
                structure_issues.append("Too many responsibilities - consider splitting")
        
        # Check method length
        for method in component.get("methods", []):
            if method.get("lines", 0) > 20:
                structure_issues.append(f"Method {method['name']} too long - consider refactoring")
        
        return {
            "valid": len(structure_issues) == 0,
            "issues": structure_issues,
            "recommendations": self._generate_structure_recommendations(structure_issues)
        }
```

### 3. Fast System Integration Validation
**MANDATORY**: Rapidly validate system integration and architecture health:

#### **Rapid Integration Validator**
```python
class RapidIntegrationValidator:
    """Rapidly validates system integration and architecture."""
    
    def __init__(self):
        self.performance_monitor = PerformanceMonitor()
        self.integration_checker = IntegrationChecker()
        self.architecture_validator = ArchitectureValidator()
    
    def validate_integration_fast(self, component: dict) -> dict:
        """Rapid integration validation - 60 second check."""
        validation_results = {
            "performance_impact": self._quick_performance_check(component),
            "integration_compatibility": self._rapid_compatibility_check(component),
            "architecture_consistency": self._fast_consistency_check(component),
            "system_health": self._quick_health_check(component)
        }
        
        return validation_results
    
    def _quick_performance_check(self, component: dict) -> dict:
        """Quick performance impact assessment - 15 seconds."""
        performance_indicators = {
            "memory_usage": component.get("estimated_memory", "low"),
            "cpu_impact": component.get("estimated_cpu", "low"),
            "network_usage": component.get("network_calls", 0),
            "database_queries": component.get("db_queries", 0)
        }
        
        return {
            "acceptable": all(v == "low" or v == 0 for v in performance_indicators.values()),
            "indicators": performance_indicators,
            "recommendations": self._generate_performance_recommendations(performance_indicators)
        }
    
    def _rapid_compatibility_check(self, component: dict) -> dict:
        """Rapid compatibility check - 15 seconds."""
        compatibility_checks = [
            self._check_interface_compatibility(component),
            self._check_data_format_compatibility(component),
            self._check_error_handling_compatibility(component),
            self._check_version_compatibility(component)
        ]
        
        return {
            "compatible": all(compatibility_checks),
            "issues": [check for check in compatibility_checks if not check],
            "fixes": self._generate_compatibility_fixes(component)
        }
```

### 4. Rapid Big Picture Assessment
**MANDATORY**: Quickly assess component impact on overall system architecture:

#### **Fast Big Picture Analyzer**
```python
class FastBigPictureAnalyzer:
    """Rapidly analyzes big picture impact of components."""
    
    def __init__(self):
        self.impact_analyzer = ImpactAnalyzer()
        self.architecture_mapper = ArchitectureMapper()
        self.system_validator = SystemValidator()
    
    def assess_big_picture_fast(self, component: dict) -> dict:
        """Rapid big picture assessment - 45 second analysis."""
        assessment = {
            "system_impact": self._quick_impact_analysis(component),
            "architecture_fit": self._rapid_architecture_fit(component),
            "integration_points": self._fast_integration_mapping(component),
            "future_compatibility": self._quick_future_check(component)
        }
        
        return assessment
    
    def _quick_impact_analysis(self, component: dict) -> dict:
        """Quick impact analysis - 15 seconds."""
        impact_factors = {
            "affects_existing_components": component.get("dependencies", []),
            "introduces_new_patterns": component.get("design_patterns", []),
            "changes_data_flow": component.get("data_flow_changes", False),
            "affects_performance": component.get("performance_impact", "low")
        }
        
        return {
            "impact_level": self._calculate_impact_level(impact_factors),
            "affected_components": impact_factors["affects_existing_components"],
            "risk_assessment": self._assess_risk_level(impact_factors),
            "mitigation_strategies": self._generate_mitigation_strategies(impact_factors)
        }
    
    def _rapid_architecture_fit(self, component: dict) -> dict:
        """Rapid architecture fit assessment - 15 seconds."""
        fit_checks = [
            self._check_architectural_principles(component),
            self._check_design_patterns(component),
            self._check_coding_standards(component),
            self._check_integration_patterns(component)
        ]
        
        return {
            "fits_architecture": all(fit_checks),
            "violations": [check for check in fit_checks if not check],
            "recommendations": self._generate_architecture_recommendations(component)
        }
```

### 5. Rapid Development Workflow
**MANDATORY**: Execute rapid development workflow with systematic validation:

#### **Fast Development Manager**
```python
class FastDevelopmentManager:
    """Manages rapid development workflow with systematic validation."""
    
    def __init__(self):
        self.architecture_manager = RapidArchitectureManager()
        self.quality_engineer = RapidQualityEngineer()
        self.integration_validator = RapidIntegrationValidator()
        self.big_picture_analyzer = FastBigPictureAnalyzer()
    
    async def develop_rapidly(self, feature_spec: dict) -> dict:
        """Rapid development workflow - 3 minute cycle."""
        print("âš¡ Starting rapid development...")
        
        # Step 1: Fast architecture design (1 minute)
        architecture = self.architecture_manager.design_component_fast(feature_spec)
        print("ðŸ—ï¸ Architecture designed")
        
        # Step 2: Rapid quality assurance (1 minute)
        quality = self.quality_engineer.ensure_quality_fast(architecture)
        print("âœ… Quality assured")
        
        # Step 3: Fast integration validation (30 seconds)
        integration = self.integration_validator.validate_integration_fast(quality)
        print("ðŸ”— Integration validated")
        
        # Step 4: Quick big picture assessment (30 seconds)
        big_picture = self.big_picture_analyzer.assess_big_picture_fast(integration)
        print("ðŸŽ¯ Big picture assessed")
        
        return {
            "architecture": architecture,
            "quality": quality,
            "integration": integration,
            "big_picture": big_picture,
            "development_time": "3 minutes",
            "next_steps": self._generate_next_steps(big_picture)
        }
    
    def _generate_next_steps(self, assessment: dict) -> list:
        """Generate next steps based on assessment."""
        next_steps = []
        
        if not assessment["system_impact"]["impact_level"] == "low":
            next_steps.append("Review with team for high-impact changes")
        
        if assessment["architecture_fit"]["violations"]:
            next_steps.append("Fix architecture violations")
        
        if assessment["integration_points"]["complexity"] == "high":
            next_steps.append("Simplify integration points")
        
        return next_steps
```

## Practical Implementation Guidelines

### 1. Speed-Focused Development Process
- **30-Second Architecture Check**: Quick validation of component architecture
- **1-Minute Quality Review**: Rapid quality assurance checks
- **30-Second Integration Test**: Fast integration validation
- **30-Second Big Picture Review**: Quick assessment of system impact

### 2. Rapid Decision Making
- **Immediate Feedback**: Generate feedback within 15 seconds
- **Quick Validation**: Validate decisions within 30 seconds
- **Fast Assessment**: Assess impact within 45 seconds
- **Rapid Iteration**: Complete development cycles in 3 minutes

### 3. Efficient Quality Assurance
- **Automated Checks**: Use automated tools for rapid validation
- **Pattern Matching**: Quick pattern identification and application
- **Standards Validation**: Rapid standards compliance checking
- **Performance Assessment**: Quick performance impact analysis

### 4. Fast Integration Testing
- **Compatibility Checks**: Rapid compatibility validation
- **Interface Testing**: Quick interface compatibility testing
- **Error Handling**: Fast error handling validation
- **Performance Monitoring**: Quick performance impact assessment

## Benefits

### Speed Benefits
- **Rapid Development**: Complete development cycles in minutes
- **Quick Validation**: Immediate feedback on design decisions
- **Fast Integration**: Rapid integration testing and validation
- **Efficient Workflow**: Streamlined development process

### Quality Benefits
- **Systematic Validation**: Consistent quality assurance process
- **Architecture Compliance**: Ensures architectural consistency
- **Integration Quality**: Validates proper integration
- **Performance Awareness**: Maintains performance standards

### Efficiency Benefits
- **Reduced Development Time**: Faster feature development
- **Immediate Feedback**: Quick identification of issues
- **Rapid Iteration**: Fast iteration and improvement cycles
- **Systematic Approach**: Consistent development methodology

## Application

### When to Apply
- **Every Component**: Apply rapid architecture design to every component
- **Every Integration**: Use fast integration validation for every integration
- **Every Quality Check**: Apply rapid quality assurance to every implementation
- **Every Assessment**: Use quick big picture assessment for every change

### How to Apply
1. **Start with Architecture**: Quick 30-second architecture validation
2. **Rapid Quality Check**: 1-minute quality assurance review
3. **Fast Integration**: 30-second integration validation
4. **Quick Assessment**: 30-second big picture review
5. **Immediate Feedback**: Generate feedback within 15 seconds

### Success Criteria
- **Development Speed**: Complete development cycles in 3 minutes
- **Quality Maintenance**: Maintain high quality standards
- **Integration Success**: Successful integration validation
- **Architecture Compliance**: Consistent architectural design
- **Performance Standards**: Maintain performance requirements

---

**This rule ensures rapid, efficient software development while maintaining systematic architecture validation and quality standards.**
description: Rapid system architecture integration with systematic validation
globs: ["**/*.py", "**/*.md", "**/architecture/**", "**/design/**"]
alwaysApply: true
