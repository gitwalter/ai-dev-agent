# Agile Manifesto Principles Rule

**CRITICAL**: All development activities must strictly adhere to the [Agile Manifesto Principles](https://agilemanifesto.org/principles.html) as the foundational guidelines for all work.

## Description
This rule enforces the 12 core principles from the Agile Manifesto, ensuring that all development work, processes, and decisions align with true agile methodology as defined by the original manifesto.

## ðŸ›ï¸ **THE 12 AGILE MANIFESTO PRINCIPLES**

### **Principle 1: Customer Satisfaction Through Early and Continuous Delivery**
**"Our highest priority is to satisfy the customer through early and continuous delivery of valuable software."**

#### **Implementation Requirements**
```python
# MANDATORY: Customer value first approach
def validate_customer_value(task: str, deliverable: str) -> bool:
    """Validate that task delivers measurable customer value."""
    
    # Customer value criteria
    value_criteria = [
        "Solves real customer problem",
        "Provides measurable benefit", 
        "Deployable and usable",
        "Aligned with customer needs",
        "Delivers working software"
    ]
    
    return all(validate_criterion(deliverable, criterion) for criterion in value_criteria)

# CORRECT: Customer-focused development
def implement_customer_value_first(feature: str):
    """Implement feature with customer value as primary focus."""
    # 1. Validate customer value proposition
    # 2. Deliver minimal viable functionality first
    # 3. Deploy early and get feedback
    # 4. Iterate based on customer input
    pass

# INCORRECT: Technology-first development
def implement_technology_first(feature: str):
    """Implement feature focusing on technology over customer value."""
    # This violates Principle 1
    pass
```

#### **Automation Requirements**
- **Continuous Delivery Pipeline**: Automated deployment of working software
- **Customer Feedback Integration**: Automated collection and integration of customer feedback
- **Value Metrics Tracking**: Automated measurement of customer value delivery

---

### **Principle 2: Welcome Changing Requirements**
**"Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage."**

#### **Implementation Requirements**
```python
# MANDATORY: Change adaptation mechanisms
def embrace_requirement_change(change_request: dict) -> dict:
    """Process requirement changes as opportunities, not obstacles."""
    
    # Change assessment
    impact_analysis = analyze_change_impact(change_request)
    customer_value = assess_customer_value_increase(change_request)
    
    # Welcome change if it increases customer value
    if customer_value > 0:
        return implement_change_immediately(change_request, impact_analysis)
    else:
        return evaluate_change_benefits(change_request)

# CORRECT: Change-embracing process
def implement_adaptive_planning():
    """Implement planning that embraces change."""
    # 1. Short iteration cycles
    # 2. Flexible architecture
    # 3. Minimal documentation
    # 4. Rapid prototyping
    # 5. Customer collaboration
    pass

# INCORRECT: Change-resistant process
def implement_rigid_planning():
    """Implement planning that resists change."""
    # This violates Principle 2
    pass
```

#### **Automation Requirements**
- **Change Impact Assessment**: Automated analysis of requirement changes
- **Rapid Adaptation Workflows**: Automated processes for implementing changes
- **Flexible Planning Tools**: Automated planning that adapts to changes

---

### **Principle 3: Frequent Software Delivery**
**"Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale."**

#### **Implementation Requirements**
```python
# MANDATORY: Frequent delivery cycles
def enforce_frequent_delivery() -> bool:
    """Enforce frequent delivery of working software."""
    
    # Delivery frequency requirements
    max_delivery_cycle = 14  # days (2 weeks maximum)
    preferred_cycle = 7      # days (1 week preferred)
    
    current_cycle = get_current_delivery_cycle()
    
    if current_cycle > max_delivery_cycle:
        raise DeliveryFrequencyError(f"Delivery cycle too long: {current_cycle} days")
    
    return current_cycle <= preferred_cycle

# CORRECT: Short delivery cycles
def implement_weekly_delivery():
    """Implement weekly delivery of working software."""
    # 1. Daily integration
    # 2. Automated testing
    # 3. Automated deployment
    # 4. Working software validation
    # 5. Customer feedback collection
    pass

# INCORRECT: Long delivery cycles
def implement_quarterly_delivery():
    """Implement quarterly delivery cycles."""
    # This violates Principle 3
    pass
```

#### **Automation Requirements**
- **Daily Integration**: Automated continuous integration
- **Automated Deployment**: Push-button deployment capabilities
- **Delivery Metrics**: Automated tracking of delivery frequency

---

### **Principle 4: Daily Collaboration Between Business and Development**
**"Business people and developers must work together daily throughout the project."**

#### **Implementation Requirements**
```python
# MANDATORY: Daily collaboration mechanisms
def ensure_daily_collaboration() -> bool:
    """Ensure daily collaboration between business and development."""
    
    collaboration_activities = [
        "Daily stakeholder communication",
        "Requirement clarification sessions",
        "Progress demonstrations", 
        "Feedback collection and integration",
        "Priority alignment discussions"
    ]
    
    return all(activity_completed_today(activity) for activity in collaboration_activities)

# CORRECT: Daily business collaboration
def implement_daily_business_collaboration():
    """Implement daily collaboration with business stakeholders."""
    # 1. Daily standup with stakeholders
    # 2. Requirement clarification sessions
    # 3. Progress demonstrations
    # 4. Feedback integration
    # 5. Priority discussions
    pass

# INCORRECT: Isolated development
def implement_isolated_development():
    """Implement development isolated from business."""
    # This violates Principle 4
    pass
```

#### **Automation Requirements**
- **Stakeholder Communication**: Automated progress reporting to business
- **Feedback Collection**: Automated systems for collecting business feedback
- **Collaboration Scheduling**: Automated scheduling of collaboration sessions

---

### **Principle 5: Motivated Individuals and Trust**
**"Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done."**

#### **Implementation Requirements**
```python
# MANDATORY: Individual empowerment and trust
def empower_team_members() -> dict:
    """Empower team members with autonomy and support."""
    
    empowerment_elements = {
        "decision_autonomy": grant_decision_making_authority(),
        "tool_access": provide_necessary_tools(),
        "learning_support": enable_continuous_learning(),
        "environment_optimization": optimize_work_environment(),
        "trust_demonstration": demonstrate_trust_through_delegation()
    }
    
    return empowerment_elements

# CORRECT: Trust-based empowerment
def implement_trust_and_empowerment():
    """Implement trust-based team empowerment."""
    # 1. Delegate decision-making authority
    # 2. Provide necessary tools and resources
    # 3. Support continuous learning
    # 4. Remove bureaucratic obstacles
    # 5. Trust team judgment
    pass

# INCORRECT: Micromanagement approach
def implement_micromanagement():
    """Implement micromanagement and control."""
    # This violates Principle 5
    pass
```

#### **Automation Requirements**
- **Autonomous Decision Tools**: Tools that enable team decision-making
- **Resource Provisioning**: Automated provisioning of necessary resources
- **Learning Platform**: Automated access to learning resources

---

### **Principle 6: Face-to-Face Communication**
**"The most efficient and effective method of conveying information to and within a development team is face-to-face conversation."**

#### **Implementation Requirements**
```python
# MANDATORY: Direct communication prioritization
def prioritize_direct_communication() -> bool:
    """Prioritize face-to-face and direct communication."""
    
    communication_hierarchy = [
        "Face-to-face conversation",      # Highest priority
        "Video calls with interaction",   # High priority
        "Voice calls with discussion",    # Medium priority
        "Real-time chat with context",    # Lower priority
        "Asynchronous messages"           # Lowest priority
    ]
    
    return use_highest_priority_communication_available(communication_hierarchy)

# CORRECT: Direct communication emphasis
def implement_direct_communication():
    """Implement direct communication practices."""
    # 1. Daily face-to-face standups
    # 2. Pair programming sessions
    # 3. Collaborative design sessions
    # 4. Direct problem-solving discussions
    # 5. Immediate clarification conversations
    pass

# INCORRECT: Documentation-heavy communication
def implement_documentation_heavy_communication():
    """Implement communication through extensive documentation."""
    # This violates Principle 6
    pass
```

#### **Automation Requirements**
- **Meeting Facilitation**: Tools that facilitate effective face-to-face meetings
- **Communication Scheduling**: Automated scheduling of direct communication
- **Collaboration Spaces**: Digital spaces that simulate face-to-face interaction

---

### **Principle 7: Working Software as Primary Progress Measure**
**"Working software is the primary measure of progress."**

#### **Implementation Requirements**
```python
# MANDATORY: Working software focus
def measure_progress_by_working_software() -> dict:
    """Measure progress primarily through working software delivery."""
    
    progress_metrics = {
        "working_features_completed": count_working_features(),
        "customer_value_delivered": measure_customer_value(),
        "software_functionality": assess_functionality(),
        "deployment_readiness": validate_deployment_readiness(),
        "user_acceptance": measure_user_acceptance()
    }
    
    # Working software metrics should dominate
    total_progress = calculate_weighted_progress(progress_metrics, {
        "working_features_completed": 0.4,
        "customer_value_delivered": 0.3,
        "software_functionality": 0.2,
        "deployment_readiness": 0.1
    })
    
    return total_progress

# CORRECT: Working software progress measurement
def track_working_software_progress():
    """Track progress through working software delivery."""
    # 1. Feature completion tracking
    # 2. Deployment readiness validation
    # 3. Customer value measurement
    # 4. Functionality assessment
    # 5. User acceptance testing
    pass

# INCORRECT: Documentation-based progress tracking
def track_documentation_progress():
    """Track progress through documentation completion."""
    # This violates Principle 7
    pass
```

#### **Automation Requirements**
- **Working Software Validation**: Automated validation of software functionality
- **Progress Dashboards**: Real-time dashboards showing working software progress
- **Deployment Metrics**: Automated tracking of deployment-ready features

---

### **Principle 8: Sustainable Development Pace**
**"Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely."**

#### **Implementation Requirements**
```python
# MANDATORY: Sustainable pace maintenance
def maintain_sustainable_pace() -> bool:
    """Maintain sustainable development pace for team health."""
    
    sustainability_metrics = {
        "work_hours_per_week": get_average_work_hours(),
        "overtime_frequency": calculate_overtime_frequency(),
        "team_satisfaction": measure_team_satisfaction(),
        "burnout_indicators": assess_burnout_risk(),
        "velocity_consistency": measure_velocity_consistency()
    }
    
    # Validate sustainable pace
    max_work_hours = 40  # Standard work week
    max_overtime_frequency = 0.1  # 10% maximum
    min_satisfaction = 7.0  # 7/10 minimum
    
    return (
        sustainability_metrics["work_hours_per_week"] <= max_work_hours and
        sustainability_metrics["overtime_frequency"] <= max_overtime_frequency and
        sustainability_metrics["team_satisfaction"] >= min_satisfaction
    )

# CORRECT: Sustainable pace implementation
def implement_sustainable_pace():
    """Implement sustainable development practices."""
    # 1. Respect work-life balance
    # 2. Avoid overtime as standard practice
    # 3. Monitor team health indicators
    # 4. Maintain consistent velocity
    # 5. Prevent burnout through pace management
    pass

# INCORRECT: Unsustainable pace (crunch mode)
def implement_crunch_mode():
    """Implement unsustainable high-pressure development."""
    # This violates Principle 8
    pass
```

#### **Automation Requirements**
- **Pace Monitoring**: Automated monitoring of work pace and team health
- **Velocity Tracking**: Automated tracking of sustainable velocity
- **Health Dashboards**: Real-time dashboards showing team sustainability metrics

---

### **Principle 9: Technical Excellence and Good Design**
**"Continuous attention to technical excellence and good design enhances agility."**

#### **Implementation Requirements**
```python
# MANDATORY: Technical excellence standards
def enforce_technical_excellence() -> bool:
    """Enforce continuous technical excellence and good design."""
    
    excellence_criteria = {
        "code_quality": assess_code_quality(),
        "design_patterns": validate_design_patterns(),
        "technical_debt": measure_technical_debt(),
        "test_coverage": calculate_test_coverage(),
        "performance": measure_performance_metrics(),
        "maintainability": assess_maintainability(),
        "security": validate_security_standards()
    }
    
    # Technical excellence thresholds
    quality_thresholds = {
        "code_quality": 8.0,      # 8/10 minimum
        "test_coverage": 0.9,     # 90% minimum
        "technical_debt": 0.1,    # 10% maximum
        "performance": 8.0,       # 8/10 minimum
        "maintainability": 8.0,   # 8/10 minimum
        "security": 9.0           # 9/10 minimum
    }
    
    return all(
        excellence_criteria[metric] >= threshold
        for metric, threshold in quality_thresholds.items()
        if metric != "technical_debt"
    ) and excellence_criteria["technical_debt"] <= quality_thresholds["technical_debt"]

# CORRECT: Technical excellence focus
def implement_technical_excellence():
    """Implement continuous technical excellence practices."""
    # 1. Test-driven development
    # 2. Continuous refactoring
    # 3. Code review processes
    # 4. Design pattern application
    # 5. Performance optimization
    # 6. Security best practices
    pass

# INCORRECT: Quick-and-dirty development
def implement_quick_and_dirty_development():
    """Implement development that sacrifices quality for speed."""
    # This violates Principle 9
    pass
```

#### **Automation Requirements**
- **Quality Gates**: Automated quality validation in CI/CD pipeline
- **Technical Debt Monitoring**: Automated tracking of technical debt
- **Performance Monitoring**: Automated performance testing and monitoring

---

### **Principle 10: Simplicity - Maximizing Work Not Done**
**"Simplicity--the art of maximizing the amount of work not done--is essential."**

#### **Implementation Requirements**
```python
# MANDATORY: Simplicity and minimalism focus
def maximize_work_not_done() -> dict:
    """Focus on simplicity and eliminating unnecessary work."""
    
    simplicity_assessment = {
        "feature_necessity": assess_feature_necessity(),
        "code_complexity": measure_code_complexity(),
        "process_overhead": calculate_process_overhead(),
        "documentation_necessity": assess_documentation_necessity(),
        "meeting_efficiency": measure_meeting_efficiency()
    }
    
    # Simplicity improvements
    improvements = {
        "unnecessary_features": identify_unnecessary_features(),
        "code_simplification": identify_simplification_opportunities(),
        "process_reduction": identify_process_reduction_opportunities(),
        "documentation_reduction": identify_documentation_reduction()
    }
    
    return implement_simplicity_improvements(improvements)

# CORRECT: Simplicity-focused development
def implement_simplicity_focus():
    """Implement development with simplicity as core principle."""
    # 1. Minimal viable product approach
    # 2. Eliminate unnecessary features
    # 3. Simplify complex processes
    # 4. Reduce documentation overhead
    # 5. Focus on essential work only
    pass

# INCORRECT: Over-engineering approach
def implement_over_engineering():
    """Implement complex solutions for simple problems."""
    # This violates Principle 10
    pass
```

#### **Automation Requirements**
- **Complexity Analysis**: Automated detection of unnecessary complexity
- **Feature Usage Tracking**: Automated tracking of feature usage to identify unnecessary features
- **Process Optimization**: Automated identification of process inefficiencies

---

### **Principle 11: Self-Organizing Teams**
**"The best architectures, requirements, and designs emerge from self-organizing teams."**

#### **Implementation Requirements**
```python
# MANDATORY: Self-organizing team principles
def enable_self_organization() -> dict:
    """Enable and support self-organizing team structures."""
    
    self_organization_elements = {
        "decision_autonomy": grant_team_decision_authority(),
        "architecture_ownership": enable_team_architecture_decisions(),
        "requirement_refinement": support_team_requirement_refinement(),
        "design_collaboration": facilitate_collaborative_design(),
        "process_adaptation": allow_process_customization()
    }
    
    # Measure self-organization effectiveness
    effectiveness_metrics = {
        "decision_speed": measure_decision_making_speed(),
        "solution_quality": assess_solution_quality(),
        "team_satisfaction": measure_team_satisfaction(),
        "innovation_rate": calculate_innovation_metrics()
    }
    
    return {
        "organization": self_organization_elements,
        "effectiveness": effectiveness_metrics
    }

# CORRECT: Self-organizing team support
def support_self_organization():
    """Support team self-organization principles."""
    # 1. Delegate architectural decisions to team
    # 2. Enable team requirement refinement
    # 3. Support collaborative design processes
    # 4. Allow process customization
    # 5. Provide autonomy with accountability
    pass

# INCORRECT: Top-down command and control
def implement_command_and_control():
    """Implement top-down decision making and control."""
    # This violates Principle 11
    pass
```

#### **Automation Requirements**
- **Decision Tracking**: Automated tracking of team decisions and outcomes
- **Collaboration Tools**: Tools that facilitate team self-organization
- **Autonomy Metrics**: Automated measurement of team autonomy and effectiveness

---

### **Principle 12: Regular Reflection and Adaptation**
**"At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly."**

#### **Implementation Requirements**
```python
# MANDATORY: Regular reflection and improvement
def conduct_regular_reflection() -> dict:
    """Conduct regular team reflection and adaptation sessions."""
    
    reflection_frequency = 14  # days (every 2 weeks minimum)
    
    reflection_activities = {
        "retrospective_meetings": schedule_retrospectives(reflection_frequency),
        "process_analysis": analyze_current_processes(),
        "improvement_identification": identify_improvement_opportunities(),
        "adaptation_implementation": implement_process_adaptations(),
        "effectiveness_measurement": measure_improvement_effectiveness()
    }
    
    # Reflection outcomes
    outcomes = {
        "identified_improvements": collect_improvement_ideas(),
        "implemented_changes": track_implemented_changes(),
        "effectiveness_metrics": measure_change_effectiveness(),
        "team_learning": document_team_learning()
    }
    
    return {
        "activities": reflection_activities,
        "outcomes": outcomes
    }

# CORRECT: Regular reflection implementation
def implement_regular_reflection():
    """Implement regular reflection and adaptation practices."""
    # 1. Sprint retrospectives
    # 2. Process improvement sessions
    # 3. Team learning discussions
    # 4. Adaptation implementation
    # 5. Effectiveness measurement
    pass

# INCORRECT: Process stagnation
def maintain_static_processes():
    """Maintain processes without reflection or adaptation."""
    # This violates Principle 12
    pass
```

#### **Automation Requirements**
- **Retrospective Scheduling**: Automated scheduling of reflection sessions
- **Improvement Tracking**: Automated tracking of improvements and their effectiveness
- **Learning Documentation**: Automated documentation of team learning and insights

---

## **INTEGRATION WITH EXISTING RULES**

### **Rule Integration Matrix**
```yaml
# How Agile Manifesto principles integrate with existing Cursor rules
integration_mapping:
  principle_1_customer_satisfaction:
    - "development_core_principles_rule.mdc"
    - "agile_user_story_management_rule.mdc"
    
  principle_2_welcome_change:
    - "agile_sprint_management_rule.mdc"
    - "continuous_improvement_systematic_rule.mdc"
    
  principle_3_frequent_delivery:
    - "agile_daily_deployed_build_rule.mdc"
    - "automated_commit_rule.mdc"
    
  principle_4_daily_collaboration:
    - "agile_artifacts_maintenance_rule.mdc"
    
  principle_5_motivated_individuals:
    - "development_courage_completion_rule.mdc"
    - "boyscout_principle_rule.mdc"
    
  principle_6_face_to_face_communication:
    - "agile_artifacts_maintenance_rule.mdc"
    
  principle_7_working_software:
    - "no_failing_tests_rule.mdc"
    - "xp_test_first_development_rule.mdc"
    
  principle_8_sustainable_development:
    - "performance_monitoring_optimization_rule.mdc"
    
  principle_9_technical_excellence:
    - "code_review_quality_gates_rule.mdc"
    - "quality_validation_rule.mdc"
    
  principle_10_simplicity:
    - "anti_redundancy_elimination_rule.mdc"
    - "file_organization_cleanup_rule.mdc"
    
  principle_11_self_organizing_teams:
    - "metarule_holistic_boyscout_rule.mdc"
    
  principle_12_regular_reflection:
    - "continuous_improvement_systematic_rule.mdc"
```

## **VALIDATION AND COMPLIANCE**

### **Agile Manifesto Compliance Checker**
```python
# MANDATORY: Validate compliance with all 12 principles
def validate_agile_manifesto_compliance() -> dict:
    """Validate complete compliance with Agile Manifesto principles."""
    
    compliance_results = {}
    
    principles = [
        ("principle_1", validate_customer_satisfaction_priority),
        ("principle_2", validate_change_welcoming),
        ("principle_3", validate_frequent_delivery),
        ("principle_4", validate_daily_collaboration),
        ("principle_5", validate_motivated_individuals),
        ("principle_6", validate_face_to_face_communication),
        ("principle_7", validate_working_software_measure),
        ("principle_8", validate_sustainable_pace),
        ("principle_9", validate_technical_excellence),
        ("principle_10", validate_simplicity_focus),
        ("principle_11", validate_self_organization),
        ("principle_12", validate_regular_reflection)
    ]
    
    for principle_id, validator in principles:
        try:
            compliance_results[principle_id] = validator()
        except Exception as e:
            compliance_results[principle_id] = {
                "compliant": False,
                "error": str(e)
            }
    
    overall_compliance = all(
        result.get("compliant", False) 
        for result in compliance_results.values()
    )
    
    return {
        "overall_compliant": overall_compliance,
        "individual_results": compliance_results,
        "compliance_percentage": calculate_compliance_percentage(compliance_results)
    }
```

## **ENFORCEMENT**

This rule is **ALWAYS APPLIED** and must be followed for all:
- Development activities and processes
- Team interactions and collaboration
- Progress measurement and reporting
- Process improvement and adaptation
- Technical decision making
- Customer interaction and feedback
- Quality assurance and validation

**Violations of any Agile Manifesto principle require immediate correction and process adjustment.**

### **Compliance Requirements**
- [ ] All 12 principles actively implemented
- [ ] Regular compliance validation performed
- [ ] Process adaptations based on principle violations
- [ ] Team training on manifesto principles
- [ ] Customer satisfaction prioritized in all decisions
- [ ] Working software delivered frequently
- [ ] Technical excellence maintained continuously
- [ ] Simplicity maximized in all work
- [ ] Self-organization supported and enabled
- [ ] Regular reflection and adaptation conducted

**Reference**: [Agile Manifesto Principles](https://agilemanifesto.org/principles.html)

description:
globs:
alwaysApply: true
---