# Agile Daily Deployed Build Rule

**CRITICAL**: Implement and maintain daily deployed builds as a cornerstone of agile development methodology to ensure continuous integration, rapid feedback, and reliable delivery.

## Description
This rule enforces the agile practice of daily deployed builds, ensuring that every development day produces a potentially deployable artifact through automated processes, comprehensive testing, and continuous validation. This practice is fundamental to agile methodology and enables rapid iteration, risk reduction, and stakeholder confidence.

## Core Requirements

### 1. Daily Build Mandatory Requirement
**MANDATORY**: Every development day must produce a deployable build
```yaml
# REQUIRED: Daily build production standards
daily_build_requirements:
  - "One complete build per development day minimum"
  - "Build must be triggered automatically on main branch changes"
  - "Build must complete within maximum time limits"
  - "Build must pass all quality gates and tests"
  - "Build artifacts must be stored and versioned"
  - "Build status must be immediately visible to all stakeholders"
  - "Failed builds must trigger immediate remediation actions"
  - "Build metrics must be tracked and analyzed daily"
```

### 2. Automated Build Pipeline
**MANDATORY**: Implement fully automated build pipeline
```yaml
# REQUIRED: Automated pipeline stages
automated_pipeline_stages:
  - name: "Source Code Validation"
    requirements:
      - "Code formatting checks (Black, isort)"
      - "Linting validation (pylint, flake8)"
      - "Type checking (mypy)"
      - "Security scanning (bandit)"
      - "Dependency vulnerability checks"
    
  - name: "Build and Compilation"
    requirements:
      - "Virtual environment creation"
      - "Dependency installation and verification"
      - "Code compilation and module validation"
      - "Configuration validation"
      - "Resource bundling and optimization"
    
  - name: "Comprehensive Testing"
    requirements:
      - "Unit tests (100% execution)"
      - "Integration tests (full coverage)"
      - "System tests (end-to-end validation)"
      - "Performance tests (baseline validation)"
      - "Security tests (vulnerability assessment)"
    
  - name: "Quality Assurance"
    requirements:
      - "Code coverage analysis (â‰¥90%)"
      - "Technical debt assessment"
      - "Documentation validation"
      - "Compliance verification"
      - "Quality metrics collection"
    
  - name: "Deployment Preparation"
    requirements:
      - "Artifact packaging"
      - "Version tagging and labeling"
      - "Release notes generation"
      - "Deployment manifest creation"
      - "Rollback package preparation"
```

### 3. Build Quality Gates
**MANDATORY**: All builds must pass defined quality gates
```python
# REQUIRED: Quality gate implementation
class DailyBuildQualityGates:
    """Enforce quality gates for daily builds."""
    
    def validate_build_quality(self, build_artifacts: BuildArtifacts) -> QualityGateResult:
        """Validate build against all quality gates."""
        
        quality_checks = {
            "code_quality": self._validate_code_quality(build_artifacts),
            "test_coverage": self._validate_test_coverage(build_artifacts),
            "security_compliance": self._validate_security(build_artifacts),
            "performance_baseline": self._validate_performance(build_artifacts),
            "documentation_completeness": self._validate_documentation(build_artifacts),
            "dependency_health": self._validate_dependencies(build_artifacts)
        }
        
        # All quality gates must pass
        failed_gates = [gate for gate, passed in quality_checks.items() if not passed]
        
        if failed_gates:
            raise BuildQualityGateFailure(f"Failed quality gates: {failed_gates}")
        
        return QualityGateResult(
            status="PASSED",
            quality_score=self._calculate_quality_score(quality_checks),
            timestamp=datetime.utcnow(),
            build_id=build_artifacts.build_id
        )
    
    def _validate_code_quality(self, artifacts: BuildArtifacts) -> bool:
        """Validate code quality standards."""
        return (
            artifacts.code_coverage >= 0.90 and
            artifacts.linting_score >= 9.0 and
            artifacts.complexity_score <= 10 and
            artifacts.duplicate_code_ratio <= 0.03
        )
    
    def _validate_test_coverage(self, artifacts: BuildArtifacts) -> bool:
        """Validate test coverage requirements."""
        return (
            artifacts.unit_test_coverage >= 0.95 and
            artifacts.integration_test_coverage >= 0.90 and
            artifacts.test_pass_rate >= 0.99 and
            artifacts.test_execution_time <= 300  # 5 minutes max
        )
    
    def _validate_security(self, artifacts: BuildArtifacts) -> bool:
        """Validate security requirements."""
        return (
            artifacts.critical_vulnerabilities == 0 and
            artifacts.high_vulnerabilities == 0 and
            artifacts.medium_vulnerabilities <= 2 and
            artifacts.secret_exposure_count == 0
        )
    
    def _validate_performance(self, artifacts: BuildArtifacts) -> bool:
        """Validate performance baseline."""
        return (
            artifacts.response_time_p95 <= 2.0 and  # 2 seconds max
            artifacts.memory_usage_peak <= 512 and  # 512MB max
            artifacts.cpu_usage_peak <= 0.8 and     # 80% max
            artifacts.startup_time <= 30            # 30 seconds max
        )
```

### 4. Build Triggering Strategy
**MANDATORY**: Implement multiple build triggering mechanisms
```yaml
# REQUIRED: Build triggering configuration
build_triggers:
  scheduled_builds:
    - name: "Daily Morning Build"
      schedule: "0 8 * * 1-5"  # 8 AM, Monday-Friday
      branch: "main"
      priority: "high"
      notification: "all_stakeholders"
    
    - name: "End of Day Build"
      schedule: "0 18 * * 1-5"  # 6 PM, Monday-Friday
      branch: "develop"
      priority: "medium"
      notification: "development_team"
  
  event_triggered_builds:
    - name: "Main Branch Push"
      trigger: "push"
      branch: "main"
      immediate: true
      priority: "critical"
    
    - name: "Feature Branch Merge"
      trigger: "pull_request_merge"
      branches: ["develop", "main"]
      immediate: true
      priority: "high"
    
    - name: "Release Tag Creation"
      trigger: "tag_creation"
      pattern: "v*.*.*"
      immediate: true
      priority: "critical"
  
  manual_builds:
    - name: "Emergency Build"
      authorization_required: true
      notification: "all_stakeholders"
      priority: "critical"
    
    - name: "Release Candidate Build"
      authorization_required: true
      branch: "release/*"
      priority: "high"
```

### 5. Build Monitoring and Metrics
**MANDATORY**: Comprehensive build monitoring and metrics collection
```python
# REQUIRED: Build monitoring implementation
class DailyBuildMonitor:
    """Monitor and track daily build metrics."""
    
    def track_build_metrics(self, build_result: BuildResult) -> BuildMetrics:
        """Track comprehensive build metrics."""
        
        metrics = BuildMetrics(
            build_id=build_result.build_id,
            timestamp=build_result.timestamp,
            duration=build_result.duration,
            status=build_result.status,
            
            # Pipeline Metrics
            pipeline_metrics=PipelineMetrics(
                total_duration=build_result.pipeline_duration,
                stage_durations=build_result.stage_durations,
                queue_time=build_result.queue_time,
                resource_utilization=build_result.resource_usage
            ),
            
            # Quality Metrics
            quality_metrics=QualityMetrics(
                code_coverage=build_result.code_coverage,
                test_pass_rate=build_result.test_pass_rate,
                security_score=build_result.security_score,
                performance_score=build_result.performance_score
            ),
            
            # Business Metrics
            business_metrics=BusinessMetrics(
                deployability_score=build_result.deployability_score,
                feature_completeness=build_result.feature_completeness,
                story_points_completed=build_result.story_points_completed,
                velocity_impact=build_result.velocity_impact
            )
        )
        
        # Store metrics for trend analysis
        self.metrics_store.store_build_metrics(metrics)
        
        # Generate alerts for anomalies
        self._check_build_health_alerts(metrics)
        
        return metrics
    
    def generate_daily_build_report(self, date: datetime.date) -> DailyBuildReport:
        """Generate comprehensive daily build report."""
        
        builds = self.metrics_store.get_builds_for_date(date)
        
        return DailyBuildReport(
            date=date,
            total_builds=len(builds),
            successful_builds=len([b for b in builds if b.status == "SUCCESS"]),
            failed_builds=len([b for b in builds if b.status == "FAILED"]),
            average_duration=statistics.mean([b.duration for b in builds]),
            quality_trends=self._analyze_quality_trends(builds),
            performance_trends=self._analyze_performance_trends(builds),
            recommendations=self._generate_improvement_recommendations(builds)
        )
```

### 6. Deployment Integration
**MANDATORY**: Integrate builds with deployment pipeline
```yaml
# REQUIRED: Deployment integration configuration
deployment_integration:
  environment_strategy:
    development:
      auto_deploy: true
      on_build_success: true
      rollback_on_failure: true
      notification: "development_team"
    
    staging:
      auto_deploy: true
      on_main_branch_build: true
      manual_approval_required: false
      smoke_tests_required: true
    
    production:
      auto_deploy: false
      manual_approval_required: true
      change_management_required: true
      rollback_plan_required: true
  
  deployment_validation:
    health_checks:
      - "application_startup_validation"
      - "api_endpoint_availability"
      - "database_connectivity"
      - "external_service_integration"
      - "performance_baseline_validation"
    
    rollback_triggers:
      - "health_check_failure"
      - "error_rate_spike"
      - "performance_degradation"
      - "security_alert"
      - "manual_intervention"
```

### 7. Stakeholder Communication
**MANDATORY**: Comprehensive stakeholder communication
```python
# REQUIRED: Stakeholder notification system
class BuildCommunicationSystem:
    """Manage stakeholder communication for daily builds."""
    
    def notify_build_status(self, build_result: BuildResult) -> None:
        """Notify stakeholders of build status."""
        
        notification_rules = {
            "SUCCESS": {
                "channels": ["email", "slack", "dashboard"],
                "recipients": ["development_team", "product_owner", "scrum_master"],
                "urgency": "normal",
                "template": "build_success_template"
            },
            "FAILED": {
                "channels": ["email", "slack", "dashboard", "sms"],
                "recipients": ["development_team", "technical_lead", "devops_team"],
                "urgency": "high",
                "template": "build_failure_template"
            },
            "UNSTABLE": {
                "channels": ["email", "slack", "dashboard"],
                "recipients": ["development_team", "technical_lead"],
                "urgency": "medium",
                "template": "build_unstable_template"
            }
        }
        
        rule = notification_rules[build_result.status]
        
        message = self._generate_notification_message(build_result, rule["template"])
        
        for channel in rule["channels"]:
            self._send_notification(
                channel=channel,
                recipients=rule["recipients"],
                message=message,
                urgency=rule["urgency"]
            )
    
    def generate_daily_build_summary(self, date: datetime.date) -> DailyBuildSummary:
        """Generate daily build summary for stakeholders."""
        
        builds = self.build_store.get_builds_for_date(date)
        
        return DailyBuildSummary(
            date=date,
            total_builds=len(builds),
            success_rate=self._calculate_success_rate(builds),
            quality_score=self._calculate_average_quality_score(builds),
            deployment_count=self._count_deployments(builds),
            key_achievements=self._identify_key_achievements(builds),
            issues_identified=self._identify_issues(builds),
            recommendations=self._generate_recommendations(builds)
        )
```

### 8. Build Artifact Management
**MANDATORY**: Comprehensive artifact management
```yaml
# REQUIRED: Artifact management configuration
artifact_management:
  storage_strategy:
    local_storage:
      path: "./build_artifacts"
      retention: "30_days"
      compression: true
    
    cloud_storage:
      provider: "aws_s3"
      bucket: "ai-dev-agent-builds"
      retention: "1_year"
      versioning: true
    
    registry_storage:
      container_registry: true
      package_registry: true
      version_tagging: true
  
  artifact_types:
    - name: "application_package"
      format: "wheel"
      required: true
      testing_required: true
    
    - name: "container_image"
      format: "docker"
      required: true
      security_scanning: true
    
    - name: "deployment_manifest"
      format: "yaml"
      required: true
      validation_required: true
    
    - name: "test_reports"
      format: "html"
      required: true
      retention: "90_days"
    
    - name: "documentation"
      format: "html"
      required: true
      accessibility_check: true
```

### 9. Failure Recovery and Remediation
**MANDATORY**: Automated failure recovery and remediation
```python
# REQUIRED: Build failure recovery system
class BuildFailureRecovery:
    """Handle build failures and implement recovery strategies."""
    
    def handle_build_failure(self, build_failure: BuildFailure) -> RecoveryResult:
        """Handle build failure with automated recovery strategies."""
        
        recovery_strategies = {
            "dependency_failure": self._recover_dependency_issues,
            "test_failure": self._recover_test_failures,
            "compilation_failure": self._recover_compilation_issues,
            "quality_gate_failure": self._recover_quality_issues,
            "infrastructure_failure": self._recover_infrastructure_issues
        }
        
        failure_type = self._classify_failure(build_failure)
        recovery_strategy = recovery_strategies.get(failure_type)
        
        if recovery_strategy:
            recovery_result = recovery_strategy(build_failure)
            
            if recovery_result.success:
                # Trigger automatic rebuild
                self._trigger_recovery_build(build_failure.build_id)
                return recovery_result
        
        # Escalate to manual intervention
        self._escalate_build_failure(build_failure)
        return RecoveryResult(success=False, escalated=True)
    
    def _recover_dependency_issues(self, failure: BuildFailure) -> RecoveryResult:
        """Recover from dependency-related build failures."""
        
        recovery_actions = [
            self._clear_dependency_cache,
            self._update_dependency_lockfile,
            self._validate_dependency_compatibility,
            self._restore_known_good_dependencies
        ]
        
        for action in recovery_actions:
            try:
                action(failure)
                return RecoveryResult(success=True, action=action.__name__)
            except Exception as e:
                continue
        
        return RecoveryResult(success=False)
    
    def _recover_test_failures(self, failure: BuildFailure) -> RecoveryResult:
        """Recover from test-related build failures."""
        
        # Analyze test failures
        test_failures = self._analyze_test_failures(failure)
        
        # Classify failure types
        if test_failures.are_flaky_tests():
            # Retry flaky tests
            return self._retry_flaky_tests(test_failures)
        
        if test_failures.are_environmental_issues():
            # Reset test environment
            return self._reset_test_environment(test_failures)
        
        # Genuine test failures require manual intervention
        return RecoveryResult(success=False, requires_manual_fix=True)
```

### 10. Integration with Agile Practices
**MANDATORY**: Integration with agile development practices
```yaml
# REQUIRED: Agile integration requirements
agile_integration:
  sprint_alignment:
    - "Daily builds support sprint goals validation"
    - "Build status included in daily standup reports"
    - "Build quality metrics inform sprint retrospectives"
    - "Build deployment supports sprint demo preparation"
  
  user_story_validation:
    - "Each build validates completed user stories"
    - "Acceptance criteria tested in daily builds"
    - "Definition of Done includes successful build"
    - "User story status updated based on build results"
  
  velocity_tracking:
    - "Build success rate impacts velocity calculations"
    - "Build quality trends inform capacity planning"
    - "Deployment frequency supports release planning"
    - "Build metrics included in burn-down charts"
  
  continuous_improvement:
    - "Build failures trigger retrospective items"
    - "Build metrics inform process improvements"
    - "Build automation reduces manual effort"
    - "Build quality trends guide technical debt decisions"
```

## Implementation Guidelines

### 1. Build Pipeline Setup
**MANDATORY**: Implement complete build pipeline
```bash
# REQUIRED: Build pipeline implementation
#!/bin/bash
# daily_build_pipeline.sh

set -e  # Exit on any failure

echo "ðŸš€ Starting Daily Build Pipeline"

# Stage 1: Source Validation
echo "ðŸ“‹ Stage 1: Source Code Validation"
python -m black --check .
python -m isort --check-only .
python -m pylint src/ --fail-under=9.0
python -m mypy src/
python -m bandit -r src/ -f json -o security_report.json

# Stage 2: Build and Compilation
echo "ðŸ”¨ Stage 2: Build and Compilation"
python -m venv build_env
source build_env/bin/activate
pip install -r requirements.txt
pip install -e .

# Stage 3: Comprehensive Testing
echo "ðŸ§ª Stage 3: Comprehensive Testing"
python -m pytest tests/ --cov=src --cov-report=html --cov-fail-under=90
python -m pytest tests/integration/ --maxfail=1
python -m pytest tests/system/ --maxfail=1

# Stage 4: Quality Assurance
echo "ðŸ“Š Stage 4: Quality Assurance"
python -m coverage report --show-missing
python -m pytest tests/performance/ --benchmark-only

# Stage 5: Deployment Preparation
echo "ðŸ“¦ Stage 5: Deployment Preparation"
python setup.py bdist_wheel
docker build -t ai-dev-agent:daily-$(date +%Y%m%d) .

echo "âœ… Daily Build Pipeline Complete"
```

### 2. Quality Gate Configuration
**MANDATORY**: Configure comprehensive quality gates
```python
# REQUIRED: Quality gate configuration
DAILY_BUILD_QUALITY_GATES = {
    "code_quality": {
        "min_code_coverage": 0.90,
        "max_cyclomatic_complexity": 10,
        "max_duplicate_code_ratio": 0.03,
        "min_maintainability_index": 70
    },
    "test_quality": {
        "min_test_coverage": 0.95,
        "min_test_pass_rate": 0.99,
        "max_test_execution_time": 300,
        "min_assertion_coverage": 0.80
    },
    "security": {
        "max_critical_vulnerabilities": 0,
        "max_high_vulnerabilities": 0,
        "max_medium_vulnerabilities": 2,
        "max_secret_exposures": 0
    },
    "performance": {
        "max_response_time_p95": 2.0,
        "max_memory_usage_mb": 512,
        "max_cpu_usage_percent": 80,
        "max_startup_time_seconds": 30
    },
    "documentation": {
        "min_api_documentation_coverage": 1.0,
        "min_code_documentation_coverage": 0.90,
        "require_readme_updates": True,
        "require_changelog_updates": True
    }
}
```

### 3. Monitoring Dashboard
**MANDATORY**: Implement comprehensive monitoring dashboard
```python
# REQUIRED: Daily build monitoring dashboard
class DailyBuildDashboard:
    """Provide real-time visibility into daily build status."""
    
    def generate_dashboard_data(self) -> DashboardData:
        """Generate comprehensive dashboard data."""
        
        return DashboardData(
            current_build_status=self._get_current_build_status(),
            daily_build_metrics=self._get_daily_metrics(),
            weekly_trends=self._get_weekly_trends(),
            quality_trends=self._get_quality_trends(),
            deployment_status=self._get_deployment_status(),
            alerts_and_issues=self._get_active_alerts(),
            improvement_opportunities=self._identify_improvements()
        )
    
    def _get_current_build_status(self) -> BuildStatus:
        """Get current build status information."""
        
        current_build = self.build_service.get_current_build()
        
        return BuildStatus(
            build_id=current_build.id,
            status=current_build.status,
            progress=current_build.progress,
            estimated_completion=current_build.estimated_completion,
            current_stage=current_build.current_stage,
            elapsed_time=current_build.elapsed_time
        )
    
    def _get_daily_metrics(self) -> DailyMetrics:
        """Get today's build metrics."""
        
        today_builds = self.build_service.get_builds_for_today()
        
        return DailyMetrics(
            total_builds=len(today_builds),
            successful_builds=len([b for b in today_builds if b.status == "SUCCESS"]),
            failed_builds=len([b for b in today_builds if b.status == "FAILED"]),
            average_duration=statistics.mean([b.duration for b in today_builds]),
            quality_score=statistics.mean([b.quality_score for b in today_builds]),
            deployment_count=len([b for b in today_builds if b.deployed])
        )
```

## Benefits

### 1. Agile Alignment Benefits
- **Rapid Feedback**: Daily builds provide immediate feedback on code changes
- **Risk Reduction**: Early detection of integration and quality issues
- **Stakeholder Confidence**: Regular, visible progress through daily builds
- **Continuous Improvement**: Daily metrics inform process improvements
- **Sprint Support**: Builds support sprint goals and user story validation

### 2. Quality Assurance Benefits
- **Consistent Quality**: Daily quality gates ensure consistent standards
- **Automated Validation**: Comprehensive automated testing and validation
- **Trend Analysis**: Daily metrics enable quality trend analysis
- **Early Detection**: Issues identified and resolved quickly
- **Documentation Currency**: Documentation validated and updated daily

### 3. Deployment Readiness Benefits
- **Always Deployable**: Every successful build is potentially deployable
- **Reduced Deployment Risk**: Regular deployments reduce deployment risk
- **Faster Time to Market**: Rapid deployment capability
- **Environment Consistency**: Consistent build and deployment processes
- **Rollback Capability**: Automated rollback procedures for failed deployments

## Enforcement

### 1. Automated Enforcement
```bash
# REQUIRED: Automated enforcement checks
#!/bin/bash
# enforce_daily_build.sh

# Check if daily build occurred
if ! check_daily_build_completion; then
    echo "ERROR: Daily build requirement not met"
    trigger_emergency_build
    notify_stakeholders "DAILY_BUILD_MISSING"
    exit 1
fi

# Validate build quality
if ! validate_build_quality_gates; then
    echo "ERROR: Build quality gates not met"
    trigger_quality_remediation
    exit 1
fi

echo "âœ… Daily build requirements satisfied"
```

### 2. Quality Gates
- [ ] Daily build executed successfully
- [ ] All quality gates passed
- [ ] Build artifacts generated and stored
- [ ] Stakeholders notified of build status
- [ ] Deployment pipeline validated
- [ ] Metrics collected and analyzed
- [ ] Issues identified and escalated appropriately

### 3. Compliance Monitoring
- [ ] Build frequency meets daily requirement
- [ ] Build quality meets defined standards
- [ ] Build process follows agile principles
- [ ] Stakeholder communication completed
- [ ] Continuous improvement practices applied

## Integration with Existing Rules

### 1. Related Agile Rules
- **Agile Development Rule**: Daily builds support agile principles
- **Agile Sprint Management Rule**: Builds align with sprint goals
- **Continuous Improvement Rule**: Build metrics inform improvements
- **Live Documentation Updates Rule**: Build process updates documentation

### 2. Related Quality Rules
- **No Failing Tests Rule**: Builds must pass all tests
- **Quality Validation Rule**: Builds must meet quality standards
- **Performance Monitoring Rule**: Builds include performance validation
- **Security Assessment Rule**: Builds include security validation

### 3. Related Automation Rules
- **Full Automation Rule**: Build process is fully automated
- **Automated Commit Rule**: Builds triggered by commits
- **Health Monitoring Rule**: Build health monitored continuously

## Monitoring and Metrics

### Success Indicators:
- Daily build completion rate â‰¥ 95%
- Build success rate â‰¥ 90%
- Build duration â‰¤ 30 minutes
- Quality gate pass rate â‰¥ 95%
- Deployment success rate â‰¥ 95%
- Stakeholder satisfaction â‰¥ 90%

### Failure Indicators:
- Missing daily builds
- Build success rate < 80%
- Build duration > 60 minutes
- Quality gate failures > 10%
- Deployment failures > 5%
- Stakeholder complaints about build process

## Remember

**"Every day builds success, success builds confidence."**

**"Daily builds are the heartbeat of agile development."**

**"A day without a build is a day without progress."**

This rule is **ALWAYS APPLIED** and must be followed for all:
- Development work and code changes
- Sprint planning and execution
- Quality assurance and validation
- Deployment and release management
- Stakeholder communication and reporting
- Continuous improvement initiatives

**Violations of this rule require immediate remediation and process improvement.**