---
name: No Silent Errors and Mock Fallbacks Rule
description:
globs:
alwaysApply: true
---

# No Silent Errors and Mock Fallbacks Rule

**CRITICAL**: Never use silent error handling, mock fallbacks, or placeholder data that masks real parsing failures. All errors must be exposed and addressed properly to ensure system reliability and quality.

## Core Requirements

### 1. Error Exposure Requirements
**MANDATORY**: All errors must be exposed, never silenced
```python
# CORRECT: Expose errors immediately
try:
    result = parser.parse(response)
    return result
except Exception as e:
    logger.error(f"Parsing failed: {e}")
    raise OutputParserException(f"Failed to parse response: {e}")

# INCORRECT: Silent error handling with fallbacks
try:
    result = parser.parse(response)
    return result
except Exception as e:
    logger.warning(f"Parsing failed, using fallback: {e}")
    return get_fallback_data()  # NEVER DO THIS
```

### 2. Fallback Prohibition
**FORBIDDEN**: Mock fallbacks, placeholder data, or silent error recovery
```python
# FORBIDDEN: Mock fallback data
def _get_fallback_data(self):
    return {
        "status": "completed",
        "message": "Fallback data used",
        "data": {}  # Empty/mock data
    }

# FORBIDDEN: Silent error handling
except Exception as e:
    logger.warning(f"Error occurred: {e}")
    return {}  # Silent failure
```

### 3. Error Propagation Requirements

#### **Immediate Error Exposure**
```python
# MANDATORY: Always raise exceptions for parsing failures
def parse_response(self, response: str) -> Dict[str, Any]:
    try:
        # Primary parsing attempt
        return self._primary_parse(response)
    except Exception as e:
        # Log the error and re-raise
        self.logger.error(f"Primary parsing failed: {e}")
        raise OutputParserException(f"Failed to parse response: {e}")
```

#### **No Graceful Degradation**
```python
# FORBIDDEN: Graceful degradation with fallbacks
def parse_with_fallbacks(self, response: str):
    try:
        return self._primary_parse(response)
    except Exception as e:
        try:
            return self._secondary_parse(response)  # FORBIDDEN
        except Exception as e2:
            return self._get_fallback_data()  # FORBIDDEN
```

### 4. Error Handling Standards

#### **Exception Types**
```python
# MANDATORY: Use specific exception types
class OutputParserException(Exception):
    """Raised when output parsing fails."""
    pass

class ValidationException(Exception):
    """Raised when data validation fails."""
    pass

class FormatException(Exception):
    """Raised when output format is invalid."""
    pass
```

#### **Error Context Requirements**
```python
# MANDATORY: Include context in error messages
def parse_response(self, response: str, agent_type: str) -> Dict[str, Any]:
    try:
        return self._parse(response)
    except Exception as e:
        error_msg = f"Parsing failed for {agent_type}: {e}. Response: {response[:200]}..."
        raise OutputParserException(error_msg)
```

### 5. Logging Requirements

#### **Error Logging Standards**
```python
# MANDATORY: Comprehensive error logging
import logging

logger = logging.getLogger(__name__)

def parse_response(self, response: str) -> Dict[str, Any]:
    try:
        return self._parse(response)
    except Exception as e:
        logger.error(f"Parsing failed: {e}")
        logger.error(f"Response content: {response}")
        logger.error(f"Agent type: {self.agent_type}")
        logger.error(f"Parser configuration: {self.config}")
        raise  # Re-raise the exception
```

#### **No Warning-Only Logging**
```python
# FORBIDDEN: Warning-only logging for errors
except Exception as e:
    logger.warning(f"Parsing failed, continuing with fallback: {e}")  # FORBIDDEN
    return fallback_data

# CORRECT: Error logging with exception raising
except Exception as e:
    logger.error(f"Parsing failed: {e}")
    raise OutputParserException(f"Parsing failed: {e}")
```

### 6. Testing Requirements

#### **Error Testing**
```python
# MANDATORY: Test error conditions
def test_parsing_failure_exposure():
    """Test that parsing failures are properly exposed."""
    parser = OutputParser()
    
    # Test with invalid response
    with pytest.raises(OutputParserException):
        parser.parse("invalid response")
    
    # Test with malformed JSON
    with pytest.raises(OutputParserException):
        parser.parse('{"incomplete": json')
    
    # Test with missing required fields
    with pytest.raises(ValidationException):
        parser.parse('{"partial": "data"}')
```

#### **No Fallback Testing**
```python
# FORBIDDEN: Test fallback mechanisms
def test_fallback_mechanism():  # FORBIDDEN
    parser = OutputParser()
    result = parser.parse("invalid response")
    assert result == fallback_data  # FORBIDDEN

# CORRECT: Test error exposure
def test_error_exposure():
    parser = OutputParser()
    with pytest.raises(OutputParserException):
        parser.parse("invalid response")
```

### 7. Agent Integration Requirements

#### **Agent Error Handling**
```python
# MANDATORY: Agents must fail on parsing errors
def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
    try:
        response = await self._generate_response(state)
        parsed_response = self.parser.parse(response)
        return self._update_state(state, parsed_response)
    except OutputParserException as e:
        # Log the error and fail the agent
        self.logger.error(f"Agent {self.name} failed due to parsing error: {e}")
        raise AgentExecutionException(f"Agent {self.name} failed: {e}")
```

#### **No Agent Fallbacks**
```python
# FORBIDDEN: Agent fallback mechanisms
def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
    try:
        response = await self._generate_response(state)
        parsed_response = self.parser.parse(response)
        return self._update_state(state, parsed_response)
    except Exception as e:
        # FORBIDDEN: Agent fallback
        return self._get_fallback_state(state)  # NEVER DO THIS
```

### 8. Workflow Integration Requirements

#### **Workflow Error Propagation**
```python
# MANDATORY: Workflow must fail on agent errors
async def execute_workflow(self, state: Dict[str, Any]) -> Dict[str, Any]:
    for agent in self.agents:
        try:
            state = await agent.execute(state)
        except AgentExecutionException as e:
            # Log and fail the entire workflow
            self.logger.error(f"Workflow failed due to agent error: {e}")
            raise WorkflowExecutionException(f"Workflow failed: {e}")
    
    return state
```

#### **No Workflow Fallbacks**
```python
# FORBIDDEN: Workflow fallback mechanisms
async def execute_workflow(self, state: Dict[str, Any]) -> Dict[str, Any]:
    for agent in self.agents:
        try:
            state = await agent.execute(state)
        except Exception as e:
            # FORBIDDEN: Workflow fallback
            state = self._get_fallback_state(state)  # NEVER DO THIS
            continue  # NEVER DO THIS
    
    return state
```

### 9. Configuration Requirements

#### **Parser Configuration**
```python
# MANDATORY: Configure parsers to fail on errors
class OutputParser:
    def __init__(self, fail_on_error: bool = True):
        self.fail_on_error = True  # Always true, no option to disable
        self.allow_fallbacks = False  # Always false
        self.silent_errors = False  # Always false
```

#### **No Fallback Configuration**
```python
# FORBIDDEN: Fallback configuration options
class OutputParser:
    def __init__(self, 
                 fail_on_error: bool = True,  # OK
                 allow_fallbacks: bool = False,  # OK
                 silent_errors: bool = False):  # OK
        # FORBIDDEN: Allow fallback configuration
        if allow_fallbacks or silent_errors:
            raise ValueError("Fallbacks and silent errors are not allowed")
```

### 10. Code Review Requirements

#### **Mandatory Checks**
- [ ] No fallback data or mock responses
- [ ] No silent error handling
- [ ] All exceptions are properly raised
- [ ] Error logging is comprehensive
- [ ] No graceful degradation mechanisms
- [ ] No placeholder or default data

#### **Forbidden Patterns**
```python
# FORBIDDEN PATTERNS TO CHECK FOR:

# 1. Silent error handling
except Exception as e:
    logger.warning(f"Error: {e}")
    return default_data

# 2. Fallback mechanisms
except Exception as e:
    return self._get_fallback_data()

# 3. Graceful degradation
except Exception as e:
    return self._degrade_gracefully()

# 4. Warning-only logging for errors
except Exception as e:
    logger.warning(f"Error occurred: {e}")
    continue

# 5. Empty error handling
except Exception:
    pass  # Silent ignore
```

### 11. Implementation Guidelines

#### **Error Handling Template**
```python
# CORRECT ERROR HANDLING TEMPLATE
def parse_response(self, response: str) -> Dict[str, Any]:
    """
    Parse response with proper error handling.
    
    Args:
        response: The response to parse
        
    Returns:
        Parsed response data
        
    Raises:
        OutputParserException: If parsing fails
        ValidationException: If validation fails
    """
    try:
        # Primary parsing attempt
        parsed_data = self._primary_parse(response)
        
        # Validate the parsed data
        validated_data = self._validate_data(parsed_data)
        
        return validated_data
        
    except Exception as e:
        # Log comprehensive error information
        self.logger.error(f"Parsing failed: {e}")
        self.logger.error(f"Response: {response}")
        self.logger.error(f"Parser state: {self._get_parser_state()}")
        
        # Re-raise with context
        raise OutputParserException(f"Failed to parse response: {e}")
```

#### **Agent Error Handling Template**
```python
# CORRECT AGENT ERROR HANDLING TEMPLATE
async def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute agent with proper error handling.
    
    Args:
        state: Current workflow state
        
    Returns:
        Updated workflow state
        
    Raises:
        AgentExecutionException: If agent execution fails
    """
    try:
        # Generate response
        response = await self._generate_response(state)
        
        # Parse response
        parsed_response = self.parser.parse(response)
        
        # Update state
        updated_state = self._update_state(state, parsed_response)
        
        return updated_state
        
    except Exception as e:
        # Log comprehensive error information
        self.logger.error(f"Agent {self.name} execution failed: {e}")
        self.logger.error(f"Current state: {state}")
        self.logger.error(f"Agent configuration: {self.config}")
        
        # Raise agent execution exception
        raise AgentExecutionException(f"Agent {self.name} failed: {e}")
```

### 12. Benefits

- **Improved Reliability**: No hidden failures or silent errors
- **Better Debugging**: All errors are exposed and logged
- **Quality Assurance**: Forces proper error handling and validation
- **System Transparency**: Clear visibility into all failures
- **Maintenance**: Easier to identify and fix issues

### 13. Enforcement

This rule is **ALWAYS APPLIED** and must be followed for all:
- Parser implementations
- Agent error handling
- Workflow error handling
- Testing procedures
- Code reviews
- Configuration management

**Violations of this rule require immediate remediation and removal of all fallback mechanisms.**

### 14. Migration Guide

#### **Removing Existing Fallbacks**
1. **Identify Fallback Code**: Find all fallback mechanisms
2. **Replace with Exceptions**: Convert fallbacks to proper exceptions
3. **Update Error Handling**: Ensure all errors are properly logged and raised
4. **Update Tests**: Remove fallback tests, add error exposure tests
5. **Update Documentation**: Remove references to fallback mechanisms

#### **Example Migration**
```python
# BEFORE: With fallbacks
def parse_response(self, response: str):
    try:
        return self._parse(response)
    except Exception as e:
        logger.warning(f"Parsing failed: {e}")
        return self._get_fallback_data()

# AFTER: Without fallbacks
def parse_response(self, response: str):
    try:
        return self._parse(response)
    except Exception as e:
        logger.error(f"Parsing failed: {e}")
        raise OutputParserException(f"Failed to parse response: {e}")
```

**Remember**: The goal is to expose all errors, not hide them. This ensures system reliability and forces proper error handling and validation.
