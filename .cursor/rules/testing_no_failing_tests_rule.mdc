# No Failing Tests Rule

## Description
Maintain zero failing tests policy - all tests must pass before any code changes.

## Core Requirements

### 1. Zero Failing Tests Policy
- **All tests must pass** before any code changes
- **Immediate fix** of any test failures
- **No exceptions** - even minor test failures must be fixed
- **Regression testing** for all changes
- **Quality gates** for test requirements

### 2. Test Quality Standards
- **Comprehensive coverage** for all components
- **Meaningful tests** - test actual functionality, not just syntax
- **Fast execution** - tests should run quickly
- **Reliable results** - tests should be deterministic
- **Clear failure messages** - easy to understand what failed

### 3. Test Maintenance
- **Regular test updates** - keep tests current with code changes
- **Test refactoring** - improve test quality and maintainability
- **Test documentation** - clear test purpose and requirements
- **Test organization** - logical test structure and naming
- **Test performance** - monitor and optimize test execution

### 4. Test Monitoring
- **Automated test execution** - run tests automatically
- **Immediate failure detection** - stop on first failure
- **Comprehensive reporting** - detailed failure information
- **Performance tracking** - monitor test execution times
- **Coverage reporting** - track test coverage metrics

### 5. Test-Driven Development
- **Write tests first** - before implementing functionality
- **Test-driven design** - let tests guide implementation
- **Continuous testing** - test throughout development
- **Test validation** - ensure tests are meaningful
- **Test improvement** - continuously improve test quality

## Implementation Guidelines

### Test Execution Process
```bash
# Run all tests and stop on first failure
python -m pytest tests/ -x --tb=short

# Run specific test types
python -m pytest tests/unit/ -x
python -m pytest tests/integration/ -x
python -m pytest tests/system/ -x

# Run with coverage
python -m pytest tests/ --cov=. --cov-report=html
```

### Test Quality Checklist
- [ ] **All tests pass** - no failing tests
- [ ] **Comprehensive coverage** - 90%+ coverage for core components
- [ ] **Fast execution** - tests complete in reasonable time
- [ ] **Reliable results** - tests are deterministic
- [ ] **Clear failures** - easy to understand what failed
- [ ] **Meaningful tests** - test actual functionality
- [ ] **Well organized** - logical test structure
- [ ] **Documented** - clear test purpose and requirements

### Test Failure Response
1. **Stop immediately** - don't continue with failing tests
2. **Analyze failure** - understand what went wrong
3. **Fix the issue** - address the root cause
4. **Re-run tests** - confirm the fix works
5. **Update tests** - improve test quality if needed
6. **Document changes** - record what was fixed

## Benefits

### Quality Improvements
- **Maintains code quality** - forces attention to detail
- **Prevents regressions** - catches issues early
- **Ensures reliability** - consistent functionality
- **Improves maintainability** - well-tested code is easier to maintain

### Development Efficiency
- **Faster debugging** - immediate feedback on issues
- **Confident changes** - know changes don't break existing functionality
- **Better design** - test-driven development improves design
- **Reduced technical debt** - prevents accumulation of issues

### Team Productivity
- **Clear standards** - everyone knows what's expected
- **Reduced conflicts** - fewer integration issues
- **Faster onboarding** - tests serve as documentation
- **Better collaboration** - shared understanding of requirements

## Application

### When to Apply
- **Before any code changes** - ensure tests pass first
- **During development** - continuous testing
- **Before commits** - validate changes don't break tests
- **Before deployments** - ensure production readiness
- **During refactoring** - maintain functionality during changes

### How to Apply
1. **Run tests first** - before making any changes
2. **Fix any failures** - address issues immediately
3. **Write tests for new features** - test-driven development
4. **Update existing tests** - keep tests current
5. **Monitor test performance** - optimize execution times

### Success Criteria
- **Zero failing tests** - all tests pass consistently
- **High test coverage** - 90%+ coverage for core components
- **Fast test execution** - tests complete quickly
- **Reliable results** - tests are deterministic
- **Clear failure messages** - easy to understand what failed
- **Meaningful tests** - test actual functionality
- **Well organized** - logical test structure and naming

## Enforcement

### Automated Enforcement
- **CI/CD integration** - automated test execution
- **Pre-commit hooks** - run tests before commits
- **Quality gates** - block changes with failing tests
- **Monitoring** - track test status continuously

### Manual Enforcement
- **Code reviews** - verify tests are included
- **Team standards** - shared commitment to test quality
- **Documentation** - clear test requirements and standards
- **Training** - ensure team understands test importance

---

**This rule ensures that code quality is maintained through comprehensive testing and zero tolerance for test failures.**
description: Zero failing tests policy
globs: ["tests/*.py", "**/*test*.py"]
alwaysApply: true
--- 
description:
globs:
alwaysApply: true
---
