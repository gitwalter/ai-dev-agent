# Development Environment Optimization Rule

## Description
Always use the correct and best commands for the environment we're working in, ensuring fast and efficient operation.

## Core Requirements

### 1. Environment-Aware Command Selection
- **Use correct Python path** - Always use `C:\App\Anaconda\python.exe` on Windows
- **Use correct conda path** - Always use `C:\App\Anaconda\Scripts\conda.exe`
- **Use correct pip path** - Always use `C:\App\Anaconda\Scripts\pip.exe`
- **Environment activation** - Always activate environments before running scripts
- **Path validation** - Verify correct paths are being used

### 2. Fast and Efficient Commands
- **Optimized test execution** - Use `-x` flag to stop on first failure
- **Parallel execution** - Use `-n auto` for parallel test execution when appropriate
- **Verbose output** - Use `-v` for detailed output when debugging
- **Coverage reporting** - Use `--cov` for test coverage analysis
- **Performance monitoring** - Use timing flags for performance analysis

### 3. Best Practice Command Patterns
- **Consistent command structure** - Use standardized command patterns
- **Error handling** - Include proper error handling in commands
- **Logging** - Use appropriate logging levels and formats
- **Cleanup** - Always clean up temporary files and processes
- **Resource management** - Properly manage system resources

### 4. Environment-Specific Optimizations
- **Windows optimizations** - Use Windows-specific optimizations
- **Anaconda optimizations** - Leverage Anaconda-specific features
- **Python optimizations** - Use Python-specific performance features
- **IDE optimizations** - Use IDE-specific features for efficiency
- **System optimizations** - Use system-specific performance features

### 5. Command Validation and Testing
- **Command validation** - Verify commands work before using in production
- **Command testing** - Test commands in isolated environments
- **Performance testing** - Test command performance and optimize
- **Error testing** - Test error handling and recovery
- **Integration testing** - Test commands in full workflow

## Implementation Guidelines

### Environment Setup and Validation
```python
class EnvironmentOptimizer:
    """Optimize development environment for fast and efficient operation."""
    
    def __init__(self):
        self.platform = self.detect_platform()
        self.python_path = self.get_correct_python_path()
        self.conda_path = self.get_correct_conda_path()
        self.pip_path = self.get_correct_pip_path()
    
    def detect_platform(self):
        """Detect the current platform."""
        import platform
        return platform.system().lower()
    
    def get_correct_python_path(self):
        """Get the correct Python path for the environment."""
        if self.platform == "windows":
            return r"C:\App\Anaconda\python.exe"
        else:
            return "python"  # Use system Python on other platforms
    
    def get_correct_conda_path(self):
        """Get the correct conda path for the environment."""
        if self.platform == "windows":
            return r"C:\App\Anaconda\Scripts\conda.exe"
        else:
            return "conda"
    
    def get_correct_pip_path(self):
        """Get the correct pip path for the environment."""
        if self.platform == "windows":
            return r"C:\App\Anaconda\Scripts\pip.exe"
        else:
            return "pip"
    
    def validate_environment(self):
        """Validate that the environment is correctly configured."""
        validation_results = {
            'python_path': self.validate_python_path(),
            'conda_path': self.validate_conda_path(),
            'pip_path': self.validate_pip_path(),
            'environment_activated': self.validate_environment_activation()
        }
        
        return validation_results
```

### Optimized Command Execution
```python
class OptimizedCommandExecutor:
    """Execute commands with optimal performance and error handling."""
    
    def __init__(self, environment_optimizer):
        self.env_opt = environment_optimizer
        self.command_cache = {}
        self.performance_metrics = {}
    
    async def execute_optimized_test_command(self, test_path: str, options: dict = None):
        """Execute test command with optimal settings."""
        default_options = {
            'stop_on_failure': True,
            'verbose': False,
            'parallel': False,
            'coverage': False,
            'performance_monitoring': False
        }
        
        if options:
            default_options.update(options)
        
        # Build optimized command
        command_parts = [self.env_opt.python_path, "-m", "pytest", test_path]
        
        if default_options['stop_on_failure']:
            command_parts.append("-x")
        
        if default_options['verbose']:
            command_parts.append("-v")
        
        if default_options['parallel']:
            command_parts.extend(["-n", "auto"])
        
        if default_options['coverage']:
            command_parts.extend(["--cov=.", "--cov-report=html"])
        
        if default_options['performance_monitoring']:
            command_parts.append("--durations=10")
        
        command = " ".join(command_parts)
        
        # Execute with performance monitoring
        start_time = time.time()
        result = await self.execute_command(command)
        execution_time = time.time() - start_time
        
        # Record performance metrics
        self.performance_metrics[command] = {
            'execution_time': execution_time,
            'success': result['success'],
            'timestamp': datetime.now()
        }
        
        return result
    
    async def execute_command(self, command: str):
        """Execute command with proper error handling and logging."""
        try:
            # Log command execution
            logger.info(f"Executing command: {command}")
            
            # Execute command
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            result = {
                'success': process.returncode == 0,
                'stdout': stdout.decode() if stdout else '',
                'stderr': stderr.decode() if stderr else '',
                'return_code': process.returncode,
                'command': command
            }
            
            # Log results
            if result['success']:
                logger.info(f"Command succeeded: {command}")
            else:
                logger.error(f"Command failed: {command}")
                logger.error(f"Error: {result['stderr']}")
            
            return result
            
        except Exception as e:
            logger.error(f"Error executing command {command}: {e}")
            return {
                'success': False,
                'error': str(e),
                'command': command
            }
```

### Performance Optimization System
```python
class PerformanceOptimizer:
    """Optimize command performance and execution speed."""
    
    def __init__(self):
        self.performance_cache = {}
        self.optimization_rules = self.load_optimization_rules()
    
    def optimize_command(self, command: str, context: dict = None):
        """Optimize command for best performance."""
        optimized_command = command
        
        # Apply platform-specific optimizations
        if self.is_windows():
            optimized_command = self.apply_windows_optimizations(optimized_command)
        
        # Apply Python-specific optimizations
        optimized_command = self.apply_python_optimizations(optimized_command)
        
        # Apply context-specific optimizations
        if context:
            optimized_command = self.apply_context_optimizations(optimized_command, context)
        
        return optimized_command
    
    def apply_windows_optimizations(self, command: str):
        """Apply Windows-specific optimizations."""
        # Use correct paths
        command = command.replace("python", r"C:\App\Anaconda\python.exe")
        command = command.replace("conda", r"C:\App\Anaconda\Scripts\conda.exe")
        command = command.replace("pip", r"C:\App\Anaconda\Scripts\pip.exe")
        
        # Add Windows-specific flags
        if "pytest" in command and "-x" not in command:
            command += " -x"  # Stop on first failure
        
        return command
    
    def apply_python_optimizations(self, command: str):
        """Apply Python-specific optimizations."""
        # Add performance monitoring
        if "pytest" in command and "--durations" not in command:
            command += " --durations=10"
        
        # Add memory optimization
        if "python" in command and "-O" not in command:
            command = command.replace("python", "python -O")
        
        return command
    
    def apply_context_optimizations(self, command: str, context: dict):
        """Apply context-specific optimizations."""
        # Add parallel execution for large test suites
        if context.get('large_test_suite', False) and "pytest" in command:
            command += " -n auto"
        
        # Add coverage for development context
        if context.get('development_mode', False) and "pytest" in command:
            command += " --cov=. --cov-report=html"
        
        return command
```

### Command Validation System
```python
class CommandValidator:
    """Validate commands before execution."""
    
    def __init__(self):
        self.validation_rules = self.load_validation_rules()
    
    def validate_command(self, command: str, context: dict = None):
        """Validate command before execution."""
        validation_results = {
            'valid': True,
            'warnings': [],
            'errors': [],
            'suggestions': []
        }
        
        # Check command syntax
        syntax_check = self.check_command_syntax(command)
        if not syntax_check['valid']:
            validation_results['valid'] = False
            validation_results['errors'].extend(syntax_check['errors'])
        
        # Check environment compatibility
        env_check = self.check_environment_compatibility(command)
        if not env_check['valid']:
            validation_results['valid'] = False
            validation_results['errors'].extend(env_check['errors'])
        
        # Check performance implications
        perf_check = self.check_performance_implications(command)
        validation_results['warnings'].extend(perf_check['warnings'])
        validation_results['suggestions'].extend(perf_check['suggestions'])
        
        return validation_results
    
    def check_command_syntax(self, command: str):
        """Check command syntax for validity."""
        # Basic syntax validation
        if not command or command.strip() == "":
            return {'valid': False, 'errors': ['Empty command']}
        
        # Check for dangerous commands
        dangerous_patterns = ['rm -rf /', 'del /s /q', 'format']
        for pattern in dangerous_patterns:
            if pattern in command.lower():
                return {'valid': False, 'errors': [f'Dangerous command pattern: {pattern}']}
        
        return {'valid': True, 'errors': []}
```

## Benefits

### Performance Benefits
- **Faster execution** - Optimized commands run faster
- **Better resource usage** - Efficient use of system resources
- **Reduced wait times** - Minimize time spent waiting for commands
- **Parallel execution** - Use parallel processing when appropriate
- **Caching** - Cache results for faster subsequent execution

### Efficiency Benefits
- **Correct paths** - Always use the right tools for the environment
- **Optimized settings** - Use best settings for each command
- **Error prevention** - Validate commands before execution
- **Consistent behavior** - Predictable command execution
- **Automated optimization** - Automatic performance optimization

### Quality Benefits
- **Reliable execution** - Commands work consistently
- **Error handling** - Proper error handling and recovery
- **Performance monitoring** - Track and optimize performance
- **Validation** - Validate commands before execution
- **Documentation** - Document command patterns and optimizations

## Application

### When to Apply
- **Command execution** - Apply optimizations to all commands
- **Environment setup** - Optimize environment configuration
- **Performance tuning** - Continuously optimize performance
- **Error resolution** - Use optimized commands for troubleshooting
- **Development workflow** - Optimize entire development workflow

### How to Apply
1. **Validate environment** - Ensure correct paths and configuration
2. **Optimize commands** - Apply performance optimizations
3. **Monitor performance** - Track command performance
4. **Validate commands** - Check commands before execution
5. **Document patterns** - Document successful command patterns

### Success Criteria
- **Fast execution** - Commands execute quickly and efficiently
- **Correct paths** - Always use correct tools for the environment
- **Error-free execution** - Commands execute without errors
- **Performance optimization** - Continuous performance improvement
- **Consistent behavior** - Predictable and reliable command execution

---

**This rule ensures that we always use the correct and best commands for fast, efficient, and reliable operation in our development environment.**
description: Environment optimization and command efficiency
globs: ["**/*.py", "**/*.sh", "**/*.bat", "**/*.ps1"]
alwaysApply: true
---
description:
globs:
alwaysApply: true
---
