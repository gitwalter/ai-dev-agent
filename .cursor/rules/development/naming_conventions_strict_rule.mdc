# Strict Naming Conventions Rule

## Description
Enforce strict naming conventions for all code elements to ensure software is readable, attractive, clear, structured, and always testable. Follow industry best practices and language-specific conventions.

## Core Requirements

### 1. File and Directory Naming
- **Python files**: Use snake_case (e.g., `user_management.py`, `data_processor.py`)
- **Test files**: Prefix with `test_` (e.g., `test_user_management.py`, `test_data_processor.py`)
- **Directories**: Use snake_case (e.g., `user_management/`, `data_processing/`)
- **Configuration files**: Use descriptive names (e.g., `database_config.py`, `api_settings.py`)
- **Documentation files**: Use descriptive names (e.g., `README.md`, `API_DOCUMENTATION.md`)

### 2. Class Naming (PascalCase)
- **Clear and descriptive**: `UserAccountManager`, `DataProcessor`, `ApiClient`
- **Avoid abbreviations**: `UserMgr` → `UserManager`, `DataProc` → `DataProcessor`
- **Indicate purpose**: `UserAuthenticationService`, `DatabaseConnectionPool`
- **Test classes**: Prefix with `Test` (e.g., `TestUserAccountManager`, `TestDataProcessor`)
- **Abstract classes**: Prefix with `Abstract` or `Base` (e.g., `AbstractUserService`, `BaseProcessor`)

### 3. Function and Method Naming (snake_case)
- **Verb-based actions**: `create_user()`, `process_data()`, `validate_input()`
- **Clear purpose**: `authenticate_user_credentials()`, `transform_data_format()`
- **Boolean functions**: Use `is_`, `has_`, `can_` prefixes (e.g., `is_valid()`, `has_permission()`)
- **Getter methods**: Use descriptive names (e.g., `get_user_by_id()`, `get_active_connections()`)
- **Setter methods**: Use descriptive names (e.g., `set_user_status()`, `update_configuration()`)

### 4. Variable Naming (snake_case)
- **Descriptive and clear**: `user_id`, `connection_pool`, `api_response`
- **Avoid single letters**: `i` → `index`, `x` → `coordinate_x`, `d` → `data`
- **Constants**: Use UPPER_SNAKE_CASE (e.g., `MAX_CONNECTIONS`, `DEFAULT_TIMEOUT`)
- **Type indicators**: Use suffixes when helpful (e.g., `user_list`, `config_dict`, `response_json`)
- **Boolean variables**: Use `is_`, `has_`, `can_` prefixes (e.g., `is_authenticated`, `has_permission`)

### 5. Module and Package Naming
- **Lowercase with underscores**: `user_management`, `data_processing`, `api_client`
- **Avoid hyphens**: `user-management` → `user_management`
- **Descriptive**: `database_connection_pool`, `authentication_service`
- **Test modules**: Prefix with `test_` (e.g., `test_user_management`, `test_data_processing`)

### 6. Database and API Naming
- **Tables**: Use snake_case (e.g., `user_accounts`, `order_items`)
- **Columns**: Use snake_case (e.g., `user_id`, `created_at`, `is_active`)
- **API endpoints**: Use kebab-case (e.g., `/user-management`, `/data-processing`)
- **API parameters**: Use snake_case (e.g., `user_id`, `page_size`, `sort_order`)

### 7. Configuration and Environment Variables
- **Environment variables**: Use UPPER_SNAKE_CASE (e.g., `DATABASE_URL`, `API_KEY`)
- **Configuration keys**: Use snake_case (e.g., `database_url`, `api_key`)
- **Feature flags**: Use descriptive names (e.g., `ENABLE_DEBUG_MODE`, `USE_CACHE`)

### 8. Test Naming Conventions
- **Test functions**: Use descriptive names (e.g., `test_create_user_with_valid_data()`)
- **Test classes**: Prefix with `Test` (e.g., `TestUserAccountManager`)
- **Test files**: Prefix with `test_` (e.g., `test_user_management.py`)
- **Test data**: Use descriptive names (e.g., `valid_user_data`, `invalid_email_data`)
- **Mock objects**: Use descriptive names (e.g., `mock_user_service`, `mock_database_connection`)

## Implementation Guidelines

### Naming Convention Enforcer
```python
class NamingConventionEnforcer:
    """Enforce strict naming conventions across the codebase."""
    
    def __init__(self):
        self.python_conventions = PythonNamingConventions()
        self.test_conventions = TestNamingConventions()
        self.database_conventions = DatabaseNamingConventions()
        self.api_conventions = ApiNamingConventions()
    
    async def validate_file_naming(self, file_path: str):
        """Validate file naming conventions."""
        filename = Path(file_path).name
        
        if filename.endswith('.py'):
            return await self.python_conventions.validate_filename(filename)
        elif filename.endswith('.md'):
            return await self.validate_documentation_filename(filename)
        elif filename.endswith('.yml') or filename.endswith('.yaml'):
            return await self.validate_config_filename(filename)
        
        return {'valid': True, 'message': 'File type not requiring validation'}
    
    async def validate_class_naming(self, class_name: str, context: str = 'general'):
        """Validate class naming conventions."""
        validation_result = {
            'valid': True,
            'issues': [],
            'suggestions': []
        }
        
        # Check PascalCase
        if not self.is_pascal_case(class_name):
            validation_result['valid'] = False
            validation_result['issues'].append(f"Class name '{class_name}' should use PascalCase")
            validation_result['suggestions'].append(self.convert_to_pascal_case(class_name))
        
        # Check for abbreviations
        abbreviations = self.find_abbreviations(class_name)
        if abbreviations:
            validation_result['issues'].append(f"Class name contains abbreviations: {abbreviations}")
            validation_result['suggestions'].append(self.expand_abbreviations(class_name))
        
        # Check descriptiveness
        if len(class_name) < 3:
            validation_result['valid'] = False
            validation_result['issues'].append("Class name too short")
        
        # Context-specific validation
        if context == 'test':
            if not class_name.startswith('Test'):
                validation_result['valid'] = False
                validation_result['issues'].append("Test class should start with 'Test'")
        
        return validation_result
    
    async def validate_function_naming(self, function_name: str, context: str = 'general'):
        """Validate function naming conventions."""
        validation_result = {
            'valid': True,
            'issues': [],
            'suggestions': []
        }
        
        # Check snake_case
        if not self.is_snake_case(function_name):
            validation_result['valid'] = False
            validation_result['issues'].append(f"Function name '{function_name}' should use snake_case")
            validation_result['suggestions'].append(self.convert_to_snake_case(function_name))
        
        # Check for verb-based naming
        if not self.starts_with_verb(function_name):
            validation_result['issues'].append("Function name should start with a verb")
            validation_result['suggestions'].append(self.suggest_verb_prefix(function_name))
        
        # Check descriptiveness
        if len(function_name) < 3:
            validation_result['valid'] = False
            validation_result['issues'].append("Function name too short")
        
        # Context-specific validation
        if context == 'test':
            if not function_name.startswith('test_'):
                validation_result['valid'] = False
                validation_result['issues'].append("Test function should start with 'test_'")
        
        return validation_result
    
    async def validate_variable_naming(self, variable_name: str, context: str = 'general'):
        """Validate variable naming conventions."""
        validation_result = {
            'valid': True,
            'issues': [],
            'suggestions': []
        }
        
        # Check snake_case
        if not self.is_snake_case(variable_name):
            validation_result['valid'] = False
            validation_result['issues'].append(f"Variable name '{variable_name}' should use snake_case")
            validation_result['suggestions'].append(self.convert_to_snake_case(variable_name))
        
        # Check for single letter variables
        if len(variable_name) == 1 and not self.is_acceptable_single_letter(variable_name):
            validation_result['valid'] = False
            validation_result['issues'].append("Single letter variables should be avoided")
            validation_result['suggestions'].append(self.suggest_descriptive_name(variable_name))
        
        # Check descriptiveness
        if len(variable_name) < 2:
            validation_result['valid'] = False
            validation_result['issues'].append("Variable name too short")
        
        # Context-specific validation
        if context == 'constant':
            if not self.is_upper_snake_case(variable_name):
                validation_result['valid'] = False
                validation_result['issues'].append("Constants should use UPPER_SNAKE_CASE")
                validation_result['suggestions'].append(self.convert_to_upper_snake_case(variable_name))
        
        return validation_result
    
    def is_pascal_case(self, name: str) -> bool:
        """Check if name follows PascalCase convention."""
        if not name or not name[0].isupper():
            return False
        return all(c.isalnum() for c in name) and not '_' in name
    
    def is_snake_case(self, name: str) -> bool:
        """Check if name follows snake_case convention."""
        if not name:
            return False
        return all(c.isalnum() or c == '_' for c in name) and not name.startswith('_')
    
    def is_upper_snake_case(self, name: str) -> bool:
        """Check if name follows UPPER_SNAKE_CASE convention."""
        if not name:
            return False
        return all(c.isupper() or c == '_' for c in name) and not name.startswith('_')
    
    def starts_with_verb(self, name: str) -> bool:
        """Check if function name starts with a verb."""
        common_verbs = [
            'get', 'set', 'create', 'update', 'delete', 'remove', 'add', 'find',
            'validate', 'process', 'transform', 'convert', 'parse', 'format',
            'send', 'receive', 'connect', 'disconnect', 'open', 'close',
            'start', 'stop', 'pause', 'resume', 'init', 'clean', 'build',
            'test', 'mock', 'stub', 'assert', 'expect', 'verify', 'check'
        ]
        return any(name.lower().startswith(verb) for verb in common_verbs)
    
    def find_abbreviations(self, name: str) -> list:
        """Find abbreviations in a name."""
        abbreviations = []
        words = name.replace('_', ' ').split()
        
        for word in words:
            if len(word) <= 3 and word.isupper():
                abbreviations.append(word)
        
        return abbreviations
    
    def convert_to_pascal_case(self, name: str) -> str:
        """Convert name to PascalCase."""
        words = name.replace('_', ' ').replace('-', ' ').split()
        return ''.join(word.capitalize() for word in words)
    
    def convert_to_snake_case(self, name: str) -> str:
        """Convert name to snake_case."""
        import re
        name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
        return name.lower().replace('-', '_')
    
    def convert_to_upper_snake_case(self, name: str) -> str:
        """Convert name to UPPER_SNAKE_CASE."""
        return self.convert_to_snake_case(name).upper()
```

### Automated Naming Validation
```python
class AutomatedNamingValidator:
    """Automatically validate naming conventions in code."""
    
    def __init__(self):
        self.enforcer = NamingConventionEnforcer()
        self.code_parser = CodeParser()
        self.suggestion_generator = NamingSuggestionGenerator()
    
    async def validate_file(self, file_path: str):
        """Validate naming conventions in a file."""
        validation_results = {
            'file_path': file_path,
            'overall_valid': True,
            'issues': [],
            'suggestions': []
        }
        
        # Parse the file
        code_elements = await self.code_parser.parse_file(file_path)
        
        # Validate each element
        for element in code_elements:
            element_validation = await self.validate_element(element)
            validation_results['issues'].extend(element_validation['issues'])
            validation_results['suggestions'].extend(element_validation['suggestions'])
            
            if not element_validation['valid']:
                validation_results['overall_valid'] = False
        
        return validation_results
    
    async def validate_element(self, element: dict):
        """Validate a single code element."""
        element_type = element['type']
        element_name = element['name']
        context = element.get('context', 'general')
        
        if element_type == 'class':
            return await self.enforcer.validate_class_naming(element_name, context)
        elif element_type == 'function':
            return await self.enforcer.validate_function_naming(element_name, context)
        elif element_type == 'variable':
            return await self.enforcer.validate_variable_naming(element_name, context)
        elif element_type == 'module':
            return await self.enforcer.validate_module_naming(element_name)
        
        return {'valid': True, 'issues': [], 'suggestions': []}
    
    async def generate_renaming_suggestions(self, file_path: str):
        """Generate suggestions for renaming elements."""
        validation_results = await self.validate_file(file_path)
        suggestions = []
        
        for issue in validation_results['issues']:
            suggestion = await self.suggestion_generator.generate_suggestion(issue)
            suggestions.append(suggestion)
        
        return suggestions
```

### Naming Convention Documentation
```python
class NamingConventionDocumentation:
    """Generate and maintain naming convention documentation."""
    
    def __init__(self):
        self.template_generator = DocumentationTemplateGenerator()
        self.example_generator = ExampleGenerator()
    
    async def generate_naming_guide(self):
        """Generate comprehensive naming convention guide."""
        guide = {
            'title': 'Naming Conventions Guide',
            'sections': [
                await self.generate_file_naming_section(),
                await self.generate_class_naming_section(),
                await self.generate_function_naming_section(),
                await self.generate_variable_naming_section(),
                await self.generate_test_naming_section(),
                await self.generate_database_naming_section(),
                await self.generate_api_naming_section()
            ]
        }
        
        return guide
    
    async def generate_file_naming_section(self):
        """Generate file naming conventions section."""
        return {
            'title': 'File and Directory Naming',
            'conventions': [
                {
                    'type': 'Python files',
                    'pattern': 'snake_case',
                    'examples': ['user_management.py', 'data_processor.py', 'api_client.py'],
                    'rationale': 'Consistent with Python community standards'
                },
                {
                    'type': 'Test files',
                    'pattern': 'test_*.py',
                    'examples': ['test_user_management.py', 'test_data_processor.py'],
                    'rationale': 'Clear identification of test files'
                },
                {
                    'type': 'Directories',
                    'pattern': 'snake_case',
                    'examples': ['user_management/', 'data_processing/', 'api_client/'],
                    'rationale': 'Consistent with file naming'
                }
            ]
        }
    
    async def generate_class_naming_section(self):
        """Generate class naming conventions section."""
        return {
            'title': 'Class Naming (PascalCase)',
            'conventions': [
                {
                    'type': 'General classes',
                    'pattern': 'PascalCase',
                    'examples': ['UserAccountManager', 'DataProcessor', 'ApiClient'],
                    'rationale': 'Clear identification of classes'
                },
                {
                    'type': 'Test classes',
                    'pattern': 'Test*',
                    'examples': ['TestUserAccountManager', 'TestDataProcessor'],
                    'rationale': 'Clear identification of test classes'
                },
                {
                    'type': 'Abstract classes',
                    'pattern': 'Abstract* or Base*',
                    'examples': ['AbstractUserService', 'BaseProcessor'],
                    'rationale': 'Clear identification of abstract classes'
                }
            ]
        }
```

## Benefits

### Readability Benefits
- **Clear intent** - Names clearly indicate purpose and functionality
- **Easy navigation** - Consistent naming makes code easier to navigate
- **Reduced cognitive load** - Familiar patterns reduce mental effort
- **Self-documenting code** - Names serve as inline documentation

### Maintainability Benefits
- **Consistent structure** - Uniform naming across the codebase
- **Easy refactoring** - Clear names make refactoring safer
- **Reduced confusion** - No ambiguity about what elements do
- **Better collaboration** - Team members understand code quickly

### Testability Benefits
- **Clear test names** - Test names clearly indicate what is being tested
- **Easy test discovery** - Consistent test naming makes tests easy to find
- **Clear test data** - Descriptive variable names in tests
- **Maintainable tests** - Well-named tests are easier to maintain

### Quality Benefits
- **Professional appearance** - Consistent naming looks professional
- **Industry standards** - Follows established conventions
- **Code review friendly** - Clear names make code reviews more effective
- **Documentation quality** - Good names reduce documentation needs

## Application

### When to Apply
- **Every new file** - Apply naming conventions to all new files
- **Every new class** - Follow class naming conventions
- **Every new function** - Follow function naming conventions
- **Every new variable** - Follow variable naming conventions
- **Code reviews** - Check naming conventions during reviews
- **Refactoring** - Apply naming conventions during refactoring

### How to Apply
1. **Use automated tools** - Use linters and validators
2. **Follow templates** - Use naming templates for consistency
3. **Review regularly** - Regular naming convention reviews
4. **Document standards** - Keep naming conventions documented
5. **Train team** - Ensure team understands conventions
6. **Enforce consistently** - Apply conventions to all code

### Success Criteria
- **Consistent naming** - All code follows naming conventions
- **Clear intent** - Names clearly indicate purpose
- **Easy navigation** - Code is easy to navigate and understand
- **Professional quality** - Code looks professional and well-structured
- **Maintainable** - Code is easy to maintain and modify
- **Testable** - Code is easy to test with clear test names

---

**This rule ensures all code follows strict naming conventions for readability, maintainability, and testability.**
description: Strict naming conventions for readability and maintainability
globs: ["**/*.py", "**/*.md", "**/*.yml", "**/*.yaml"]
alwaysApply: true
---
description:
globs:
alwaysApply: true
---
