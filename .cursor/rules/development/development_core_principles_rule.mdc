---
alwaysApply: false
autoFix: false
category: code-type_0
contexts:
- CODING
- DEVELOPMENT
dependencies:
- core_values_enforcement_rule
description: Code Development Excellence - type_0 layer rule
enforcement: warning
formalLayer: type_0
globs:
- '**/*'
languageGames:
- code_quality_coordination
- development_harmony
linguisticFramework: code
logicalType: 0
priority: high
tags:
- type_0
- code
- type_0
- priority_2
- code_quality_coordination
- development_harmony
tier: '2'
---

# Optimized Development Rules for AI Development Agent

## üéØ **TIER 1: CORE DEVELOPMENT PRINCIPLES** ‚≠ê
**These rules are ALWAYS applied first - they form the foundation of everything we do**

### 1. Test-Driven Development Excellence ‚≠ê
**CRITICAL**: Always write tests first, then implement functionality with Red-Green-Refactor cycle.

**Core Requirements**:
- Write comprehensive tests before implementing any feature
- Follow Red-Green-Refactor cycle: Red (failing test), Green (passing test), Refactor (improve)
- Achieve 90%+ test coverage for core components
- Test both success and failure scenarios
- Use isolated testing for problematic components

**Implementation**:
```python
# ‚úÖ CORRECT: TDD Cycle Implementation
class TDDCycle:
    def red_phase(self, requirement):
        """Write failing test first"""
        test = self.create_test(requirement)
        assert not test.passes(), "Test should fail in red phase"
        return test
    
    def green_phase(self, test):
        """Write minimal code to pass test"""
        implementation = self.minimal_implementation(test)
        assert test.passes(), "Test must pass in green phase"
        return implementation
    
    def refactor_phase(self, code, test):
        """Improve code while keeping tests green"""
        improved_code = self.refactor(code)
        assert test.passes(), "Tests must remain green after refactoring"
        return improved_code
```

### 2. Systematic Problem-Solving ‚≠ê
**CRITICAL**: Always follow systematic approach to problem-solving with clear steps and validation.

**Core Requirements**:
- Define the problem clearly - What exactly is wrong?
- Analyze root cause - Why is it happening?
- Create isolated test - Test the problem in isolation
- Apply systematic fixes - Try solutions methodically
- Validate the solution - Confirm the fix works
- Document the solution - Record what worked and why

**Implementation**:
```python
# ‚úÖ CORRECT: Systematic Problem-Solving
class ProblemSolver:
    def solve_problem(self, issue):
        # 1. Define problem clearly
        problem_definition = self.define_problem(issue)
        
        # 2. Analyze root cause
        root_cause = self.analyze_root_cause(problem_definition)
        
        # 3. Create isolated test
        test = self.create_isolated_test(root_cause)
        
        # 4. Apply systematic fixes
        solution = self.apply_systematic_fixes(test)
        
        # 5. Validate solution
        validation = self.validate_solution(solution, test)
        
        # 6. Document solution
        self.document_solution(problem_definition, solution, validation)
        
        return solution
```

### 3. Framework-First Development ‚≠ê
**CRITICAL**: Always use established frameworks over custom implementations.

**Core Requirements**:
- **LangChain + LangGraph + LangSmith** for all agent development
- **Pydantic** for data validation and structured outputs
- **Pytest** for comprehensive testing
- **Streamlit** for web interfaces
- **Mermaid** for all diagrams (GitHub-compatible)
- **Standard libraries** over custom implementations

**Implementation**:
```python
# ‚úÖ CORRECT: Framework-First Approach
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
import streamlit as st

# Use established frameworks
class AgentConfig(BaseModel):
    model_name: str = Field(default="gemini-2.5-flash-lite")
    temperature: float = Field(default=0.1)
    max_tokens: int = Field(default=8192)

# Use Streamlit secrets
api_key = st.secrets["GEMINI_API_KEY"]
```

### 4. Error Exposure and Handling ‚≠ê
**CRITICAL**: Never use silent error handling or fallbacks - expose all errors immediately.

**Core Requirements**:
- All errors must be exposed, never silenced
- No mock fallbacks or placeholder data
- Comprehensive error logging with context
- Proper exception types and hierarchies
- Immediate error propagation

**Implementation**:
```python
# ‚úÖ CORRECT: Error Exposure
class ErrorHandler:
    def handle_error(self, error, context):
        # Log comprehensive error information
        logger.error(f"Error in {context}: {error}")
        logger.error(f"Stack trace: {traceback.format_exc()}")
        logger.error(f"Context: {context}")
        
        # Re-raise with context
        raise SpecificException(f"Failed in {context}: {error}")

# ‚ùå FORBIDDEN: Silent error handling
try:
    result = risky_operation()
except Exception:
    pass  # Never do this
```

### 5. Continuous Validation ‚≠ê
**CRITICAL**: Validate every step and decision continuously.

**Core Requirements**:
- Validate inputs before processing
- Validate outputs after generation
- Validate state changes at each step
- Validate performance metrics
- Validate quality metrics

**Implementation**:
```python
# ‚úÖ CORRECT: Continuous Validation
class Validator:
    def validate_input(self, data):
        """Validate input data before processing"""
        if not data:
            raise ValueError("Input data cannot be empty")
        return data
    
    def validate_output(self, result):
        """Validate output after processing"""
        if not result:
            raise ValueError("Output cannot be empty")
        return result
    
    def validate_state_change(self, old_state, new_state):
        """Validate state transitions"""
        if not self.is_valid_transition(old_state, new_state):
            raise ValueError("Invalid state transition")
        return new_state
```

### 6. Agile and XP Integration ‚≠ê
**CRITICAL**: Follow Agile sprint methodology and XP practices with TDD integration.

**Core Requirements**:
- 2-week sprint iterations with daily standups
- User stories with INVEST criteria and story point estimation
- Enhanced Red-Green-Refactor cycle with continuous refactoring
- Sprint planning, execution, and retrospective
- Velocity tracking and capacity planning

**Implementation**:
```python
# ‚úÖ CORRECT: Agile/XP Integration
class AgileWorkflow:
    def plan_sprint(self, user_stories, team_capacity):
        """Plan sprint with capacity-based story selection"""
        selected_stories = []
        total_points = 0
        
        for story in user_stories:
            if total_points + story.points <= team_capacity:
                selected_stories.append(story)
                total_points += story.points
        
        return Sprint(selected_stories, total_points)
    
    def execute_tdd_cycle(self, user_story):
        """Execute TDD cycle for user story"""
        # Red phase: Write failing tests
        tests = self.write_acceptance_tests(user_story)
        
        # Green phase: Implement minimal code
        implementation = self.implement_minimal_code(tests)
        
        # Refactor phase: Improve code quality
        improved_code = self.refactor_code(implementation)
        
        return improved_code
```

### 7. Code Quality and Architecture ‚≠ê
**CRITICAL**: Follow SOLID principles and clean code practices.

**Core Requirements**:
- Single Responsibility Principle (SRP)
- Open/Closed Principle (OCP)
- Liskov Substitution Principle (LSP)
- Interface Segregation Principle (ISP)
- Dependency Inversion Principle (DIP)
- Clean code practices and naming conventions

**Implementation**:
```python
# ‚úÖ CORRECT: SOLID Principles
class UserService:
    """Single responsibility: User management only"""
    
    def __init__(self, user_repository: UserRepository):
        # Dependency inversion: depend on abstraction
        self.user_repository = user_repository
    
    def create_user(self, user_data: UserData) -> User:
        """Create user with validation"""
        # Validate input
        validated_data = self.validate_user_data(user_data)
        
        # Create user
        user = User(validated_data)
        
        # Save to repository
        return self.user_repository.save(user)
```

## üéØ **TIER 2: DEVELOPMENT STANDARDS** ‚≠ê
**These rules ensure consistent, high-quality development practices**

### 8. AI Model Selection and Configuration ‚≠ê
**CRITICAL**: Use standardized Gemini model selection for optimal performance and cost.

**Core Requirements**:
- Use `gemini-2.5-flash-lite` for simple tasks
- Use `gemini-2.5-flash` for complex tasks
- Always use `st.secrets["GEMINI_API_KEY"]` for API key
- Set temperature to 0.1 for consistent outputs
- Configure max_tokens to 8192

**Implementation**:
```python
# ‚úÖ CORRECT: Standardized Model Selection
def get_llm_model(task_complexity="simple"):
    """Get appropriate LLM model based on task complexity"""
    api_key = st.secrets["GEMINI_API_KEY"]
    
    if task_complexity == "complex":
        model_name = "gemini-2.5-flash"
    else:
        model_name = "gemini-2.5-flash-lite"
    
    return ChatGoogleGenerativeAI(
        model=model_name,
        google_api_key=api_key,
        temperature=0.1,
        max_tokens=8192
    )
```

### 9. Testing Organization and Patterns ‚≠ê
**CRITICAL**: Follow systematic testing patterns with clear organization.

**Core Requirements**:
- Unit tests for individual components
- Integration tests for component interactions
- System tests for end-to-end workflows
- Performance tests for critical paths
- Security tests for vulnerabilities

**Implementation**:
```python
# ‚úÖ CORRECT: Test Organization
# tests/unit/agents/test_requirements_analyst.py
class TestRequirementsAnalyst:
    def test_analyze_requirements(self):
        """Test requirements analysis functionality"""
        analyst = RequirementsAnalyst()
        result = analyst.analyze("Create a REST API")
        assert result.has_endpoints()
        assert result.has_authentication()

# tests/integration/test_agent_workflow.py
class TestAgentWorkflow:
    def test_complete_workflow(self):
        """Test complete agent workflow"""
        workflow = AgentWorkflow()
        result = workflow.execute(project_description)
        assert result.is_complete()
        assert result.has_all_artifacts()
```

### 10. Security and Configuration Management ‚≠ê
**CRITICAL**: Use secure configuration management and follow security best practices.

**Core Requirements**:
- Use Streamlit secrets for all sensitive data
- Never hardcode API keys or credentials
- Validate all inputs and outputs
- Implement proper authentication and authorization
- Follow OWASP security guidelines

**Implementation**:
```python
# ‚úÖ CORRECT: Secure Configuration
import streamlit as st

# Use Streamlit secrets
api_key = st.secrets.get("GEMINI_API_KEY")
if not api_key:
    st.error("Missing API key in secrets")
    st.stop()

# Validate configuration
if api_key == "your-api-key-here":
    st.error("Please set a valid API key")
    st.stop()
```

### 11. Documentation and Maintenance ‚≠ê
**CRITICAL**: Maintain comprehensive, synchronized documentation.

**Core Requirements**:
- Document all public interfaces and APIs
- Keep documentation synchronized with code changes
- Use clear, concise language
- Include usage examples and code snippets
- Maintain README files for all major components

**Implementation**:
```python
# ‚úÖ CORRECT: Documentation
class UserService:
    """
    User management service for authentication and user operations.
    
    This service provides comprehensive user management functionality
    including creation, authentication, and profile management.
    
    Example:
        >>> service = UserService()
        >>> user = service.create_user({"name": "John", "email": "john@example.com"})
        >>> print(user.id)
        'user_123'
    """
    
    def create_user(self, user_data: dict) -> User:
        """
        Create a new user with the provided data.
        
        Args:
            user_data: Dictionary containing user information
                - name: User's full name (required)
                - email: User's email address (required)
                - role: User's role (optional, defaults to 'user')
        
        Returns:
            User: Created user object with assigned ID
        
        Raises:
            ValueError: If required fields are missing
            DuplicateUserError: If user with email already exists
        """
        # Implementation here
        pass
```

## üéØ **TIER 3: PROJECT MANAGEMENT** ‚≠ê
**These rules ensure effective project organization and management**

### 12. File Organization and Structure ‚≠ê
**CRITICAL**: Maintain clear, logical file organization and structure.

**Core Requirements**:
- Follow established directory structure
- Use consistent naming conventions
- Separate concerns into appropriate modules
- Maintain clear import hierarchies
- Use __init__.py files for package organization

**Implementation**:
```
ai-dev-agent/
‚îú‚îÄ‚îÄ agents/                 # Agent implementations
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base_agent.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements_analyst.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ tests/                  # Test suite
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ system/
‚îú‚îÄ‚îÄ utils/                  # Utility functions
‚îú‚îÄ‚îÄ models/                 # Data models
‚îú‚îÄ‚îÄ workflow/               # Workflow management
‚îî‚îÄ‚îÄ docs/                   # Documentation
```

### 12.5. Documentation Cleanliness and Organization ‚≠ê
**CRITICAL**: Maintain pristine documentation folder with no temporary, messy, or redundant files.

**Core Requirements**:
- **NO TEMPORARY FILES**: Never leave temporary documentation files in docs/
- **NO SUMMARY FILES**: Remove summary files after they've served their purpose
- **PROPER CATEGORIZATION**: All files must be in appropriate subdirectories
- **CURRENT INDEX**: Documentation index must always reflect actual content
- **NO DUPLICATES**: Eliminate duplicate or redundant documentation
- **CLEAN STRUCTURE**: Maintain clean, logical folder hierarchy

**Documentation Folder Structure**:
```
docs/
‚îú‚îÄ‚îÄ DOCUMENTATION_INDEX.md     # Master index (ALWAYS CURRENT)
‚îú‚îÄ‚îÄ README.md                  # Main docs overview
‚îú‚îÄ‚îÄ concepts/                  # Concept papers and strategic documents
‚îÇ   ‚îú‚îÄ‚îÄ agile_xp_ai_agent_integration_concept.md
‚îÇ   ‚îú‚îÄ‚îÄ agent_system_implementation_concept.md
‚îÇ   ‚îú‚îÄ‚îÄ integration/           # Integration strategies
‚îÇ   ‚îî‚îÄ‚îÄ migration/             # Migration strategies
‚îú‚îÄ‚îÄ guides/                    # Implementation and how-to guides
‚îÇ   ‚îú‚îÄ‚îÄ development/           # Development guides
‚îÇ   ‚îú‚îÄ‚îÄ implementation/        # Implementation guides
‚îÇ   ‚îú‚îÄ‚îÄ database/              # Database guides
‚îÇ   ‚îú‚îÄ‚îÄ deployment/            # Deployment guides
‚îÇ   ‚îú‚îÄ‚îÄ testing/               # Testing guides
‚îÇ   ‚îú‚îÄ‚îÄ observability/         # Monitoring guides
‚îÇ   ‚îú‚îÄ‚îÄ langgraph/             # LangGraph guides
‚îÇ   ‚îî‚îÄ‚îÄ architecture/          # Architecture guides
‚îú‚îÄ‚îÄ analysis/                  # Research and analysis documents
‚îÇ   ‚îú‚îÄ‚îÄ agent_analysis/        # Agent analysis
‚îÇ   ‚îî‚îÄ‚îÄ summaries/             # Analysis summaries
‚îî‚îÄ‚îÄ architecture/              # Architecture documentation
    ‚îú‚îÄ‚îÄ overview/              # High-level architecture
    ‚îú‚îÄ‚îÄ components/            # Component architecture
    ‚îî‚îÄ‚îÄ diagrams/              # Architecture diagrams
```

**Forbidden File Patterns**:
```python
# ‚ùå FORBIDDEN: Temporary files
forbidden_patterns = [
    "DOCUMENTATION_*_SUMMARY.md",    # Temporary summary files
    "*_TEMP.md",                     # Temporary files
    "*_DRAFT.md",                    # Draft files
    "*_BACKUP.md",                   # Backup files
    "*_OLD.md",                      # Old versions
    "*_COPY.md",                     # Copy files
    "temp_*",                        # Temporary files
    "draft_*",                       # Draft files
    "*_notes.md",                    # Personal notes
    "*_TODO.md",                     # TODO files
    "*_CHANGES.md",                  # Change logs (use git)
    "*_UPDATES.md",                  # Update logs (use git)
    "*_INTEGRATION_SUMMARY.md",      # Integration summaries
    "*_UPDATE_SUMMARY.md",           # Update summaries
    "*_RULE_INTEGRATION_SUMMARY.md", # Rule integration summaries
]

# ‚ùå FORBIDDEN: Files in wrong locations
forbidden_locations = [
    "docs/*.md",                     # No .md files directly in docs/ (except index and README)
    "docs/concepts/*.txt",           # No .txt files in concepts/
    "docs/guides/*.tmp",             # No .tmp files anywhere
    "docs/analysis/*.bak",           # No .bak files anywhere
]
```

**Documentation Cleanup Process**:
```python
# ‚úÖ CORRECT: Documentation Cleanup
class DocumentationCleaner:
    def __init__(self):
        self.docs_root = "docs/"
        self.forbidden_patterns = forbidden_patterns
        self.required_structure = required_structure
    
    def cleanup_documentation(self):
        """Clean up documentation folder"""
        # 1. Remove temporary files
        self.remove_temporary_files()
        
        # 2. Move files to correct locations
        self.organize_files()
        
        # 3. Update documentation index
        self.update_documentation_index()
        
        # 4. Validate structure
        self.validate_structure()
        
        # 5. Remove duplicates
        self.remove_duplicates()
    
    def remove_temporary_files(self):
        """Remove all temporary and summary files"""
        for pattern in self.forbidden_patterns:
            files = glob.glob(f"{self.docs_root}/{pattern}")
            for file in files:
                logger.info(f"Removing temporary file: {file}")
                os.remove(file)
    
    def organize_files(self):
        """Move files to appropriate subdirectories"""
        # Move concept papers to concepts/
        concept_files = glob.glob(f"{self.docs_root}/*_concept.md")
        for file in concept_files:
            if not file.startswith(f"{self.docs_root}concepts/"):
                new_path = f"{self.docs_root}concepts/{os.path.basename(file)}"
                shutil.move(file, new_path)
                logger.info(f"Moved concept file: {file} -> {new_path}")
    
    def update_documentation_index(self):
        """Update DOCUMENTATION_INDEX.md to reflect current state"""
        # Scan all documentation files
        all_files = self.scan_documentation_files()
        
        # Update index with current files
        self.regenerate_index(all_files)
        
        logger.info("Updated documentation index")
    
    def validate_structure(self):
        """Validate documentation structure"""
        # Check required directories exist
        for directory in self.required_structure:
            if not os.path.exists(f"{self.docs_root}/{directory}"):
                os.makedirs(f"{self.docs_root}/{directory}")
                logger.info(f"Created missing directory: {directory}")
        
        # Check no files in wrong locations
        self.check_file_locations()
    
    def remove_duplicates(self):
        """Remove duplicate documentation files"""
        # Find files with similar names
        similar_files = self.find_similar_files()
        
        # Keep the most recent/complete version
        for file_group in similar_files:
            self.keep_best_version(file_group)
```

**Pre-Commit Documentation Check**:
# Code example removed for brevity


**Documentation Maintenance Schedule**:
# Code example removed for brevity


**Documentation Quality Gates**:
# Code example removed for brevity


**Implementation Examples**:
# Code example removed for brevity


**Documentation Cleanup Checklist**:
- [ ] **No temporary files** in docs/ directory
- [ ] **No summary files** left after use
- [ ] **All files categorized** in appropriate subdirectories
- [ ] **Documentation index current** and accurate
- [ ] **No duplicate files** or redundant content
- [ ] **Clean folder structure** maintained
- [ ] **No forbidden file patterns** present
- [ ] **All links valid** and working
- [ ] **Navigation logical** and intuitive
- [ ] **Content quality** meets standards

### 13. Task Management and Progress Tracking ‚≠ê
**CRITICAL**: Maintain accurate task tracking and progress management.

**Core Requirements**:
- Keep task lists current and accurate
- Track progress with clear metrics
- Update task status regularly
- Document blockers and impediments
- Maintain sprint backlogs and velocity

**Implementation**:
# Code example removed for brevity


### 14. Requirements Management ‚≠ê
**CRITICAL**: Track and validate requirements throughout development.

**Core Requirements**:
- Document all requirements clearly
- Validate requirements against implementation
- Track requirement changes and updates
- Ensure requirements are testable
- Maintain requirement traceability

**Implementation**:
# Code example removed for brevity


## üéØ **TIER 4: AUTOMATION AND OPTIMIZATION** ‚≠ê
**These rules ensure efficient, automated development processes**

### 15. Automation and Environment ‚≠ê
**CRITICAL**: Implement comprehensive automation for development processes.

**Core Requirements**:
- Automate repetitive development tasks
- Implement continuous integration and deployment
- Automate testing and quality checks
- Automate documentation updates
- Implement automated error detection and recovery

**Implementation**:
# Code example removed for brevity


### 16. Performance and Quality Optimization ‚≠ê
**CRITICAL**: Continuously optimize performance and quality.

**Core Requirements**:
- Monitor performance metrics continuously
- Optimize critical code paths
- Maintain code quality standards
- Implement performance testing
- Track and improve quality metrics

**Implementation**:
# Code example removed for brevity


## üéØ **TIER 5: CONTINUOUS IMPROVEMENT** ‚≠ê
**These rules ensure continuous learning and improvement**

### 17. Learning and Knowledge Management ‚≠ê
**CRITICAL**: Continuously learn and improve from all interactions.

**Core Requirements**:
- Document every insight and learning
- Share knowledge systematically across agents
- Recognize patterns in successes and failures
- Evolve rules based on new learnings
- Apply learnings to future interactions

**Implementation**:
# Code example removed for brevity


## üìã **RULE APPLICATION GUIDELINES**

### Priority Levels
- **‚≠ê Critical (Tier 1)**: Always applied, form the foundation
- **‚≠ê High (Tier 2)**: Applied to relevant development activities
- **‚≠ê Medium (Tier 3)**: Applied when context is relevant
- **‚≠ê Low (Tier 4-5)**: Applied on demand or for specific scenarios

### Application Criteria
1. **Critical Rules**: Always enforced across entire project
2. **High Priority Rules**: Applied to relevant file patterns and scenarios
3. **Medium Priority Rules**: Applied when context is relevant
4. **Low Priority Rules**: Applied on demand or for specific scenarios

### Validation Checklist
- [ ] All critical rules are being followed
- [ ] No redundant or conflicting rules
- [ ] Rules are clear and actionable
- [ ] Rules are effectively enforced
- [ ] Rules contribute to project success

## üéØ **BENEFITS OF OPTIMIZED RULES**

### Consistency
- Uniform standards across all development activities
- Clear, actionable guidelines for all team members
- Consistent application of best practices

### Quality
- Automated enforcement of quality standards
- Comprehensive testing and validation
- Continuous improvement and optimization

### Efficiency
- Reduced manual review and standardization efforts
- Automated processes and workflows
- Optimized development practices

### Reliability
- Consistent error handling and testing practices
- Robust validation and quality assurance
- Reliable development processes

### Maintainability
- Clear standards for code organization and structure
- Comprehensive documentation and knowledge management
- Systematic approach to problem-solving

### Scalability
- Standardized patterns for team collaboration
- Automated processes that scale with project size
- Clear guidelines for growth and expansion
