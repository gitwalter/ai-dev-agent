---
description: "Never use silent error handling, mock fallbacks, or placeholder data that masks real parsing failures. All errors must be exposed and addressed properly."
category: "quality-standards"
priority: "high"
alwaysApply: false
contexts: ["DEBUGGING", "CODING", "TESTING", "DEFAULT"]
globs: ["**/*"]
tags: ["error-handling", "quality", "reliability", "debugging"]
tier: "2"
---

# No Silent Errors and Mock Fallbacks Rule

**CRITICAL**: Never use silent error handling, mock fallbacks, or placeholder data that masks real parsing failures. All errors must be exposed and addressed properly to ensure system reliability and quality.

## Core Requirements

### 1. Error Exposure Requirements
**MANDATORY**: All errors must be exposed, never silenced
```python
# CORRECT: Expose errors immediately
try:
    result = parser.parse(response)
    return result
except Exception as e:
    logger.error(f"Parsing failed: {e}")
    raise OutputParserException(f"Failed to parse response: {e}")

# INCORRECT: Silent error handling with fallbacks
try:
    result = parser.parse(response)
    return result
except Exception as e:
    logger.warning(f"Parsing failed, using fallback: {e}")
    return get_fallback_data()  # NEVER DO THIS
```

### 2. Fallback Prohibition
**FORBIDDEN**: Mock fallbacks, placeholder data, or silent error recovery
```python
# FORBIDDEN: Mock fallback data
def _get_fallback_data(self):
    return {
        "status": "completed",
        "message": "Fallback data used",
        "data": {}  # Empty/mock data
    }

# FORBIDDEN: Silent error handling
except Exception as e:
    logger.warning(f"Error occurred: {e}")
    return {}  # Silent failure
```

### 3. Error Propagation Requirements

#### **Immediate Error Exposure**
```python
# MANDATORY: Always raise exceptions for parsing failures
def parse_response(self, response: str) -> Dict[str, Any]:
    try:
        # Primary parsing attempt
        return self._primary_parse(response)
    except Exception as e:
        # Log the error and re-raise
        self.logger.error(f"Primary parsing failed: {e}")
        raise OutputParserException(f"Failed to parse response: {e}")
```

#### **No Graceful Degradation**
```python
# FORBIDDEN: Graceful degradation with fallbacks
def parse_with_fallbacks(self, response: str):
    try:
        return self._primary_parse(response)
    except Exception as e:
        try:
            return self._secondary_parse(response)  # FORBIDDEN
        except Exception as e2:
            return self._get_fallback_data()  # FORBIDDEN
```

### 4. Error Handling Standards

#### **Exception Types**
```python
# MANDATORY: Use specific exception types
class OutputParserException(Exception):
    """Raised when output parsing fails."""
    pass

class ValidationException(Exception):
    """Raised when data validation fails."""
    pass

class FormatException(Exception):
    """Raised when output format is invalid."""
    pass
```

#### **Error Context Requirements**
```python
# MANDATORY: Include context in error messages
def parse_response(self, response: str, agent_type: str) -> Dict[str, Any]:
    try:
        return self._parse(response)
    except Exception as e:
        error_msg = f"Parsing failed for {agent_type}: {e}. Response: {response[:200]}..."
        raise OutputParserException(error_msg)
```

### 5. Logging Requirements

#### **Error Logging Standards**
```python
# MANDATORY: Comprehensive error logging
import logging

logger = logging.getLogger(__name__)

def parse_response(self, response: str) -> Dict[str, Any]:
    try:
        return self._parse(response)
    except Exception as e:
        logger.error(f"Parsing failed: {e}")
        logger.error(f"Response content: {response}")
        logger.error(f"Agent type: {self.agent_type}")
        logger.error(f"Parser configuration: {self.config}")
        raise  # Re-raise the exception
```

#### **No Warning-Only Logging**
```python
# FORBIDDEN: Warning-only logging for errors
except Exception as e:
    logger.warning(f"Parsing failed, continuing with fallback: {e}")  # FORBIDDEN
    return fallback_data

# CORRECT: Error logging with exception raising
except Exception as e:
    logger.error(f"Parsing failed: {e}")
    raise OutputParserException(f"Parsing failed: {e}")
```

### 6. Testing Requirements

#### **Error Testing**
```python
# MANDATORY: Test error conditions
def test_parsing_failure_exposure():
    """Test that parsing failures are properly exposed."""
    parser = OutputParser()
    
    # Test with invalid response
    with pytest.raises(OutputParserException):
        parser.parse("invalid response")
    
    # Test with malformed JSON
    with pytest.raises(OutputParserException):
        parser.parse('{"incomplete": json')
    
    # Test with missing required fields
    with pytest.raises(ValidationException):
        parser.parse('{"partial": "data"}')
```

#### **No Fallback Testing**
```python
# FORBIDDEN: Test fallback mechanisms
def test_fallback_mechanism():  # FORBIDDEN
    parser = OutputParser()
    result = parser.parse("invalid response")
    assert result == fallback_data  # FORBIDDEN

# CORRECT: Test error exposure
def test_error_exposure():
    parser = OutputParser()
    with pytest.raises(OutputParserException):
        parser.parse("invalid response")
```

### 7. Agent Integration Requirements

#### **Agent Error Handling**
```python
# MANDATORY: Agents must fail on parsing errors
def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
    try:
        response = await self._generate_response(state)
        parsed_response = self.parser.parse(response)
        return self._update_state(state, parsed_response)
    except OutputParserException as e:
        # Log the error and fail the agent
        self.logger.error(f"Agent {self.name} failed due to parsing error: {e}")
        raise AgentExecutionException(f"Agent {self.name} failed: {e}")
```

#### **No Agent Fallbacks**
```python
# FORBIDDEN: Agent fallback mechanisms
def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
    try:
        response = await self._generate_response(state)
        parsed_response = self.parser.parse(response)
        return self._update_state(state, parsed_response)
    except Exception as e:
        # FORBIDDEN: Agent fallback
        return self._get_fallback_state(state)  # NEVER DO THIS
```

### 8. Workflow Integration Requirements

#### **Workflow Error Propagation**
```python
# MANDATORY: Workflow must fail on agent errors
async def execute_workflow(self, state: Dict[str, Any]) -> Dict[str, Any]:
    for agent in self.agents:
        try:
            state = await agent.execute(state)
        except AgentExecutionException as e:
            # Log and fail the entire workflow
            self.logger.error(f"Workflow failed due to agent error: {e}")
            raise WorkflowExecutionException(f"Workflow failed: {e}")
    
    return state
```

#### **No Workflow Fallbacks**
```python
# FORBIDDEN: Workflow fallback mechanisms
async def execute_workflow(self, state: Dict[str, Any]) -> Dict[str, Any]:
    for agent in self.agents:
        try:
            state = await agent.execute(state)
        except Exception as e:
            # FORBIDDEN: Workflow fallback
            state = self._get_fallback_state(state)  # NEVER DO THIS
            continue  # NEVER DO THIS
    
    return state
```

### 9. Configuration Requirements

#### **Parser Configuration**
```python
# MANDATORY: Configure parsers to fail on errors
class OutputParser:
    def __init__(self, fail_on_error: bool = True):
        self.fail_on_error = True  # Always true, no option to disable
        self.allow_fallbacks = False  # Always false
        self.silent_errors = False  # Always false
```

#### **No Fallback Configuration**
# Code example removed for brevity


### 10. Code Review Requirements

#### **Mandatory Checks**
- [ ] No fallback data or mock responses
- [ ] No silent error handling
- [ ] All exceptions are properly raised
- [ ] Error logging is comprehensive
- [ ] No graceful degradation mechanisms
- [ ] No placeholder or default data

#### **Forbidden Patterns**
# Code example removed for brevity


### 11. Implementation Guidelines

#### **Error Handling Template**
# Code example removed for brevity


#### **Agent Error Handling Template**
# Code example removed for brevity


### 12. Benefits

- **Improved Reliability**: No hidden failures or silent errors
- **Better Debugging**: All errors are exposed and logged
- **Quality Assurance**: Forces proper error handling and validation
- **System Transparency**: Clear visibility into all failures
- **Maintenance**: Easier to identify and fix issues

### 13. Enforcement

This rule is **CONDITIONALLY APPLIED** based on context.

**Violations of this rule require immediate remediation and removal of all fallback mechanisms.**

### 14. Migration Guide

#### **Removing Existing Fallbacks**
1. **Identify Fallback Code**: Find all fallback mechanisms
2. **Replace with Exceptions**: Convert fallbacks to proper exceptions
3. **Update Error Handling**: Ensure all errors are properly logged and raised
4. **Update Tests**: Remove fallback tests, add error exposure tests
5. **Update Documentation**: Remove references to fallback mechanisms

#### **Example Migration**
# Code example removed for brevity


**Remember**: The goal is to expose all errors, not hide them. This ensures system reliability and forces proper error handling and validation.
