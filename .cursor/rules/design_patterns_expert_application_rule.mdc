# Expert Design Patterns Application Rule

## Description
Apply design patterns from Gang of Four (GoF), Martin Fowler, and other influential software architects with expert care and understanding. Use patterns purposefully to make code understandable, robust, and maintainable. Always consider the context and apply patterns only when they genuinely improve the solution.

## Core Requirements

### 1. Gang of Four (GoF) Patterns Mastery
**MANDATORY**: Expert application of GoF design patterns:

#### **Creational Patterns - Applied with Care**
```python
class CreationalPatternExpert:
    """Expert application of GoF creational patterns."""
    
    def __init__(self):
        self.pattern_context = PatternContext()
        self.implementation_guide = ImplementationGuide()
    
    def apply_singleton_carefully(self, context: dict) -> dict:
        """
        Apply Singleton pattern only when truly needed.
        
        Use when:
        - Global state is genuinely required
        - Resource management is critical
        - Configuration management is centralized
        
        Avoid when:
        - Testing becomes difficult
        - Tight coupling is introduced
        - Alternative solutions exist
        """
        if not self._singleton_is_justified(context):
            return {"pattern": "alternative_solution", "reason": "Singleton not justified"}
        
        singleton_implementation = {
            "pattern": "singleton",
            "implementation": self._implement_thread_safe_singleton(context),
            "testing_strategy": self._design_singleton_testing_strategy(context),
            "documentation": self._document_singleton_usage(context)
        }
        
        return singleton_implementation
    
    def apply_factory_pattern_purposefully(self, context: dict) -> dict:
        """
        Apply Factory pattern when object creation logic is complex.
        
        Use when:
        - Object creation involves complex logic
        - Different types of objects need different creation processes
        - Creation logic needs to be centralized
        """
        factory_analysis = {
            "creation_complexity": self._assess_creation_complexity(context),
            "type_variations": self._analyze_type_variations(context),
            "centralization_benefit": self._assess_centralization_benefit(context)
        }
        
        if factory_analysis["creation_complexity"]["score"] > 7:
            return self._implement_factory_pattern(context, factory_analysis)
        else:
            return {"pattern": "simple_constructor", "reason": "Factory complexity not justified"}
    
    def apply_builder_pattern_for_complex_objects(self, context: dict) -> dict:
        """
        Apply Builder pattern for complex object construction.
        
        Use when:
        - Object has many optional parameters
        - Construction process is complex
        - Immutability is desired
        """
        builder_analysis = {
            "parameter_count": self._count_parameters(context),
            "construction_complexity": self._assess_construction_complexity(context),
            "immutability_requirement": context.get("immutable", False)
        }
        
        if (builder_analysis["parameter_count"] > 5 or 
            builder_analysis["construction_complexity"]["score"] > 6):
            return self._implement_builder_pattern(context, builder_analysis)
        else:
            return {"pattern": "constructor_with_defaults", "reason": "Builder complexity not justified"}
```

#### **Structural Patterns - Applied for Clarity**
```python
class StructuralPatternExpert:
    """Expert application of GoF structural patterns."""
    
    def apply_adapter_pattern_thoughtfully(self, context: dict) -> dict:
        """
        Apply Adapter pattern to integrate incompatible interfaces.
        
        Use when:
        - Integrating third-party libraries
        - Legacy system integration
        - Interface compatibility issues
        """
        adapter_analysis = {
            "interface_incompatibility": self._assess_interface_incompatibility(context),
            "integration_necessity": self._assess_integration_necessity(context),
            "maintenance_impact": self._assess_maintenance_impact(context)
        }
        
        if adapter_analysis["interface_incompatibility"]["score"] > 5:
            return self._implement_adapter_pattern(context, adapter_analysis)
        else:
            return {"pattern": "direct_integration", "reason": "Adapter not needed"}
    
    def apply_decorator_pattern_for_behavior_extension(self, context: dict) -> dict:
        """
        Apply Decorator pattern for flexible behavior extension.
        
        Use when:
        - Multiple behavior combinations are needed
        - Runtime behavior modification is required
        - Inheritance is not suitable
        """
        decorator_analysis = {
            "behavior_combinations": self._analyze_behavior_combinations(context),
            "runtime_modification": context.get("runtime_modification", False),
            "inheritance_suitability": self._assess_inheritance_suitability(context)
        }
        
        if (decorator_analysis["behavior_combinations"]["count"] > 3 or 
            decorator_analysis["runtime_modification"]):
            return self._implement_decorator_pattern(context, decorator_analysis)
        else:
            return {"pattern": "inheritance_or_composition", "reason": "Decorator complexity not justified"}
    
    def apply_facade_pattern_for_simplification(self, context: dict) -> dict:
        """
        Apply Facade pattern to simplify complex subsystems.
        
        Use when:
        - Subsystem is complex and difficult to use
        - Multiple subsystems need coordination
        - Client code needs simplification
        """
        facade_analysis = {
            "subsystem_complexity": self._assess_subsystem_complexity(context),
            "coordination_needs": self._assess_coordination_needs(context),
            "client_simplification_benefit": self._assess_client_benefit(context)
        }
        
        if facade_analysis["subsystem_complexity"]["score"] > 6:
            return self._implement_facade_pattern(context, facade_analysis)
        else:
            return {"pattern": "direct_subsystem_access", "reason": "Facade not needed"}
```

#### **Behavioral Patterns - Applied for Robustness**
```python
class BehavioralPatternExpert:
    """Expert application of GoF behavioral patterns."""
    
    def apply_observer_pattern_for_loose_coupling(self, context: dict) -> dict:
        """
        Apply Observer pattern for loose coupling between components.
        
        Use when:
        - One-to-many dependency relationships
        - Loose coupling is desired
        - Event-driven architecture
        """
        observer_analysis = {
            "dependency_relationship": self._analyze_dependency_relationship(context),
            "coupling_requirements": self._assess_coupling_requirements(context),
            "event_driven_architecture": context.get("event_driven", False)
        }
        
        if (observer_analysis["dependency_relationship"]["type"] == "one_to_many" or
            observer_analysis["coupling_requirements"]["loose_coupling"]):
            return self._implement_observer_pattern(context, observer_analysis)
        else:
            return {"pattern": "direct_coupling", "reason": "Observer not needed"}
    
    def apply_strategy_pattern_for_algorithm_variation(self, context: dict) -> dict:
        """
        Apply Strategy pattern for algorithm variation.
        
        Use when:
        - Multiple algorithms for the same task
        - Runtime algorithm selection
        - Algorithm families need to be encapsulated
        """
        strategy_analysis = {
            "algorithm_variations": self._analyze_algorithm_variations(context),
            "runtime_selection": context.get("runtime_selection", False),
            "algorithm_family": self._assess_algorithm_family(context)
        }
        
        if (strategy_analysis["algorithm_variations"]["count"] > 2 or
            strategy_analysis["runtime_selection"]):
            return self._implement_strategy_pattern(context, strategy_analysis)
        else:
            return {"pattern": "conditional_logic", "reason": "Strategy complexity not justified"}
    
    def apply_command_pattern_for_operation_encapsulation(self, context: dict) -> dict:
        """
        Apply Command pattern for operation encapsulation.
        
        Use when:
        - Operations need to be parameterized
        - Undo/redo functionality is needed
        - Operations need to be queued or logged
        """
        command_analysis = {
            "operation_parameterization": self._assess_operation_parameterization(context),
            "undo_redo_requirement": context.get("undo_redo", False),
            "operation_queuing": context.get("operation_queuing", False)
        }
        
        if (command_analysis["operation_parameterization"]["needed"] or
            command_analysis["undo_redo_requirement"] or
            command_analysis["operation_queuing"]):
            return self._implement_command_pattern(context, command_analysis)
        else:
            return {"pattern": "direct_method_call", "reason": "Command not needed"}
```

### 2. Martin Fowler Patterns Expertise
**MANDATORY**: Expert application of Fowler's enterprise patterns:

#### **Enterprise Integration Patterns**
```python
class FowlerPatternExpert:
    """Expert application of Martin Fowler's patterns."""
    
    def apply_repository_pattern_for_data_access(self, context: dict) -> dict:
        """
        Apply Repository pattern for clean data access abstraction.
        
        Use when:
        - Data access logic needs abstraction
        - Testing with mock data is needed
        - Multiple data sources need to be supported
        """
        repository_analysis = {
            "data_access_complexity": self._assess_data_access_complexity(context),
            "testing_requirements": self._assess_testing_requirements(context),
            "data_source_variety": self._assess_data_source_variety(context)
        }
        
        if repository_analysis["data_access_complexity"]["score"] > 4:
            return self._implement_repository_pattern(context, repository_analysis)
        else:
            return {"pattern": "direct_data_access", "reason": "Repository abstraction not needed"}
    
    def apply_unit_of_work_pattern_for_transaction_management(self, context: dict) -> dict:
        """
        Apply Unit of Work pattern for transaction management.
        
        Use when:
        - Multiple operations need to be atomic
        - Transaction management is complex
        - Rollback capabilities are needed
        """
        unit_of_work_analysis = {
            "transaction_complexity": self._assess_transaction_complexity(context),
            "atomic_operations": self._assess_atomic_operations(context),
            "rollback_requirements": context.get("rollback_needed", False)
        }
        
        if (unit_of_work_analysis["transaction_complexity"]["score"] > 5 or
            unit_of_work_analysis["atomic_operations"]["count"] > 1):
            return self._implement_unit_of_work_pattern(context, unit_of_work_analysis)
        else:
            return {"pattern": "simple_transaction", "reason": "Unit of Work not needed"}
    
    def apply_specification_pattern_for_business_rules(self, context: dict) -> dict:
        """
        Apply Specification pattern for business rule encapsulation.
        
        Use when:
        - Complex business rules need to be encapsulated
        - Rules need to be combined or reused
        - Business logic needs to be testable
        """
        specification_analysis = {
            "business_rule_complexity": self._assess_business_rule_complexity(context),
            "rule_combination_needs": self._assess_rule_combination_needs(context),
            "business_logic_testability": self._assess_business_logic_testability(context)
        }
        
        if specification_analysis["business_rule_complexity"]["score"] > 6:
            return self._implement_specification_pattern(context, specification_analysis)
        else:
            return {"pattern": "simple_validation", "reason": "Specification not needed"}
```

### 3. Pattern Application Decision Framework
**MANDATORY**: Systematic approach to pattern selection:

#### **Pattern Decision Matrix**
```python
class PatternDecisionFramework:
    """Framework for making informed pattern decisions."""
    
    def __init__(self):
        self.pattern_catalog = PatternCatalog()
        self.context_analyzer = ContextAnalyzer()
        self.implementation_assessor = ImplementationAssessor()
    
    def evaluate_pattern_application(self, problem: dict, context: dict) -> dict:
        """
        Evaluate whether a pattern should be applied.
        
        Decision factors:
        - Problem complexity
        - Solution clarity
        - Maintenance impact
        - Testing implications
        - Team familiarity
        """
        evaluation = {
            "problem_analysis": self._analyze_problem(problem),
            "pattern_candidates": self._identify_pattern_candidates(problem),
            "context_assessment": self._assess_context(context),
            "implementation_impact": self._assess_implementation_impact(problem, context),
            "recommendation": self._make_recommendation(problem, context)
        }
        
        return evaluation
    
    def _analyze_problem(self, problem: dict) -> dict:
        """Analyze the problem to understand its nature."""
        return {
            "complexity": self._assess_problem_complexity(problem),
            "recurrence": self._assess_problem_recurrence(problem),
            "domain": self._identify_problem_domain(problem),
            "constraints": self._identify_problem_constraints(problem)
        }
    
    def _identify_pattern_candidates(self, problem: dict) -> list:
        """Identify potential patterns that could solve the problem."""
        candidates = []
        
        # Check GoF patterns
        for pattern in self.pattern_catalog.get_gof_patterns():
            if self._pattern_matches_problem(pattern, problem):
                candidates.append({
                    "pattern": pattern,
                    "match_score": self._calculate_match_score(pattern, problem),
                    "implementation_complexity": self._assess_implementation_complexity(pattern),
                    "team_familiarity": self._assess_team_familiarity(pattern)
                })
        
        # Check Fowler patterns
        for pattern in self.pattern_catalog.get_fowler_patterns():
            if self._pattern_matches_problem(pattern, problem):
                candidates.append({
                    "pattern": pattern,
                    "match_score": self._calculate_match_score(pattern, problem),
                    "implementation_complexity": self._assess_implementation_complexity(pattern),
                    "team_familiarity": self._assess_team_familiarity(pattern)
                })
        
        return sorted(candidates, key=lambda x: x["match_score"], reverse=True)
    
    def _make_recommendation(self, problem: dict, context: dict) -> dict:
        """Make a final recommendation based on all factors."""
        candidates = self._identify_pattern_candidates(problem)
        
        if not candidates:
            return {
                "recommendation": "no_pattern",
                "reason": "No suitable pattern found",
                "alternative": "custom_solution"
            }
        
        best_candidate = candidates[0]
        
        # Apply decision criteria
        if best_candidate["match_score"] < 7:
            return {
                "recommendation": "no_pattern",
                "reason": "Pattern match score too low",
                "alternative": "simple_solution"
            }
        
        if best_candidate["implementation_complexity"]["score"] > 8:
            return {
                "recommendation": "no_pattern",
                "reason": "Implementation too complex",
                "alternative": "simpler_solution"
            }
        
        return {
            "recommendation": "apply_pattern",
            "pattern": best_candidate["pattern"],
            "confidence": best_candidate["match_score"],
            "implementation_plan": self._create_implementation_plan(best_candidate)
        }
```

### 4. Pattern Implementation Excellence
**MANDATORY**: High-quality pattern implementation:

#### **Pattern Implementation Standards**
```python
class PatternImplementationExpert:
    """Expert pattern implementation with high standards."""
    
    def implement_pattern_with_excellence(self, pattern: dict, context: dict) -> dict:
        """Implement a pattern with excellence and care."""
        implementation = {
            "pattern_name": pattern["name"],
            "implementation": self._create_excellent_implementation(pattern, context),
            "documentation": self._create_pattern_documentation(pattern, context),
            "tests": self._create_pattern_tests(pattern, context),
            "examples": self._create_usage_examples(pattern, context)
        }
        
        return implementation
    
    def _create_excellent_implementation(self, pattern: dict, context: dict) -> dict:
        """Create an excellent pattern implementation."""
        implementation = {
            "code": self._write_clean_pattern_code(pattern, context),
            "interfaces": self._design_clean_interfaces(pattern, context),
            "error_handling": self._implement_robust_error_handling(pattern, context),
            "performance": self._optimize_for_performance(pattern, context),
            "maintainability": self._ensure_maintainability(pattern, context)
        }
        
        return implementation
    
    def _write_clean_pattern_code(self, pattern: dict, context: dict) -> str:
        """Write clean, understandable pattern code."""
        code_template = self._get_pattern_template(pattern["name"])
        
        # Apply clean code principles
        code = self._apply_clean_code_principles(code_template, context)
        
        # Ensure naming clarity
        code = self._ensure_clear_naming(code, context)
        
        # Add appropriate comments
        code = self._add_helpful_comments(code, pattern, context)
        
        return code
    
    def _design_clean_interfaces(self, pattern: dict, context: dict) -> dict:
        """Design clean, intuitive interfaces for the pattern."""
        interfaces = {
            "public_interface": self._design_public_interface(pattern, context),
            "internal_interface": self._design_internal_interface(pattern, context),
            "extension_points": self._design_extension_points(pattern, context),
            "configuration": self._design_configuration_interface(pattern, context)
        }
        
        return interfaces
```

### 5. Pattern Documentation and Knowledge Sharing
**MANDATORY**: Comprehensive pattern documentation:

#### **Pattern Knowledge Management**
```python
class PatternKnowledgeManager:
    """Manages pattern knowledge and documentation."""
    
    def create_pattern_documentation(self, pattern: dict, implementation: dict) -> dict:
        """Create comprehensive pattern documentation."""
        documentation = {
            "pattern_overview": self._create_pattern_overview(pattern),
            "implementation_guide": self._create_implementation_guide(pattern, implementation),
            "usage_examples": self._create_usage_examples(pattern, implementation),
            "best_practices": self._create_best_practices(pattern),
            "anti_patterns": self._create_anti_patterns(pattern),
            "testing_strategy": self._create_testing_strategy(pattern, implementation)
        }
        
        return documentation
    
    def _create_pattern_overview(self, pattern: dict) -> dict:
        """Create a clear pattern overview."""
        return {
            "name": pattern["name"],
            "category": pattern["category"],
            "intent": pattern["intent"],
            "motivation": pattern["motivation"],
            "applicability": pattern["applicability"],
            "structure": pattern["structure"],
            "participants": pattern["participants"],
            "collaborations": pattern["collaborations"],
            "consequences": pattern["consequences"]
        }
    
    def _create_implementation_guide(self, pattern: dict, implementation: dict) -> dict:
        """Create a detailed implementation guide."""
        return {
            "step_by_step": self._create_step_by_step_guide(pattern, implementation),
            "code_examples": self._create_code_examples(pattern, implementation),
            "common_pitfalls": self._create_common_pitfalls(pattern),
            "optimization_tips": self._create_optimization_tips(pattern),
            "integration_guidance": self._create_integration_guidance(pattern)
        }
```

## Benefits

### Code Quality Benefits
- **Understandable Code** - Patterns make code intentions clear
- **Robust Implementation** - Proven patterns provide reliability
- **Maintainable Structure** - Well-applied patterns improve maintainability
- **Testable Design** - Patterns often improve testability

### Development Benefits
- **Expert Decision Making** - Informed pattern selection
- **Consistent Architecture** - Standardized pattern usage
- **Knowledge Sharing** - Documented pattern applications
- **Team Efficiency** - Familiar patterns improve productivity

### System Benefits
- **Scalable Architecture** - Patterns support system growth
- **Flexible Design** - Patterns enable future changes
- **Reliable Operation** - Proven patterns reduce bugs
- **Performance Optimization** - Patterns can improve performance

## Application

### When to Apply
- **Complex Problems** - When simple solutions are insufficient
- **Recurring Patterns** - When similar problems occur frequently
- **Architecture Design** - When designing system architecture
- **Code Refactoring** - When improving existing code structure
- **Team Standards** - When establishing coding standards

### How to Apply
1. **Analyze the Problem** - Understand the problem thoroughly
2. **Identify Candidates** - Find potential patterns that could help
3. **Evaluate Context** - Consider the specific context and constraints
4. **Make Decision** - Choose the best pattern or no pattern
5. **Implement Excellently** - Implement with care and attention to detail
6. **Document Thoroughly** - Document the pattern application

### Success Criteria
- **Problem Solved** - Pattern effectively solves the problem
- **Code Clarity** - Code is more understandable with the pattern
- **Maintainability** - Code is easier to maintain and modify
- **Testability** - Code is easier to test
- **Team Understanding** - Team understands and can work with the pattern

---

**This rule ensures expert application of design patterns to create understandable, robust, and maintainable code.**
description: Expert application of design patterns from GoF, Fowler, and other influential architects
globs: ["**/*.py", "**/*.md", "**/patterns/**", "**/design/**"]
alwaysApply: true
---
description:
globs:
alwaysApply: true
---
