# Code Review and Quality Gates Rule

---
description: "Systematic code review process with quality gates and automated validation"
category: "quality-assurance"
priority: "critical"
alwaysApply: true
globs: ["**/*.py", "**/*.js", "**/*.ts", "**/*.java", "**/*.go"]
tags: ["code-review", "quality-gates", "validation", "standards"]
---

# Code Review and Quality Gates Rule

**CRITICAL**: Implement systematic code review processes with automated quality gates to ensure code quality, security, and maintainability.

## Core Requirements

### 1. Automated Quality Gates
**MANDATORY**: All code must pass automated quality gates before review.

**Quality Gate Requirements**:
- **Test Coverage**: Minimum 90% test coverage for new code
- **Code Quality**: Pylint/flake8 score > 8.0/10
- **Security Scan**: No critical or high severity vulnerabilities
- **Performance**: No performance regressions
- **Documentation**: All public APIs documented
- **Type Safety**: Type hints for all functions and methods

**Implementation**:
```python
# ✅ CORRECT: Quality Gate Implementation
class QualityGate:
    def __init__(self):
        self.gates = {
            "test_coverage": self.check_test_coverage,
            "code_quality": self.check_code_quality,
            "security": self.check_security,
            "performance": self.check_performance,
            "documentation": self.check_documentation,
            "type_safety": self.check_type_safety
        }
    
    def run_quality_gates(self, code_path: str) -> Dict[str, bool]:
        """Run all quality gates on code"""
        results = {}
        
        for gate_name, gate_function in self.gates.items():
            try:
                results[gate_name] = gate_function(code_path)
                if not results[gate_name]:
                    logger.error(f"Quality gate failed: {gate_name}")
            except Exception as e:
                logger.error(f"Quality gate error in {gate_name}: {e}")
                results[gate_name] = False
        
        return results
    
    def check_test_coverage(self, code_path: str) -> bool:
        """Check test coverage meets minimum threshold"""
        coverage = self.run_coverage_analysis(code_path)
        return coverage >= 90.0
    
    def check_code_quality(self, code_path: str) -> bool:
        """Check code quality using static analysis"""
        quality_score = self.run_pylint_analysis(code_path)
        return quality_score >= 8.0
```

### 2. Systematic Code Review Process
**MANDATORY**: Follow systematic code review checklist for all changes.

**Review Checklist**:
- [ ] **Functionality**: Does the code work as intended?
- [ ] **Test Coverage**: Are there adequate tests?
- [ ] **Code Quality**: Is the code clean and maintainable?
- [ ] **Security**: Are there any security vulnerabilities?
- [ ] **Performance**: Are there performance implications?
- [ ] **Documentation**: Is the code well-documented?
- [ ] **Error Handling**: Is error handling appropriate?
- [ ] **Naming**: Are names clear and descriptive?
- [ ] **Architecture**: Does it follow established patterns?

**Implementation**:
```python
# ✅ CORRECT: Systematic Code Review
class CodeReviewer:
    def __init__(self):
        self.review_checklist = [
            "functionality",
            "test_coverage", 
            "code_quality",
            "security",
            "performance",
            "documentation",
            "error_handling",
            "naming",
            "architecture"
        ]
    
    def conduct_review(self, code_changes: List[CodeChange]) -> ReviewResult:
        """Conduct systematic code review"""
        review_result = ReviewResult()
        
        for change in code_changes:
            # Run automated checks
            quality_gates = self.run_quality_gates(change.file_path)
            
            # Manual review checklist
            checklist_results = self.run_review_checklist(change)
            
            # Combine results
            review_result.add_change_review(change, quality_gates, checklist_results)
        
        return review_result
    
    def run_review_checklist(self, change: CodeChange) -> Dict[str, bool]:
        """Run manual review checklist"""
        results = {}
        
        for item in self.review_checklist:
            results[item] = self.check_review_item(change, item)
        
        return results
```

### 3. Automated Review Tools Integration
**MANDATORY**: Integrate automated review tools into the development workflow.

**Required Tools**:
- **Static Analysis**: Pylint, flake8, mypy
- **Security Scanning**: Bandit, safety
- **Test Coverage**: Coverage.py, pytest-cov
- **Performance**: cProfile, memory_profiler
- **Documentation**: pydocstyle, docstring-coverage

**Implementation**:
```python
# ✅ CORRECT: Automated Review Tools
class AutomatedReviewTools:
    def __init__(self):
        self.tools = {
            "static_analysis": StaticAnalyzer(),
            "security_scan": SecurityScanner(),
            "test_coverage": CoverageAnalyzer(),
            "performance": PerformanceAnalyzer(),
            "documentation": DocumentationAnalyzer()
        }
    
    def run_all_checks(self, code_path: str) -> Dict[str, CheckResult]:
        """Run all automated review tools"""
        results = {}
        
        for tool_name, tool in self.tools.items():
            try:
                results[tool_name] = tool.analyze(code_path)
            except Exception as e:
                logger.error(f"Tool {tool_name} failed: {e}")
                results[tool_name] = CheckResult(success=False, errors=[str(e)])
        
        return results

class StaticAnalyzer:
    def analyze(self, code_path: str) -> CheckResult:
        """Run static analysis checks"""
        # Run pylint
        pylint_result = self.run_pylint(code_path)
        
        # Run flake8
        flake8_result = self.run_flake8(code_path)
        
        # Run mypy for type checking
        mypy_result = self.run_mypy(code_path)
        
        return CheckResult(
            success=all([pylint_result.success, flake8_result.success, mypy_result.success]),
            issues=pylint_result.issues + flake8_result.issues + mypy_result.issues
        )
```

### 4. Review Feedback and Iteration
**MANDATORY**: Provide constructive feedback and track review iterations.

**Feedback Requirements**:
- **Specific**: Provide specific, actionable feedback
- **Constructive**: Focus on improvement, not criticism
- **Timely**: Provide feedback within 24 hours
- **Tracked**: Track all feedback and resolutions
- **Iterative**: Support multiple review iterations

**Implementation**:
```python
# ✅ CORRECT: Review Feedback System
class ReviewFeedback:
    def __init__(self):
        self.feedback_database = FeedbackDatabase()
        self.notification_system = NotificationSystem()
    
    def provide_feedback(self, review_id: str, feedback: Feedback) -> None:
        """Provide constructive feedback on code review"""
        # Validate feedback quality
        if not self.is_constructive_feedback(feedback):
            raise ValueError("Feedback must be constructive and specific")
        
        # Store feedback
        self.feedback_database.store_feedback(review_id, feedback)
        
        # Notify developer
        self.notification_system.notify_developer(feedback)
        
        # Track feedback metrics
        self.track_feedback_metrics(feedback)
    
    def is_constructive_feedback(self, feedback: Feedback) -> bool:
        """Validate feedback is constructive"""
        return (
            feedback.is_specific() and
            feedback.is_actionable() and
            feedback.is_respectful() and
            feedback.has_context()
        )
    
    def track_resolution(self, feedback_id: str, resolution: Resolution) -> None:
        """Track feedback resolution"""
        self.feedback_database.update_resolution(feedback_id, resolution)
        
        # Update metrics
        self.update_resolution_metrics(feedback_id, resolution)
```

### 5. Quality Metrics and Reporting
**MANDATORY**: Track and report quality metrics continuously.

**Required Metrics**:
- **Review Time**: Average time to complete reviews
- **Quality Score**: Overall code quality metrics
- **Defect Rate**: Number of defects found in reviews
- **Resolution Time**: Time to resolve review feedback
- **Coverage Trends**: Test coverage over time

**Implementation**:
```python
# ✅ CORRECT: Quality Metrics Tracking
class QualityMetricsTracker:
    def __init__(self):
        self.metrics_database = MetricsDatabase()
        self.reporting_system = ReportingSystem()
    
    def track_review_metrics(self, review: CodeReview) -> None:
        """Track comprehensive review metrics"""
        metrics = {
            "review_time": review.duration,
            "quality_score": review.quality_score,
            "defects_found": len(review.defects),
            "feedback_count": len(review.feedback),
            "coverage_change": review.coverage_change,
            "security_issues": len(review.security_issues)
        }
        
        self.metrics_database.store_metrics(review.id, metrics)
    
    def generate_quality_report(self, time_period: str) -> QualityReport:
        """Generate comprehensive quality report"""
        metrics = self.metrics_database.get_metrics(time_period)
        
        report = QualityReport(
            average_review_time=self.calculate_average_review_time(metrics),
            quality_trend=self.calculate_quality_trend(metrics),
            defect_rate=self.calculate_defect_rate(metrics),
            coverage_trend=self.calculate_coverage_trend(metrics),
            security_issues=self.analyze_security_issues(metrics)
        )
        
        return report
```

## Integration with Development Workflow

### Pre-Review Quality Gates
```python
# ✅ CORRECT: Pre-Review Integration
class PreReviewWorkflow:
    def prepare_for_review(self, code_changes: List[CodeChange]) -> ReviewPreparation:
        """Prepare code changes for review"""
        # Run quality gates
        quality_results = self.run_quality_gates(code_changes)
        
        # Generate review artifacts
        review_artifacts = self.generate_review_artifacts(code_changes)
        
        # Create review request
        review_request = self.create_review_request(code_changes, quality_results, review_artifacts)
        
        return review_request
```

### Post-Review Integration
```python
# ✅ CORRECT: Post-Review Integration
class PostReviewWorkflow:
    def process_review_completion(self, review: CodeReview) -> None:
        """Process completed code review"""
        # Update quality metrics
        self.track_quality_metrics(review)
        
        # Update code quality score
        self.update_code_quality_score(review)
        
        # Generate improvement recommendations
        recommendations = self.generate_improvement_recommendations(review)
        
        # Update development team knowledge
        self.update_team_knowledge(review, recommendations)
```

## Benefits

### Quality Assurance
- **Automated Quality Gates**: Prevent low-quality code from entering the codebase
- **Systematic Reviews**: Ensure consistent review standards
- **Continuous Improvement**: Track and improve quality over time

### Development Efficiency
- **Early Detection**: Catch issues before they become problems
- **Reduced Rework**: Identify issues early in the development cycle
- **Knowledge Sharing**: Share best practices through review process

### Team Collaboration
- **Constructive Feedback**: Foster positive team culture
- **Knowledge Transfer**: Share expertise across team members
- **Mentorship**: Support junior developers through review process

### Risk Mitigation
- **Security**: Prevent security vulnerabilities from entering codebase
- **Performance**: Identify performance issues early
- **Maintainability**: Ensure code is maintainable and well-documented

## Enforcement

This rule is **CRITICAL** and must be followed for all:
- Code changes and pull requests
- Feature development and bug fixes
- Refactoring and optimization work
- Security updates and patches
- Documentation updates

**Violations of this rule require immediate remediation and review process improvement.**
description:
globs:
alwaysApply: true
---
