# PowerShell Commands and File Operations Rule

**CRITICAL**: Always use PowerShell commands for file and directory operations on Windows systems. PowerShell provides better control, error handling, and consistency for file management tasks.

## Core Requirements

### 1. File and Directory Operations
**MANDATORY**: Use PowerShell cmdlets for all file operations
```powershell
# CORRECT: PowerShell directory creation
New-Item -ItemType Directory -Path "docs\guides\observability" -Force

# CORRECT: PowerShell file creation
New-Item -ItemType File -Path "docs\guides\observability\langsmith_guide.md" -Force

# CORRECT: PowerShell file movement
Move-Item "source_file.md" "destination_folder\" -Force

# CORRECT: PowerShell file copying
Copy-Item "source_file.md" "destination_folder\" -Force

# CORRECT: PowerShell file deletion
Remove-Item "file_to_delete.md" -Force

# CORRECT: PowerShell directory deletion
Remove-Item "directory_to_delete" -Recurse -Force
```

### 2. Program Execution
**MANDATORY**: Use PowerShell for starting programs and applications
```powershell
# CORRECT: Start Python with PowerShell
Start-Process -FilePath "python" -ArgumentList "main.py" -NoNewWindow

# CORRECT: Start Streamlit with PowerShell
Start-Process -FilePath "streamlit" -ArgumentList "run", "streamlit_app.py" -NoNewWindow

# CORRECT: Start pytest with PowerShell
Start-Process -FilePath "python" -ArgumentList "-m", "pytest", "tests\" -NoNewWindow

# CORRECT: Start any executable with PowerShell
Start-Process -FilePath "program.exe" -ArgumentList "arg1", "arg2" -NoNewWindow
```

### 3. Environment and Path Management
**MANDATORY**: Use PowerShell for environment operations
```powershell
# CORRECT: Set environment variables
$env:GEMINI_API_KEY = "your-api-key"

# CORRECT: Get environment variables
$api_key = $env:GEMINI_API_KEY

# CORRECT: Change directory
Set-Location "C:\path\to\project"

# CORRECT: Get current directory
$current_path = Get-Location
```

## PowerShell Command Patterns

### 1. Directory Operations
```powershell
# Create single directory
New-Item -ItemType Directory -Path "folder_name" -Force

# Create multiple directories
New-Item -ItemType Directory -Path "folder1", "folder2", "folder3" -Force

# Create nested directory structure
New-Item -ItemType Directory -Path "parent\child\grandchild" -Force

# Check if directory exists
if (Test-Path "folder_name") {
    Write-Host "Directory exists"
}

# Remove directory with contents
Remove-Item "folder_name" -Recurse -Force -ErrorAction SilentlyContinue
```

### 2. File Operations
```powershell
# Create file
New-Item -ItemType File -Path "file_name.txt" -Force

# Move file
Move-Item "source_file.txt" "destination_folder\" -Force

# Copy file
Copy-Item "source_file.txt" "destination_folder\" -Force

# Remove file
Remove-Item "file_to_delete.txt" -Force -ErrorAction SilentlyContinue

# Check if file exists
if (Test-Path "file_name.txt") {
    Write-Host "File exists"
}

# Read file content
$content = Get-Content "file_name.txt"

# Write content to file
Set-Content "file_name.txt" -Value "content"
```

### 3. Batch Operations
```powershell
# Create multiple files
@("file1.txt", "file2.txt", "file3.txt") | ForEach-Object {
    New-Item -ItemType File -Path $_ -Force
}

# Move multiple files
Get-ChildItem "*.txt" | Move-Item -Destination "destination_folder\" -Force

# Remove multiple files
Get-ChildItem "*.tmp" | Remove-Item -Force

# Create directory structure with files
$structure = @{
    "docs" = @{
        "guides" = @{
            "observability" = @("langsmith_guide.md", "monitoring_guide.md")
            "implementation" = @("setup_guide.md", "deployment_guide.md")
        }
    }
}
```

### 4. Error Handling
```powershell
# Safe directory creation with error handling
try {
    New-Item -ItemType Directory -Path "new_folder" -Force
    Write-Host "Directory created successfully"
} catch {
    Write-Host "Error creating directory: $($_.Exception.Message)"
}

# Safe file operations with error handling
try {
    Move-Item "source_file.txt" "destination_folder\" -Force
    Write-Host "File moved successfully"
} catch {
    Write-Host "Error moving file: $($_.Exception.Message)"
}

# Safe deletion with error suppression
Remove-Item "file_or_folder" -Recurse -Force -ErrorAction SilentlyContinue
```

## Forbidden Commands

### 1. Avoid Bash/Unix Commands
```bash
# FORBIDDEN: Unix-style commands on Windows
mkdir folder_name
mv source_file destination/
cp source_file destination/
rm file_name
ls directory_name
```

### 2. Avoid Basic Windows Commands
```cmd
# FORBIDDEN: Basic Windows commands
md folder_name
move source_file destination\
copy source_file destination\
del file_name
dir directory_name
```

### 3. Avoid Direct Executable Calls
```cmd
# FORBIDDEN: Direct executable calls
python main.py
streamlit run streamlit_app.py
pytest tests\
```

## Best Practices

### 1. Use Descriptive Paths
```powershell
# CORRECT: Use descriptive, full paths
New-Item -ItemType Directory -Path "docs\guides\observability" -Force

# CORRECT: Use variables for complex paths
$docs_path = "docs\guides\observability"
New-Item -ItemType Directory -Path $docs_path -Force
```

### 2. Use Consistent Error Handling
```powershell
# CORRECT: Consistent error handling pattern
function Create-DirectorySafely {
    param([string]$Path)
    
    try {
        New-Item -ItemType Directory -Path $Path -Force
        Write-Host "Directory created: $Path"
        return $true
    } catch {
        Write-Host "Error creating directory: $($_.Exception.Message)"
        return $false
    }
}
```

### 3. Use PowerShell Aliases Sparingly
```powershell
# CORRECT: Use full cmdlet names for clarity
New-Item -ItemType Directory -Path "folder_name" -Force

# AVOID: Using aliases in scripts
# md folder_name  # Less clear than New-Item
```

### 4. Use Proper Parameter Names
```powershell
# CORRECT: Use full parameter names
New-Item -ItemType Directory -Path "folder_name" -Force

# AVOID: Using abbreviated parameters
# New-Item -Type Directory -Path "folder_name" -Force
```

## Implementation Guidelines

### 1. File Creation Workflow
```powershell
# Standard file creation workflow
function Create-ProjectFile {
    param(
        [string]$FilePath,
        [string]$Content = ""
    )
    
    try {
        # Create directory if it doesn't exist
        $directory = Split-Path $FilePath -Parent
        if (!(Test-Path $directory)) {
            New-Item -ItemType Directory -Path $directory -Force
        }
        
        # Create file
        New-Item -ItemType File -Path $FilePath -Force
        
        # Add content if provided
        if ($Content) {
            Set-Content -Path $FilePath -Value $Content
        }
        
        Write-Host "File created: $FilePath"
        return $true
    } catch {
        Write-Host "Error creating file: $($_.Exception.Message)"
        return $false
    }
}
```

### 2. Directory Structure Creation
```powershell
# Create complete directory structure
function Create-ProjectStructure {
    param([hashtable]$Structure)
    
    function Create-StructureRecursive {
        param([hashtable]$Node, [string]$Path)
        
        foreach ($key in $Node.Keys) {
            $currentPath = Join-Path $Path $key
            
            if ($Node[$key] -is [hashtable]) {
                # Create directory
                New-Item -ItemType Directory -Path $currentPath -Force
                Create-StructureRecursive -Node $Node[$key] -Path $currentPath
            } elseif ($Node[$key] -is [array]) {
                # Create directory and files
                New-Item -ItemType Directory -Path $currentPath -Force
                foreach ($file in $Node[$key]) {
                    New-Item -ItemType File -Path (Join-Path $currentPath $file) -Force
                }
            }
        }
    }
    
    Create-StructureRecursive -Node $Structure -Path "."
}
```

### 3. Safe File Operations
```powershell
# Safe file operations with backup
function Move-FileSafely {
    param(
        [string]$Source,
        [string]$Destination,
        [switch]$CreateBackup
    )
    
    try {
        if ($CreateBackup -and (Test-Path $Source)) {
            $backupPath = "$Source.backup"
            Copy-Item $Source $backupPath -Force
            Write-Host "Backup created: $backupPath"
        }
        
        Move-Item $Source $Destination -Force
        Write-Host "File moved: $Source -> $Destination"
        return $true
    } catch {
        Write-Host "Error moving file: $($_.Exception.Message)"
        return $false
    }
}
```

## Error Handling Standards

### 1. Always Use Try-Catch
```powershell
# CORRECT: Always handle errors
try {
    New-Item -ItemType Directory -Path "new_folder" -Force
} catch {
    Write-Host "Error: $($_.Exception.Message)"
    # Handle error appropriately
}
```

### 2. Use ErrorAction Parameter
```powershell
# CORRECT: Use ErrorAction for non-critical operations
Remove-Item "temp_file.txt" -Force -ErrorAction SilentlyContinue

# CORRECT: Use ErrorAction for directory cleanup
Remove-Item "temp_folder" -Recurse -Force -ErrorAction SilentlyContinue
```

### 3. Validate Before Operations
```powershell
# CORRECT: Validate before operations
if (Test-Path "source_file.txt") {
    Move-Item "source_file.txt" "destination_folder\" -Force
} else {
    Write-Host "Source file not found"
}
```

## Performance Considerations

### 1. Use Batch Operations
```powershell
# CORRECT: Batch operations for multiple files
Get-ChildItem "*.txt" | Move-Item -Destination "destination_folder\" -Force

# CORRECT: Batch directory creation
@("folder1", "folder2", "folder3") | ForEach-Object {
    New-Item -ItemType Directory -Path $_ -Force
}
```

### 2. Avoid Unnecessary Operations
```powershell
# CORRECT: Check before creating
if (!(Test-Path "folder_name")) {
    New-Item -ItemType Directory -Path "folder_name" -Force
}

# CORRECT: Use -Force to overwrite existing
New-Item -ItemType File -Path "file_name.txt" -Force
```

## Benefits

- **Consistency**: Uniform file operations across Windows systems
- **Error Handling**: Better error handling and recovery
- **Performance**: Optimized operations for Windows
- **Reliability**: More reliable than basic Windows commands
- **Flexibility**: Rich parameter options and control
- **Integration**: Better integration with Windows environment

## Enforcement

This rule is **ALWAYS APPLIED** and must be followed for all:
- File and directory creation
- File and directory movement
- File and directory deletion
- Program execution and startup
- Environment variable management
- Path operations

**Violations of this rule require immediate remediation.**

## Examples

### Correct PowerShell Usage
```powershell
# ✅ CORRECT: Create directory structure
New-Item -ItemType Directory -Path "docs\guides\observability" -Force

# ✅ CORRECT: Move documentation files
Move-Item "docs\database_automation_guide.md" "docs\guides\database\" -Force

# ✅ CORRECT: Start application
Start-Process -FilePath "python" -ArgumentList "main.py" -NoNewWindow

# ✅ CORRECT: Clean up temporary files
Remove-Item "temp" -Recurse -Force -ErrorAction SilentlyContinue
```

### Incorrect Usage
```bash
# ❌ FORBIDDEN: Unix commands
mkdir docs/guides/observability
mv file.txt destination/

# ❌ FORBIDDEN: Basic Windows commands
md docs\guides\observability
move file.txt destination\

# ❌ FORBIDDEN: Direct executable calls
python main.py
streamlit run streamlit_app.py
```

**Remember**: Always use PowerShell cmdlets for file operations on Windows systems to ensure consistency, reliability, and proper error handling.
description:
globs:
alwaysApply: true
---
