# Security Vulnerability Assessment Rule

---
description: "Comprehensive security vulnerability assessment and prevention with proactive security practices"
category: "security"
priority: "critical"
alwaysApply: true
globs: ["**/*.py", "**/*.js", "**/*.ts", "**/*.java", "**/*.go", "**/*.sql"]
tags: ["security", "vulnerability", "assessment", "prevention", "scanning"]
---

# Security Vulnerability Assessment Rule

**CRITICAL**: Implement comprehensive security vulnerability assessment and prevention practices throughout the development lifecycle to ensure secure, robust applications.

## Core Requirements

### 1. Security Scanning and Assessment
**MANDATORY**: Conduct comprehensive security scanning and vulnerability assessment for all code and dependencies.

**Security Scanning Requirements**:
- **Static Application Security Testing (SAST)**: Scan source code for security vulnerabilities
- **Dynamic Application Security Testing (DAST)**: Test running applications for security issues
- **Dependency Scanning**: Scan all dependencies for known vulnerabilities
- **Container Security**: Scan container images for security issues
- **Infrastructure Security**: Assess infrastructure configuration security

**Implementation**:
```python
# ✅ CORRECT: Security Scanning
class SecurityScanner:
    def __init__(self):
        self.sast_scanner = SASTScanner()
        self.dast_scanner = DASTScanner()
        self.dependency_scanner = DependencyScanner()
        self.container_scanner = ContainerScanner()
        self.infrastructure_scanner = InfrastructureScanner()
    
    def run_comprehensive_scan(self, project_path: str) -> SecurityScanReport:
        """Run comprehensive security scan"""
        scan_report = SecurityScanReport(project_path=project_path)
        
        # SAST scanning
        sast_results = self.sast_scanner.scan_code(project_path)
        scan_report.add_sast_results(sast_results)
        
        # Dependency scanning
        dependency_results = self.dependency_scanner.scan_dependencies(project_path)
        scan_report.add_dependency_results(dependency_results)
        
        # Container scanning (if applicable)
        if self.has_containers(project_path):
            container_results = self.container_scanner.scan_containers(project_path)
            scan_report.add_container_results(container_results)
        
        # Infrastructure scanning
        infrastructure_results = self.infrastructure_scanner.scan_infrastructure(project_path)
        scan_report.add_infrastructure_results(infrastructure_results)
        
        return scan_report
    
    def assess_vulnerabilities(self, scan_report: SecurityScanReport) -> VulnerabilityAssessment:
        """Assess and prioritize vulnerabilities"""
        assessment = VulnerabilityAssessment()
        
        # Categorize vulnerabilities by severity
        critical_vulns = self.filter_by_severity(scan_report.vulnerabilities, "critical")
        high_vulns = self.filter_by_severity(scan_report.vulnerabilities, "high")
        medium_vulns = self.filter_by_severity(scan_report.vulnerabilities, "medium")
        low_vulns = self.filter_by_severity(scan_report.vulnerabilities, "low")
        
        # Add to assessment
        assessment.add_vulnerabilities("critical", critical_vulns)
        assessment.add_vulnerabilities("high", high_vulns)
        assessment.add_vulnerabilities("medium", medium_vulns)
        assessment.add_vulnerabilities("low", low_vulns)
        
        # Calculate risk scores
        assessment.calculate_risk_scores()
        
        return assessment

class SASTScanner:
    def scan_code(self, project_path: str) -> SASTResults:
        """Scan source code for security vulnerabilities"""
        import bandit
        import subprocess
        
        # Run Bandit for Python security scanning
        if self.has_python_files(project_path):
            bandit_results = self.run_bandit_scan(project_path)
        
        # Run ESLint security plugin for JavaScript/TypeScript
        if self.has_javascript_files(project_path):
            eslint_results = self.run_eslint_security_scan(project_path)
        
        # Run SonarQube for comprehensive analysis
        sonarqube_results = self.run_sonarqube_scan(project_path)
        
        return SASTResults(
            bandit_results=bandit_results,
            eslint_results=eslint_results,
            sonarqube_results=sonarqube_results
        )
    
    def run_bandit_scan(self, project_path: str) -> BanditResults:
        """Run Bandit security scanner"""
        import subprocess
        
        try:
            result = subprocess.run([
                "bandit", "-r", project_path, "-f", "json", "-o", "bandit_report.json"
            ], capture_output=True, text=True)
            
            if result.returncode == 0:
                return self.parse_bandit_results("bandit_report.json")
            else:
                raise SecurityScanError(f"Bandit scan failed: {result.stderr}")
                
        except Exception as e:
            raise SecurityScanError(f"Bandit scan error: {e}")
```

### 2. OWASP Top 10 Compliance
**MANDATORY**: Ensure compliance with OWASP Top 10 security risks and implement appropriate mitigations.

**OWASP Top 10 Requirements**:
- **A01:2021 - Broken Access Control**: Implement proper authentication and authorization
- **A02:2021 - Cryptographic Failures**: Use secure cryptographic practices
- **A03:2021 - Injection**: Prevent SQL injection, XSS, and other injection attacks
- **A04:2021 - Insecure Design**: Design security into applications from the start
- **A05:2021 - Security Misconfiguration**: Secure configuration management
- **A06:2021 - Vulnerable Components**: Keep dependencies updated and secure
- **A07:2021 - Authentication Failures**: Implement secure authentication
- **A08:2021 - Software and Data Integrity**: Ensure data integrity and secure updates
- **A09:2021 - Security Logging Failures**: Implement comprehensive security logging
- **A10:2021 - Server-Side Request Forgery**: Prevent SSRF attacks

**Implementation**:
```python
# ✅ CORRECT: OWASP Compliance
class OWASPComplianceChecker:
    def __init__(self):
        self.access_control_checker = AccessControlChecker()
        self.cryptography_checker = CryptographyChecker()
        self.injection_checker = InjectionChecker()
        self.design_checker = SecurityDesignChecker()
        self.configuration_checker = ConfigurationChecker()
        self.component_checker = ComponentChecker()
        self.authentication_checker = AuthenticationChecker()
        self.integrity_checker = IntegrityChecker()
        self.logging_checker = SecurityLoggingChecker()
        self.ssrf_checker = SSRFChecker()
    
    def check_owasp_compliance(self, application: Application) -> OWASPComplianceReport:
        """Check compliance with OWASP Top 10"""
        compliance_report = OWASPComplianceReport()
        
        # Check each OWASP category
        compliance_report.add_check("A01", self.access_control_checker.check(application))
        compliance_report.add_check("A02", self.cryptography_checker.check(application))
        compliance_report.add_check("A03", self.injection_checker.check(application))
        compliance_report.add_check("A04", self.design_checker.check(application))
        compliance_report.add_check("A05", self.configuration_checker.check(application))
        compliance_report.add_check("A06", self.component_checker.check(application))
        compliance_report.add_check("A07", self.authentication_checker.check(application))
        compliance_report.add_check("A08", self.integrity_checker.check(application))
        compliance_report.add_check("A09", self.logging_checker.check(application))
        compliance_report.add_check("A10", self.ssrf_checker.check(application))
        
        return compliance_report

class InjectionChecker:
    def check(self, application: Application) -> InjectionCheckResult:
        """Check for injection vulnerabilities"""
        result = InjectionCheckResult()
        
        # Check for SQL injection
        sql_injection_vulns = self.check_sql_injection(application)
        result.add_sql_injection_vulns(sql_injection_vulns)
        
        # Check for XSS
        xss_vulns = self.check_xss(application)
        result.add_xss_vulns(xss_vulns)
        
        # Check for command injection
        command_injection_vulns = self.check_command_injection(application)
        result.add_command_injection_vulns(command_injection_vulns)
        
        return result
    
    def check_sql_injection(self, application: Application) -> List[Vulnerability]:
        """Check for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        # Check for raw SQL queries
        raw_sql_patterns = [
            r"execute\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
            r"cursor\.execute\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
            r"\.execute\s*\(\s*f[\"'].*\{\w+\}.*[\"']"
        ]
        
        for file_path in application.get_python_files():
            with open(file_path, 'r') as f:
                content = f.read()
                for pattern in raw_sql_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    for match in matches:
                        vulnerabilities.append(Vulnerability(
                            type="sql_injection",
                            severity="high",
                            file_path=file_path,
                            line_number=self.find_line_number(content, match),
                            description=f"Potential SQL injection: {match}",
                            recommendation="Use parameterized queries or ORM"
                        ))
        
        return vulnerabilities
```

### 3. Secure Coding Practices
**MANDATORY**: Implement secure coding practices and patterns throughout development.

**Secure Coding Requirements**:
- **Input Validation**: Validate and sanitize all inputs
- **Output Encoding**: Properly encode outputs to prevent injection
- **Authentication**: Implement secure authentication mechanisms
- **Authorization**: Implement proper access control
- **Session Management**: Secure session handling
- **Error Handling**: Secure error handling without information disclosure
- **Cryptography**: Use secure cryptographic practices
- **Secure Communication**: Use HTTPS and secure protocols

**Implementation**:
```python
# ✅ CORRECT: Secure Coding Practices
class SecureCodingValidator:
    def __init__(self):
        self.input_validator = InputValidator()
        self.output_encoder = OutputEncoder()
        self.auth_validator = AuthenticationValidator()
        self.authorization_validator = AuthorizationValidator()
        self.session_validator = SessionValidator()
        self.error_handler = SecureErrorHandler()
        self.crypto_validator = CryptographyValidator()
        self.communication_validator = CommunicationValidator()
    
    def validate_secure_coding(self, code: str) -> SecureCodingReport:
        """Validate secure coding practices"""
        report = SecureCodingReport()
        
        # Check input validation
        input_issues = self.input_validator.check_input_validation(code)
        report.add_input_issues(input_issues)
        
        # Check output encoding
        output_issues = self.output_encoder.check_output_encoding(code)
        report.add_output_issues(output_issues)
        
        # Check authentication
        auth_issues = self.auth_validator.check_authentication(code)
        report.add_auth_issues(auth_issues)
        
        # Check authorization
        authz_issues = self.authorization_validator.check_authorization(code)
        report.add_authz_issues(authz_issues)
        
        # Check session management
        session_issues = self.session_validator.check_session_management(code)
        report.add_session_issues(session_issues)
        
        # Check error handling
        error_issues = self.error_handler.check_error_handling(code)
        report.add_error_issues(error_issues)
        
        # Check cryptography
        crypto_issues = self.crypto_validator.check_cryptography(code)
        report.add_crypto_issues(crypto_issues)
        
        # Check secure communication
        comm_issues = self.communication_validator.check_secure_communication(code)
        report.add_communication_issues(comm_issues)
        
        return report

class InputValidator:
    def check_input_validation(self, code: str) -> List[SecurityIssue]:
        """Check for proper input validation"""
        issues = []
        
        # Check for missing input validation patterns
        dangerous_patterns = [
            r"request\.form\[[\"'](\w+)[\"']\]",
            r"request\.args\[[\"'](\w+)[\"']\]",
            r"request\.json\[[\"'](\w+)[\"']\]",
            r"request\.cookies\[[\"'](\w+)[\"']\]"
        ]
        
        for pattern in dangerous_patterns:
            matches = re.finditer(pattern, code)
            for match in matches:
                variable_name = match.group(1)
                
                # Check if variable is validated
                if not self.is_variable_validated(code, variable_name):
                    issues.append(SecurityIssue(
                        type="missing_input_validation",
                        severity="high",
                        line_number=self.get_line_number(code, match.start()),
                        description=f"Input '{variable_name}' is not validated",
                        recommendation="Add input validation using a validation library"
                    ))
        
        return issues
    
    def is_variable_validated(self, code: str, variable_name: str) -> bool:
        """Check if variable has validation"""
        validation_patterns = [
            rf"validate_{variable_name}",
            rf"is_valid_{variable_name}",
            rf"check_{variable_name}",
            rf"sanitize_{variable_name}"
        ]
        
        for pattern in validation_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                return True
        
        return False
```

### 4. Security Testing and Validation
**MANDATORY**: Implement comprehensive security testing to validate security measures.

**Security Testing Requirements**:
- **Penetration Testing**: Simulate real-world attacks
- **Vulnerability Assessment**: Identify security weaknesses
- **Security Code Review**: Manual security code review
- **Threat Modeling**: Identify and mitigate threats
- **Security Regression Testing**: Ensure security measures remain effective

**Implementation**:
```python
# ✅ CORRECT: Security Testing
class SecurityTester:
    def __init__(self):
        self.penetration_tester = PenetrationTester()
        self.vulnerability_assessor = VulnerabilityAssessor()
        self.security_reviewer = SecurityCodeReviewer()
        self.threat_modeler = ThreatModeler()
        self.regression_tester = SecurityRegressionTester()
    
    def run_security_tests(self, application: Application) -> SecurityTestReport:
        """Run comprehensive security tests"""
        test_report = SecurityTestReport()
        
        # Penetration testing
        pentest_results = self.penetration_tester.test(application)
        test_report.add_pentest_results(pentest_results)
        
        # Vulnerability assessment
        vuln_results = self.vulnerability_assessor.assess(application)
        test_report.add_vulnerability_results(vuln_results)
        
        # Security code review
        review_results = self.security_reviewer.review(application)
        test_report.add_review_results(review_results)
        
        # Threat modeling
        threat_results = self.threat_modeler.model_threats(application)
        test_report.add_threat_results(threat_results)
        
        # Security regression testing
        regression_results = self.regression_tester.test(application)
        test_report.add_regression_results(regression_results)
        
        return test_report

class PenetrationTester:
    def test(self, application: Application) -> PenetrationTestResults:
        """Conduct penetration testing"""
        results = PenetrationTestResults()
        
        # Test authentication bypass
        auth_bypass_results = self.test_authentication_bypass(application)
        results.add_auth_bypass_results(auth_bypass_results)
        
        # Test privilege escalation
        priv_esc_results = self.test_privilege_escalation(application)
        results.add_privilege_escalation_results(priv_esc_results)
        
        # Test injection attacks
        injection_results = self.test_injection_attacks(application)
        results.add_injection_results(injection_results)
        
        # Test session management
        session_results = self.test_session_management(application)
        results.add_session_results(session_results)
        
        # Test business logic flaws
        logic_results = self.test_business_logic_flaws(application)
        results.add_logic_results(logic_results)
        
        return results
    
    def test_authentication_bypass(self, application: Application) -> List[SecurityVulnerability]:
        """Test for authentication bypass vulnerabilities"""
        vulnerabilities = []
        
        # Test common authentication bypass techniques
        bypass_techniques = [
            "admin'--",
            "admin' OR '1'='1",
            "admin' UNION SELECT 1,2,3--",
            "admin'/*",
            "admin'#"
        ]
        
        for technique in bypass_techniques:
            try:
                response = self.send_auth_request(application, technique)
                if response.is_authenticated():
                    vulnerabilities.append(SecurityVulnerability(
                        type="authentication_bypass",
                        severity="critical",
                        technique=technique,
                        description=f"Authentication bypassed using: {technique}",
                        recommendation="Implement proper input validation and parameterized queries"
                    ))
            except Exception as e:
                # Log error but continue testing
                logger.warning(f"Auth bypass test failed: {e}")
        
        return vulnerabilities
```

### 5. Security Monitoring and Incident Response
**MANDATORY**: Implement security monitoring and incident response capabilities.

**Security Monitoring Requirements**:
- **Security Event Logging**: Comprehensive security event logging
- **Real-time Monitoring**: Real-time security monitoring and alerting
- **Threat Detection**: Automated threat detection and response
- **Incident Response**: Incident response procedures and automation
- **Forensic Analysis**: Security incident forensic analysis capabilities

**Implementation**:
```python
# ✅ CORRECT: Security Monitoring
class SecurityMonitor:
    def __init__(self):
        self.event_logger = SecurityEventLogger()
        self.real_time_monitor = RealTimeMonitor()
        self.threat_detector = ThreatDetector()
        self.incident_responder = IncidentResponder()
        self.forensic_analyzer = ForensicAnalyzer()
    
    def monitor_security(self) -> SecurityMonitoringReport:
        """Monitor security events and threats"""
        monitoring_report = SecurityMonitoringReport()
        
        # Log security events
        events = self.event_logger.collect_events()
        monitoring_report.add_events(events)
        
        # Real-time monitoring
        alerts = self.real_time_monitor.check_alerts()
        monitoring_report.add_alerts(alerts)
        
        # Threat detection
        threats = self.threat_detector.detect_threats()
        monitoring_report.add_threats(threats)
        
        # Incident response
        incidents = self.incident_responder.handle_incidents(threats)
        monitoring_report.add_incidents(incidents)
        
        return monitoring_report

class SecurityEventLogger:
    def collect_events(self) -> List[SecurityEvent]:
        """Collect security events from various sources"""
        events = []
        
        # Collect authentication events
        auth_events = self.collect_auth_events()
        events.extend(auth_events)
        
        # Collect authorization events
        authz_events = self.collect_authz_events()
        events.extend(authz_events)
        
        # Collect access events
        access_events = self.collect_access_events()
        events.extend(access_events)
        
        # Collect error events
        error_events = self.collect_error_events()
        events.extend(error_events)
        
        return events
    
    def collect_auth_events(self) -> List[SecurityEvent]:
        """Collect authentication events"""
        events = []
        
        # Monitor login attempts
        login_attempts = self.monitor_login_attempts()
        for attempt in login_attempts:
            if attempt.is_suspicious():
                events.append(SecurityEvent(
                    type="suspicious_login",
                    severity="medium",
                    timestamp=attempt.timestamp,
                    user=attempt.user,
                    ip_address=attempt.ip_address,
                    description=f"Suspicious login attempt from {attempt.ip_address}"
                ))
        
        return events
```

## Integration with Development Workflow

### Pre-Commit Security Checks
```python
# ✅ CORRECT: Pre-Commit Security Validation
class PreCommitSecurityCheck:
    def validate_security(self, code_changes: List[CodeChange]) -> SecurityValidation:
        """Validate security before commit"""
        # Run security scans
        scan_results = self.run_security_scans(code_changes)
        
        # Check for critical vulnerabilities
        critical_vulns = self.find_critical_vulnerabilities(scan_results)
        
        if critical_vulns:
            raise SecurityValidationError(f"Critical vulnerabilities found: {critical_vulns}")
        
        return SecurityValidation(success=True, scan_results=scan_results)
```

### Continuous Security Monitoring
```python
# ✅ CORRECT: Continuous Security Monitoring
class ContinuousSecurityMonitor:
    def monitor_continuously(self) -> None:
        """Continuously monitor security"""
        while True:
            # Collect security metrics
            metrics = self.collect_security_metrics()
            
            # Analyze security posture
            analysis = self.analyze_security_posture(metrics)
            
            # Check for security issues
            if analysis.has_issues():
                self.handle_security_issues(analysis)
            
            # Update security dashboard
            self.update_security_dashboard(metrics, analysis)
            
            # Wait for next cycle
            time.sleep(300)  # Check every 5 minutes
```

## Benefits

### Security Assurance
- **Proactive Security**: Identify and fix security issues before they become problems
- **Compliance**: Ensure compliance with security standards and regulations
- **Risk Reduction**: Reduce security risks and potential breaches

### Development Efficiency
- **Early Detection**: Catch security issues early in development
- **Automated Testing**: Automate security testing and validation
- **Security by Design**: Build security into applications from the start

### Risk Mitigation
- **Vulnerability Prevention**: Prevent common security vulnerabilities
- **Incident Response**: Rapid response to security incidents
- **Forensic Capabilities**: Investigate and analyze security incidents

### Compliance and Trust
- **Regulatory Compliance**: Meet security compliance requirements
- **Customer Trust**: Build trust through robust security practices
- **Business Continuity**: Ensure business continuity through security measures

## Enforcement

This rule is **CRITICAL** and must be followed for all:
- Code development and changes
- Application deployments and releases
- Infrastructure configuration
- Dependency management
- Security incident response

**Violations of this rule require immediate security assessment and remediation.**
description:
globs:
alwaysApply: true
---
