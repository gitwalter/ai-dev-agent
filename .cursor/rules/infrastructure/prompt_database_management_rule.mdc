# Prompt Database Management Rule

---
description: "Database-first prompt management system with centralized storage and version control"
category: "prompt-management"
priority: "critical"
alwaysApply: true
globs: ["**/*.py", "**/*.md", "**/*.txt"]
tags: ["prompt", "database", "management", "centralized", "version-control"]
---

# Prompt Database Management Rule

**CRITICAL**: Use database-first prompt management system with centralized storage, version control, and performance tracking. Never use hardcoded prompts except as emergency fallbacks.

## Core Requirements

### 1. Database-First Prompt Storage
**MANDATORY**: Store all prompts in SQLite database with comprehensive metadata.

**Database Schema Requirements**:
- **Prompt ID**: Unique identifier for each prompt
- **Prompt Type**: Category (agent, system, workflow, error_handling)
- **Prompt Content**: The actual prompt text
- **Version**: Version number for prompt evolution
- **Performance Metrics**: Success rate, response quality, usage statistics
- **Metadata**: Creation date, last updated, author, tags
- **Dependencies**: Related prompts and context

**Implementation**:
```python
# ✅ CORRECT: Database-First Prompt Management
import sqlite3
from datetime import datetime
from typing import Dict, List, Optional
import json

class PromptDatabaseManager:
    def __init__(self, db_path: str = "prompts/prompt_templates.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize prompt database with proper schema"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS prompts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    prompt_id TEXT UNIQUE NOT NULL,
                    prompt_type TEXT NOT NULL,
                    prompt_content TEXT NOT NULL,
                    version INTEGER DEFAULT 1,
                    success_rate REAL DEFAULT 0.0,
                    usage_count INTEGER DEFAULT 0,
                    avg_response_time REAL DEFAULT 0.0,
                    quality_score REAL DEFAULT 0.0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    author TEXT,
                    tags TEXT,
                    dependencies TEXT,
                    is_active BOOLEAN DEFAULT TRUE
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS prompt_versions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    prompt_id TEXT NOT NULL,
                    version INTEGER NOT NULL,
                    prompt_content TEXT NOT NULL,
                    change_reason TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (prompt_id) REFERENCES prompts (prompt_id)
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS prompt_performance (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    prompt_id TEXT NOT NULL,
                    execution_time REAL,
                    success BOOLEAN,
                    quality_score REAL,
                    user_feedback TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (prompt_id) REFERENCES prompts (prompt_id)
                )
            """)
    
    def store_prompt(self, prompt_id: str, prompt_type: str, content: str, 
                    author: str = None, tags: List[str] = None, 
                    dependencies: List[str] = None) -> bool:
        """Store prompt in database with version control"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                # Check if prompt exists
                cursor = conn.execute(
                    "SELECT version FROM prompts WHERE prompt_id = ?", 
                    (prompt_id,)
                )
                existing = cursor.fetchone()
                
                if existing:
                    # Increment version and store in versions table
                    new_version = existing[0] + 1
                    conn.execute("""
                        INSERT INTO prompt_versions (prompt_id, version, prompt_content)
                        VALUES (?, ?, ?)
                    """, (prompt_id, new_version, content))
                    
                    # Update main prompt
                    conn.execute("""
                        UPDATE prompts 
                        SET prompt_content = ?, version = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE prompt_id = ?
                    """, (content, new_version, prompt_id))
                else:
                    # Create new prompt
                    conn.execute("""
                        INSERT INTO prompts (prompt_id, prompt_type, prompt_content, author, tags, dependencies)
                        VALUES (?, ?, ?, ?, ?, ?)
                    """, (
                        prompt_id, 
                        prompt_type, 
                        content, 
                        author,
                        json.dumps(tags) if tags else None,
                        json.dumps(dependencies) if dependencies else None
                    ))
                
                conn.commit()
                return True
                
        except Exception as e:
            logger.error(f"Failed to store prompt {prompt_id}: {e}")
            return False
    
    def get_prompt(self, prompt_id: str, version: Optional[int] = None) -> Optional[Dict]:
        """Retrieve prompt from database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                if version:
                    # Get specific version
                    cursor = conn.execute("""
                        SELECT prompt_content, version, created_at 
                        FROM prompt_versions 
                        WHERE prompt_id = ? AND version = ?
                    """, (prompt_id, version))
                else:
                    # Get latest version
                    cursor = conn.execute("""
                        SELECT prompt_content, version, updated_at, success_rate, usage_count
                        FROM prompts 
                        WHERE prompt_id = ? AND is_active = TRUE
                    """, (prompt_id,))
                
                result = cursor.fetchone()
                if result:
                    return {
                        "prompt_id": prompt_id,
                        "content": result[0],
                        "version": result[1],
                        "last_updated": result[2],
                        "success_rate": result[3] if len(result) > 3 else None,
                        "usage_count": result[4] if len(result) > 4 else None
                    }
                return None
                
        except Exception as e:
            logger.error(f"Failed to retrieve prompt {prompt_id}: {e}")
            return None
```

### 2. Prompt Performance Tracking
**MANDATORY**: Track prompt performance metrics for continuous improvement.

**Performance Metrics**:
- **Success Rate**: Percentage of successful executions
- **Response Time**: Average response time
- **Quality Score**: User feedback and quality assessment
- **Usage Statistics**: Frequency and context of usage
- **Error Analysis**: Common failure patterns and reasons

**Implementation**:
```python
# ✅ CORRECT: Performance Tracking
class PromptPerformanceTracker:
    def __init__(self, db_manager: PromptDatabaseManager):
        self.db_manager = db_manager
    
    def record_execution(self, prompt_id: str, execution_time: float, 
                        success: bool, quality_score: float = None, 
                        user_feedback: str = None) -> bool:
        """Record prompt execution performance"""
        try:
            with sqlite3.connect(self.db_manager.db_path) as conn:
                # Record execution
                conn.execute("""
                    INSERT INTO prompt_performance 
                    (prompt_id, execution_time, success, quality_score, user_feedback)
                    VALUES (?, ?, ?, ?, ?)
                """, (prompt_id, execution_time, success, quality_score, user_feedback))
                
                # Update aggregated metrics
                self.update_aggregated_metrics(conn, prompt_id)
                
                conn.commit()
                return True
                
        except Exception as e:
            logger.error(f"Failed to record execution for {prompt_id}: {e}")
            return False
    
    def update_aggregated_metrics(self, conn, prompt_id: str):
        """Update aggregated performance metrics for prompt"""
        # Calculate success rate
        cursor = conn.execute("""
            SELECT 
                COUNT(*) as total_executions,
                SUM(CASE WHEN success THEN 1 ELSE 0 END) as successful_executions,
                AVG(execution_time) as avg_execution_time,
                AVG(quality_score) as avg_quality_score
            FROM prompt_performance 
            WHERE prompt_id = ?
        """, (prompt_id,))
        
        metrics = cursor.fetchone()
        if metrics and metrics[0] > 0:
            success_rate = metrics[1] / metrics[0] if metrics[0] > 0 else 0.0
            
            # Update prompt metrics
            conn.execute("""
                UPDATE prompts 
                SET success_rate = ?, avg_response_time = ?, quality_score = ?, usage_count = ?
                WHERE prompt_id = ?
            """, (success_rate, metrics[2], metrics[3], metrics[0], prompt_id))
    
    def get_performance_report(self, prompt_id: str) -> Dict:
        """Generate comprehensive performance report"""
        try:
            with sqlite3.connect(self.db_manager.db_path) as conn:
                cursor = conn.execute("""
                    SELECT 
                        success_rate,
                        usage_count,
                        avg_response_time,
                        quality_score,
                        created_at,
                        updated_at
                    FROM prompts 
                    WHERE prompt_id = ?
                """, (prompt_id,))
                
                prompt_data = cursor.fetchone()
                if not prompt_data:
                    return None
                
                # Get recent performance data
                cursor = conn.execute("""
                    SELECT execution_time, success, quality_score, timestamp
                    FROM prompt_performance 
                    WHERE prompt_id = ?
                    ORDER BY timestamp DESC
                    LIMIT 100
                """, (prompt_id,))
                
                recent_data = cursor.fetchall()
                
                return {
                    "prompt_id": prompt_id,
                    "success_rate": prompt_data[0],
                    "usage_count": prompt_data[1],
                    "avg_response_time": prompt_data[2],
                    "quality_score": prompt_data[3],
                    "created_at": prompt_data[4],
                    "updated_at": prompt_data[5],
                    "recent_performance": recent_data,
                    "trend_analysis": self.analyze_trends(recent_data)
                }
                
        except Exception as e:
            logger.error(f"Failed to generate performance report for {prompt_id}: {e}")
            return None
```

### 3. Prompt Version Control and Evolution
**MANDATORY**: Implement comprehensive version control for prompt evolution.

**Version Control Requirements**:
- **Change Tracking**: Track all prompt changes with reasons
- **Rollback Capability**: Ability to revert to previous versions
- **A/B Testing**: Compare prompt versions for performance
- **Evolution History**: Complete history of prompt changes
- **Impact Analysis**: Analyze impact of prompt changes

**Implementation**:
```python
# ✅ CORRECT: Version Control
class PromptVersionController:
    def __init__(self, db_manager: PromptDatabaseManager):
        self.db_manager = db_manager
    
    def create_version(self, prompt_id: str, new_content: str, 
                      change_reason: str, author: str = None) -> bool:
        """Create new version of prompt with change tracking"""
        try:
            with sqlite3.connect(self.db_manager.db_path) as conn:
                # Get current version
                cursor = conn.execute(
                    "SELECT version FROM prompts WHERE prompt_id = ?", 
                    (prompt_id,)
                )
                current_version = cursor.fetchone()
                
                if current_version:
                    new_version = current_version[0] + 1
                    
                    # Store in versions table
                    conn.execute("""
                        INSERT INTO prompt_versions 
                        (prompt_id, version, prompt_content, change_reason)
                        VALUES (?, ?, ?, ?)
                    """, (prompt_id, new_version, new_content, change_reason))
                    
                    # Update main prompt
                    conn.execute("""
                        UPDATE prompts 
                        SET prompt_content = ?, version = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE prompt_id = ?
                    """, (new_content, new_version, prompt_id))
                    
                    conn.commit()
                    return True
                else:
                    logger.error(f"Prompt {prompt_id} not found for versioning")
                    return False
                    
        except Exception as e:
            logger.error(f"Failed to create version for {prompt_id}: {e}")
            return False
    
    def rollback_to_version(self, prompt_id: str, target_version: int) -> bool:
        """Rollback prompt to specific version"""
        try:
            with sqlite3.connect(self.db_manager.db_path) as conn:
                # Get target version content
                cursor = conn.execute("""
                    SELECT prompt_content FROM prompt_versions 
                    WHERE prompt_id = ? AND version = ?
                """, (prompt_id, target_version))
                
                target_content = cursor.fetchone()
                if not target_content:
                    logger.error(f"Version {target_version} not found for {prompt_id}")
                    return False
                
                # Create rollback version
                self.create_version(
                    prompt_id, 
                    target_content[0], 
                    f"Rollback to version {target_version}",
                    "system"
                )
                
                return True
                
        except Exception as e:
            logger.error(f"Failed to rollback {prompt_id} to version {target_version}: {e}")
            return False
    
    def get_version_history(self, prompt_id: str) -> List[Dict]:
        """Get complete version history for prompt"""
        try:
            with sqlite3.connect(self.db_manager.db_path) as conn:
                cursor = conn.execute("""
                    SELECT version, prompt_content, change_reason, created_at
                    FROM prompt_versions 
                    WHERE prompt_id = ?
                    ORDER BY version DESC
                """, (prompt_id,))
                
                versions = []
                for row in cursor.fetchall():
                    versions.append({
                        "version": row[0],
                        "content": row[1],
                        "change_reason": row[2],
                        "created_at": row[3]
                    })
                
                return versions
                
        except Exception as e:
            logger.error(f"Failed to get version history for {prompt_id}: {e}")
            return []
```

### 4. Emergency Fallback System
**MANDATORY**: Implement emergency fallback system for database unavailability.

**Fallback Requirements**:
- **Local Cache**: Maintain local cache of critical prompts
- **Emergency Prompts**: Hardcoded fallback prompts for critical functions
- **Graceful Degradation**: System continues to function with reduced capabilities
- **Recovery Mechanism**: Automatic recovery when database becomes available

**Implementation**:
```python
# ✅ CORRECT: Emergency Fallback System
class PromptFallbackSystem:
    def __init__(self):
        self.local_cache = {}
        self.emergency_prompts = self.load_emergency_prompts()
        self.database_available = True
    
    def load_emergency_prompts(self) -> Dict[str, str]:
        """Load hardcoded emergency prompts"""
        return {
            "requirements_analyst": """
            You are a Requirements Analyst. Analyze the provided project description and extract detailed requirements.
            Focus on functional requirements, non-functional requirements, and acceptance criteria.
            """,
            "architecture_designer": """
            You are an Architecture Designer. Design system architecture based on requirements.
            Consider scalability, maintainability, and performance requirements.
            """,
            "code_generator": """
            You are a Code Generator. Generate high-quality, well-documented code based on requirements and architecture.
            Follow best practices and coding standards.
            """,
            "test_generator": """
            You are a Test Generator. Create comprehensive test suites with high coverage.
            Include unit tests, integration tests, and edge cases.
            """,
            "error_handler": """
            You are an Error Handler. Analyze errors and provide clear, actionable solutions.
            Focus on root cause analysis and prevention.
            """
        }
    
    def get_prompt(self, prompt_id: str, db_manager: PromptDatabaseManager = None) -> str:
        """Get prompt with fallback to emergency prompts"""
        # Try database first
        if self.database_available and db_manager:
            try:
                prompt_data = db_manager.get_prompt(prompt_id)
                if prompt_data:
                    # Update local cache
                    self.local_cache[prompt_id] = prompt_data["content"]
                    return prompt_data["content"]
            except Exception as e:
                logger.warning(f"Database unavailable, using fallback for {prompt_id}: {e}")
                self.database_available = False
        
        # Try local cache
        if prompt_id in self.local_cache:
            return self.local_cache[prompt_id]
        
        # Use emergency prompt
        if prompt_id in self.emergency_prompts:
            logger.warning(f"Using emergency prompt for {prompt_id}")
            return self.emergency_prompts[prompt_id]
        
        # Last resort generic prompt
        logger.error(f"No prompt found for {prompt_id}, using generic fallback")
        return f"Execute the task for {prompt_id} following best practices and standards."
    
    def update_cache(self, prompt_id: str, content: str):
        """Update local cache with new prompt content"""
        self.local_cache[prompt_id] = content
    
    def check_database_availability(self, db_manager: PromptDatabaseManager) -> bool:
        """Check if database is available and update status"""
        try:
            # Simple test query
            test_prompt = db_manager.get_prompt("test_prompt")
            self.database_available = True
            return True
        except Exception as e:
            logger.warning(f"Database unavailable: {e}")
            self.database_available = False
            return False
```

## Integration with Development Workflow

### Prompt Loading in Agents
```python
# ✅ CORRECT: Agent Prompt Loading
class AgentPromptLoader:
    def __init__(self):
        self.db_manager = PromptDatabaseManager()
        self.fallback_system = PromptFallbackSystem()
        self.performance_tracker = PromptPerformanceTracker(self.db_manager)
    
    def load_prompt(self, agent_type: str, prompt_type: str = "main") -> str:
        """Load prompt for agent with fallback support"""
        prompt_id = f"{agent_type}_{prompt_type}"
        
        # Get prompt from database or fallback
        prompt_content = self.fallback_system.get_prompt(prompt_id, self.db_manager)
        
        # Record usage
        self.performance_tracker.record_execution(prompt_id, 0.0, True)
        
        return prompt_content
    
    def update_prompt(self, agent_type: str, new_content: str, 
                     change_reason: str, prompt_type: str = "main") -> bool:
        """Update prompt with version control"""
        prompt_id = f"{agent_type}_{prompt_type}"
        
        success = self.db_manager.store_prompt(
            prompt_id, 
            "agent", 
            new_content, 
            change_reason=change_reason
        )
        
        if success:
            # Update fallback cache
            self.fallback_system.update_cache(prompt_id, new_content)
        
        return success
```

## Benefits

### Centralized Management
- **Single Source of Truth**: All prompts stored in one location
- **Version Control**: Complete history of prompt changes
- **Performance Tracking**: Continuous improvement based on metrics

### Reliability
- **Fallback System**: System continues to function even with database issues
- **Error Recovery**: Automatic recovery when database becomes available
- **Data Integrity**: Proper backup and version control

### Performance Optimization
- **Performance Metrics**: Track and optimize prompt performance
- **A/B Testing**: Compare prompt versions for effectiveness
- **Usage Analytics**: Understand prompt usage patterns

### Development Efficiency
- **Rapid Iteration**: Quick prompt updates and testing
- **Collaboration**: Team can work on prompts simultaneously
- **Quality Assurance**: Performance tracking ensures prompt quality

## Enforcement

This rule is **CRITICAL** and must be followed for all:
- Agent prompt management
- System prompt updates
- Prompt performance optimization
- Prompt version control
- Emergency fallback scenarios

**Violations of this rule require immediate remediation and prompt database restoration.**
description:
globs:
alwaysApply: true
---
