---
alwaysApply: false
autoFix: false
category: meta-type_3
contexts:
- META
dependencies:
- formal_rule_system_framework
description: System-Wide Rule Enforcement - type_3 layer rule
enforcement: blocking
formalLayer: type_3
globs:
- '**/*'
languageGames:
- enforcement_coordination
- system_governance
linguisticFramework: meta
logicalType: 3
priority: critical
tags:
- type_3
- meta
- type_3
- priority_1
- enforcement_coordination
- system_governance
tier: '1'
---

# Automatic Rule Enforcement System

**CRITICAL**: All critical rules must be automatically enforced with zero tolerance for violations. Manual compliance is unreliable - automation prevents all degradation.

## Core Enforcement Principle

**"Critical Rules Enforce Themselves"**

Every critical rule must have:
1. **Automatic Detection** - Real-time violation scanning
2. **Blocking Enforcement** - Prevents violations from persisting  
3. **Auto-Correction** - Fixes violations automatically when possible
4. **Prevention** - Stops violations before they occur

## Enforcement Classification System

### Tier 1: BLOCKING ENFORCEMENT (Critical Rules)
```yaml
enforcement_levels:
  BLOCKING:
    priority: "critical"
    alwaysApply: false
    enforcement: "blocking" 
    autoFix: true
    tolerance: "zero"
    
    # Actions on violation
    immediate_actions:
      - Block operation
      - Auto-fix if possible
      - Alert team
      - Log violation
      
    # Examples
    rules:
      - file_organization_cleanup_rule
      - no_failing_tests_rule
      - security_vulnerability_assessment_rule
      - research_first_principle
```

### Tier 2: WARNING ENFORCEMENT (Important Rules)
```yaml
  WARNING:
    priority: "high"
    alwaysApply: false
    enforcement: "warning"
    autoFix: false
    tolerance: "low"
    
    # Actions on violation  
    immediate_actions:
      - Issue warning
      - Log violation
      - Request manual fix
      - Set fix deadline
```

### Tier 3: ADVISORY ENFORCEMENT (Best Practice Rules)
```yaml
  ADVISORY:
    priority: "medium" 
    alwaysApply: false
    enforcement: "advisory"
    autoFix: false
    tolerance: "medium"
    
    # Actions on violation
    immediate_actions:
      - Log suggestion
      - Report in metrics
      - Include in code review
```

## Automatic Enforcement Mechanisms

### 1. Real-Time Violation Detection
```python
class AutomaticRuleEnforcement:
    """Self-enforcing rule system with zero tolerance for critical violations."""
    
    def __init__(self):
        self.critical_rules = load_critical_rules()
        self.enforcement_active = True
        self.auto_fix_enabled = True
        
    def enforce_rules_on_operation(self, operation: str, context: dict) -> EnforcementResult:
        """Enforce all applicable rules before allowing operation."""
        
        violations = []
        
        for rule in self.critical_rules:
            if rule.applies_to_context(context):
                violation = rule.check_violation(operation, context)
                
                if violation and rule.enforcement == "blocking":
                    # CRITICAL: Block operation immediately
                    if rule.auto_fix and self.auto_fix_enabled:
                        fix_result = rule.auto_fix_violation(violation)
                        if fix_result.success:
                            continue  # Fixed, proceed
                    
                    # Cannot fix automatically - BLOCK
                    raise CriticalRuleViolation(
                        f"BLOCKING VIOLATION: {rule.name} - {violation.description}"
                    )
                
                elif violation:
                    violations.append(violation)
        
        return EnforcementResult(
            allowed=True,
            violations=violations,
            auto_fixes_applied=len([v for v in violations if v.auto_fixed])
        )
```

### 2. File Operation Enforcement
```python
class FileOperationEnforcement:
    """Enforce file organization rules on all file operations."""
    
    def before_file_create(self, file_path: str, content: str) -> None:
        """Enforce rules before creating any file."""
        
        # Check file placement
        if not self.is_correct_location(file_path):
            correct_path = self.get_correct_location(file_path)
            raise FileOrganizationViolation(
                f"File {file_path} should be in {correct_path}"
            )
        
        # Check for empty files
        if not content.strip():
            raise EmptyFileViolation(f"Empty file creation blocked: {file_path}")
        
        # Check naming conventions
        if not self.follows_naming_convention(file_path):
            raise NamingConventionViolation(f"Invalid naming: {file_path}")
    
    def after_file_create(self, file_path: str) -> None:
        """Auto-fix and validate after file creation."""
        
        # Auto-create required companion files
        self.create_companion_files(file_path)
        
        # Validate final state
        self.validate_file_organization()
```

### 3. Git Integration Enforcement
```python
class GitEnforcementHooks:
    """Integrate rule enforcement with Git workflow."""
    
    def pre_commit_enforcement(self) -> None:
        """Block commits that violate critical rules."""
        
        violations = self.scan_all_violations()
        critical_violations = [v for v in violations if v.rule.enforcement == "blocking"]
        
        if critical_violations:
            # Auto-fix what we can
            fixed = []
            for violation in critical_violations:
                if violation.rule.auto_fix:
                    fix_result = violation.rule.auto_fix(violation)
                    if fix_result.success:
                        fixed.append(violation)
            
            # Block commit if unfixable violations remain
            remaining = [v for v in critical_violations if v not in fixed]
            if remaining:
                raise CommitBlockedError(
                    f"COMMIT BLOCKED: {len(remaining)} critical violations must be fixed"
                )
    
    def pre_push_enforcement(self) -> None:
        """Final validation before pushing to remote."""
        
        # Run comprehensive rule check
        self.comprehensive_rule_validation()
        
        # Ensure all tests pass
        if not self.all_tests_passing():
            raise PushBlockedError("PUSH BLOCKED: Tests must pass")
```

## Critical Rule Enforcement Matrix

### File Organization Rules
```yaml
file_organization:
  violations:
    root_level_examples: 
      enforcement: "blocking"
      auto_fix: "move_to_correct_location"
      
    empty_files:
      enforcement: "blocking" 
      auto_fix: "delete_immediately"
      
    wrong_test_location:
      enforcement: "blocking"
      auto_fix: "move_to_tests_folder"
      
    missing_agile_artifacts:
      enforcement: "warning"
      auto_fix: "create_basic_templates"
```

### Code Quality Rules  
```yaml
code_quality:
  violations:
    failing_tests:
      enforcement: "blocking"
      auto_fix: false
      action: "block_all_operations"
      
    security_vulnerabilities:
      enforcement: "blocking"
      auto_fix: false
      action: "immediate_alert"
      
    missing_documentation:
      enforcement: "warning"
      auto_fix: "generate_basic_docs"
```

## Implementation Strategy

### Phase 1: Core Enforcement (Immediate)
```python
# Immediate implementation priorities
CRITICAL_ENFORCEMENT_RULES = [
    "file_organization_cleanup_rule",
    "no_failing_tests_rule", 
    "research_first_principle",
    "safety_first_principle"
]

# Auto-fix capabilities
AUTO_FIX_ENABLED = [
    "file_organization_cleanup_rule",  # Move files, delete empty files
    "missing_documentation",           # Generate basic docs
    "naming_conventions"               # Rename files
]
```

### Phase 2: Git Integration (Next 24 Hours)
```bash
# Pre-commit hook implementation
#!/bin/bash
echo "🔒 CRITICAL RULE ENFORCEMENT ACTIVE"

# Run automatic rule validation
python .cursor/enforcement/validate_all_rules.py --blocking

# Auto-fix violations
python .cursor/enforcement/auto_fix_violations.py

# Block commit if critical violations remain
if [ $? -ne 0 ]; then
    echo "❌ COMMIT BLOCKED: Critical rule violations detected"
    exit 1
fi

echo "✅ All critical rules enforced - commit allowed"
```

### Phase 3: Real-Time Enforcement (Next Week)
```python
# IDE integration for real-time enforcement
class RealTimeEnforcement:
    def on_file_save(self, file_path: str) -> None:
        """Enforce rules on every file save."""
        self.enforce_critical_rules(file_path)
    
    def on_file_create(self, file_path: str) -> None:
        """Enforce rules on file creation."""
        self.validate_file_location(file_path)
    
    def on_directory_create(self, dir_path: str) -> None:
        """Enforce structure rules on directory creation."""
        self.validate_directory_structure(dir_path)
```

## Enforcement Monitoring

### Real-Time Metrics
```python
class EnforcementMetrics:
    """Track rule enforcement effectiveness."""
    
    def track_metrics(self) -> dict:
        return {
            "violations_detected_per_day": self.count_daily_violations(),
            "auto_fixes_applied": self.count_auto_fixes(),
            "blocked_operations": self.count_blocked_operations(),
            "rule_compliance_percentage": self.calculate_compliance(),
            "enforcement_response_time": self.measure_response_time()
        }
```

### Success Criteria
- **Zero Critical Violations**: No blocking rule violations persist > 1 minute
- **100% Auto-Fix Rate**: All fixable violations auto-corrected immediately  
- **99.9% Prevention Rate**: Violations prevented before they occur
- **< 1 Second Response**: Rule enforcement completes in < 1 second

## Benefits of Automatic Enforcement

### Technical Benefits
- **Zero Violation Persistence**: Critical violations cannot accumulate
- **Immediate Correction**: Problems fixed before they spread
- **Prevention Over Cure**: Stops violations before they occur
- **Consistent Standards**: No human inconsistency in application

### Process Benefits  
- **Reduced Cognitive Load**: Developers don't need to remember all rules
- **Faster Development**: No time wasted on manual compliance checking
- **Higher Quality**: Automatic enforcement ensures consistent excellence
- **Cultural Shift**: Excellence becomes automatic, not optional

## Emergency Override Protocol

### When Enforcement Must Be Temporarily Disabled
```python
class EmergencyOverride:
    """Temporary override for critical situations only."""
    
    def request_override(self, reason: str, duration: int, approver: str) -> bool:
        """Request temporary enforcement override."""
        
        if reason not in VALID_EMERGENCY_REASONS:
            return False
            
        if duration > MAX_OVERRIDE_DURATION:
            return False
            
        # Log override request
        self.log_override_request(reason, duration, approver)
        
        # Temporary disable enforcement
        self.enforcement_active = False
        
        # Schedule automatic re-enablement
        self.schedule_reenablement(duration)
        
        return True
```

## Enforcement Hierarchy

### Rule Priority Levels
1. **SAFETY** - Never allow unsafe operations
2. **SECURITY** - Block security vulnerabilities  
3. **STRUCTURAL** - Enforce file organization and architecture
4. **QUALITY** - Maintain code quality standards
5. **STYLE** - Consistent formatting and conventions

**Remember**: "Excellence through automation, not intention."

This enforcement system ensures our rules are not suggestions but guarantees of quality and consistency.