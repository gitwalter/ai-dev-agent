---
description: "Auto-generated description for no_failing_tests_rule.mdc"
category: "core-foundation"
priority: "low"
alwaysApply: true
globs: ["**/*"]
tags: ['core_foundation']
tier: "2"
---

# No Failing Tests Rule

**CRITICAL**: Zero tolerance for failing tests - all tests must pass at all times. No exceptions.

## Description
This rule establishes an absolute requirement that there are never any failing tests in the codebase. Failing tests indicate broken functionality, unreliable code, and undermine the entire development process. This rule is the foundation of reliable software development.

## Core Principles

### 1. Absolute Test Success Requirement
**MANDATORY**: Every test must pass, every time, without exception
```python
# CORRECT: All tests pass
$ pytest
# Result: 127 passed, 0 failed, 0 errors

# FORBIDDEN: Any failing tests
$ pytest
# Result: 127 passed, 1 failed, 0 errors  # ‚ùå UNACCEPTABLE
```

### 2. Immediate Failure Resolution
**MANDATORY**: Fix any failing test immediately upon detection
```python
# CORRECT: Immediate fix workflow
def handle_failing_test():
    # 1. Identify the failing test
    failing_tests = get_failing_tests()
    
    if failing_tests:
        # 2. Stop all other work immediately
        stop_current_work()
        
        # 3. Prioritize test fixing above everything else
        fix_failing_tests(failing_tests)
        
        # 4. Verify all tests pass before continuing
        verify_all_tests_pass()
        
        # 5. Only then resume normal work
        resume_work()

# FORBIDDEN: Ignoring failing tests
def ignore_failing_tests():  # ‚ùå NEVER DO THIS
    failing_tests = get_failing_tests()
    if failing_tests:
        print("I'll fix those later...")  # ‚ùå UNACCEPTABLE
        continue_working()  # ‚ùå DANGER
```

### 3. Pre-commit Test Verification
**MANDATORY**: Never commit code with failing tests
```bash
#!/bin/bash
# .git/hooks/pre-commit - No Failing Tests Enforcement

echo "üîç Verifying all tests pass before commit..."

# Run all tests
pytest_result=$(pytest --tb=short 2>&1)
exit_code=$?

if [ $exit_code -ne 0 ]; then
    echo "‚ùå COMMIT BLOCKED: Tests are failing!"
    echo "üìã Failing tests:"
    echo "$pytest_result"
    echo ""
    echo "Fix all failing tests before committing."
    exit 1
fi

echo "‚úÖ All tests pass - commit approved"
```

### 4. Continuous Integration Integration
**MANDATORY**: CI/CD pipelines must fail on any test failures
```yaml
# GitHub Actions - No Failing Tests CI/CD
name: CI Pipeline
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Run Tests
        run: pytest --tb=short
      
      - name: Fail on Test Failures
        if: failure()
        run: |
          echo "‚ùå Tests failed - pipeline stopped"
          exit 1
          
      - name: Deploy (only if tests pass)
        if: success()
        run: deploy_application
```

## Implementation Requirements

### 1. Automated Test Monitoring
**MANDATORY**: Continuous monitoring of test status
```python
class TestMonitor:
    """Continuously monitor test status and alert on failures."""
    
    def __init__(self):
        self.test_runner = pytest.main
        self.notification_system = NotificationSystem()
        self.failure_tracker = FailureTracker()
    
    def run_continuous_monitoring(self):
        """Monitor tests continuously during development."""
        
        while True:
            try:
                # Run tests periodically
                result = self.test_runner(['--tb=short'])
                
                if result != 0:  # Tests failed
                    self.handle_test_failure()
                    break  # Stop development until fixed
                    
            except Exception as e:
                self.handle_monitoring_error(e)
            
            # Check every 30 seconds during development
            time.sleep(30)
    
    def handle_test_failure(self):
        """Handle test failure immediately."""
        
        # 1. Alert all developers
        self.notification_system.alert_all_developers(
            "üö® TESTS FAILING - STOP ALL WORK",
            "All development must stop until tests pass again."
        )
        
        # 2. Track failure details
        self.failure_tracker.record_failure()
        
        # 3. Block further commits
        self.enable_commit_block()
        
        # 4. Notify team lead
        self.notify_team_lead()
```

### 2. Development Workflow Integration
**MANDATORY**: Integrate test verification into all development activities
```python
class DevelopmentWorkflow:
    """Development workflow that enforces no failing tests."""
    
    def __init__(self):
        self.test_monitor = TestMonitor()
        self.commit_blocker = CommitBlocker()
        self.progress_tracker = ProgressTracker()
    
    def start_feature_development(self, feature_name: str):
        """Start feature development with test-first approach."""
        
        # 1. Verify all tests pass before starting
        self.verify_all_tests_pass()
        
        # 2. Create feature branch
        self.create_feature_branch(feature_name)
        
        # 3. Start with failing test (TDD)
        self.write_failing_test_first()
        
        # 4. Implement feature to make test pass
        self.implement_feature_until_tests_pass()
        
        # 5. Continue development cycle
        self.continue_tdd_cycle()
    
    def verify_all_tests_pass(self):
        """Verify all tests pass before any development activity."""
        
        result = subprocess.run(['pytest', '--tb=short'], 
                              capture_output=True, text=True)
        
        if result.returncode != 0:
            raise ValueError(f"Cannot start development - tests are failing:\n{result.stdout}")
    
    def write_failing_test_first(self):
        """Write failing test first (TDD principle)."""
        
        # This creates a failing test that must be fixed immediately
        self.create_failing_test()
        
        # Verify the test fails as expected
        self.verify_test_fails_as_expected()
    
    def implement_feature_until_tests_pass(self):
        """Implement feature until all tests pass."""
        
        while True:
            # Run tests
            if self.all_tests_pass():
                break  # Success!
            
            # If tests fail, implement more code
            self.implement_more_code()
            
            # Never commit with failing tests
            if not self.all_tests_pass():
                continue  # Keep working until tests pass
```

### 3. Team Communication Integration
**MANDATORY**: Notify team of test failures immediately
```python
class TeamCommunication:
    """Communicate test failures to the entire team."""
    
    def alert_team_of_failing_tests(self, failing_tests: List[TestResult]):
        """Alert entire team when tests start failing."""
        
        message = self.format_failure_alert(failing_tests)
        
        # Send to multiple channels
        self.send_slack_alert(message)
        self.send_email_alert(message)
        self.send_teams_alert(message)
        
        # Update dashboard
        self.update_team_dashboard(failing_tests)
        
        # Block deployments
        self.block_deployments_until_fixed()
    
    def format_failure_alert(self, failing_tests: List[TestResult]) -> str:
        """Format test failure alert for team communication."""
        
        num_failures = len(failing_tests)
        critical_failures = len([t for t in failing_tests if t.is_critical])
        
        message = f"""
üö® **TESTS FAILING - IMMEDIATE ATTENTION REQUIRED**

**Failure Summary:**
- Total failing tests: {num_failures}
- Critical failures: {critical_failures}

**Impact:**
- All development work must stop
- No commits allowed until fixed
- Deployment pipeline blocked
- Production deployments suspended

**Required Action:**
1. Stop all current work immediately
2. Focus entire team on fixing failing tests
3. No new features until all tests pass
4. Communicate fix timeline to stakeholders

**Next Steps:**
- Assign team members to fix specific failures
- Set up war room for collaborative fixing
- Update stakeholders on progress
- Resume normal work only after all tests pass
"""
        
        return message
```

## Prevention Mechanisms

### 1. Commit Blocking
**MANDATORY**: Prevent commits when tests are failing
```python
class CommitBlocker:
    """Block commits when tests are failing."""
    
    def __init__(self):
        self.git_hooks_path = ".git/hooks"
        self.pre_commit_hook = f"{self.git_hooks_path}/pre-commit"
    
    def install_commit_blocker(self):
        """Install pre-commit hook to block failing tests."""
        
        hook_content = '''#!/bin/bash
# Block commits with failing tests

echo "üîç Checking for failing tests..."

# Run tests
if ! pytest --tb=short; then
    echo "‚ùå COMMIT BLOCKED: Tests are failing!"
    echo ""
    echo "You must fix all failing tests before committing."
    echo "Run 'pytest' to see which tests are failing."
    exit 1
fi

echo "‚úÖ All tests pass - commit allowed"
'''
        
        # Write the hook
        with open(self.pre_commit_hook, 'w') as f:
            f.write(hook_content)
        
        # Make it executable
        os.chmod(self.pre_commit_hook, 0o755)
    
    def is_commit_blocked(self) -> bool:
        """Check if commits should be blocked."""
        
        # Check if tests are currently failing
        result = subprocess.run(['pytest', '--tb=short'], 
                              capture_output=True)
        
        return result.returncode != 0
```

### 2. IDE Integration
**MANDATORY**: Integrate test monitoring into development IDE
```json
// VS Code settings for no failing tests
{
    "python.testing.pytestEnabled": true,
    "python.testing.pytestArgs": [
        "--tb=short"
    ],
    "python.linting.enabled": true,
    "git.autofetch": true,
    "git.confirmSync": false,
    
    // Custom settings for no failing tests rule
    "noFailingTests": {
        "blockCommits": true,
        "continuousMonitoring": true,
        "teamNotifications": true,
        "dashboardUpdates": true
    },
    
    // Tasks to run on file save
    "tasks": {
        "version": "2.0.0",
        "tasks": [
            {
                "label": "Run Tests on Save",
                "type": "shell",
                "command": "pytest",
                "group": "test",
                "runOptions": {
                    "runOn": "folderOpen"
                }
            }
        ]
    }
}
```

## Success Metrics

### Test Health Metrics
**MANDATORY**: Track and monitor test health continuously
```python
class TestHealthMetrics:
    """Monitor and report on test health metrics."""
    
    def get_current_health_score(self) -> float:
        """Calculate current test health score (0.0 to 1.0)."""
        
        metrics = self.collect_test_metrics()
        
        # Perfect score requires:
        # - All tests passing (weight: 0.5)
        # - No skipped tests (weight: 0.2)
        # - Good test coverage (weight: 0.2)
        # - Fast execution (weight: 0.1)
        
        score = (
            metrics['pass_rate'] * 0.5 +
            metrics['no_skipped'] * 0.2 +
            metrics['coverage_score'] * 0.2 +
            metrics['performance_score'] * 0.1
        )
        
        return score
    
    def collect_test_metrics(self) -> Dict[str, float]:
        """Collect comprehensive test metrics."""
        
        # Run tests and collect results
        result = subprocess.run(['pytest', '--tb=short', '--cov=src'],
                              capture_output=True, text=True)
        
        # Parse results
        metrics = {
            'pass_rate': self.calculate_pass_rate(result),
            'no_skipped': 1.0 if 'skipped' not in result.stdout.lower() else 0.0,
            'coverage_score': self.get_coverage_score(),
            'performance_score': self.calculate_performance_score(result)
        }
        
        return metrics
    
    def report_health_status(self):
        """Report current test health status."""
        
        score = self.get_current_health_score()
        
        if score >= 0.95:
            status = "üü¢ EXCELLENT"
            message = "All tests passing, excellent health"
        elif score >= 0.85:
            status = "üü° GOOD"
            message = "Minor issues, but generally healthy"
        elif score >= 0.70:
            status = "üü† FAIR"
            message = "Some issues requiring attention"
        else:
            status = "üî¥ CRITICAL"
            message = "Major test health issues - immediate action required"
        
        return {
            'status': status,
            'score': score,
            'message': message,
            'recommendations': self.get_health_recommendations(score)
        }
```

## Implementation Guidelines

### Development Workflow with No Failing Tests
```python
# CORRECT: No failing tests workflow
def development_cycle():
    """Complete development cycle with zero failing tests."""
    
    while True:
        # 1. Verify all tests pass before starting
        assert all_tests_pass(), "Cannot start with failing tests"
        
        # 2. Work on next task
        task = get_next_task()
        work_on_task(task)
        
        # 3. Run tests frequently during development
        run_tests()
        
        # 4. Fix any failing tests immediately
        while not all_tests_pass():
            fix_failing_tests()
            run_tests()
        
        # 5. Only commit when all tests pass
        if all_tests_pass():
            commit_changes()
            continue_to_next_task()
        
        # 6. Never proceed with failing tests
        else:
            raise Exception("Fix all tests before continuing")

# FORBIDDEN: Working with failing tests
def broken_development_cycle():  # ‚ùå NEVER DO THIS
    work_on_task()
    run_tests()  # Tests fail
    print("I'll fix those later...")  # ‚ùå UNACCEPTABLE
    commit_changes()  # ‚ùå NEVER COMMIT WITH FAILING TESTS
    continue_to_next_task()  # ‚ùå DANGER
```

### Team Standards
**MANDATORY**: Establish team-wide standards for test management
```python
class TeamStandards:
    """Establish team standards for no failing tests."""
    
    ZERO_TOLERANCE_POLICY = """
    **ZERO FAILING TESTS POLICY**
    
    1. **Never commit with failing tests**
    2. **Never deploy with failing tests**  
    3. **Never ignore failing tests**
    4. **Always fix failing tests immediately**
    5. **Always run tests before any change**
    6. **Always verify all tests pass after any change**
    
    **Violations of this policy will result in:**
    - Immediate stop-work order
    - Mandatory test fixing session
    - Escalation to team lead
    - Potential process review
    
    **Rewards for compliance:**
    - Reliable software delivery
    - High team confidence
    - Faster development cycles
    - Better code quality
    """
    
    def enforce_team_standards(self):
        """Enforce team standards for test management."""
        
        # 1. Regular policy reminders
        self.send_policy_reminders()
        
        # 2. Monitor compliance
        self.monitor_compliance()
        
        # 3. Provide training
        self.provide_test_training()
        
        # 4. Celebrate success
        self.celebrate_test_success()
```

## Benefits

### Immediate Benefits
- **Reliable Codebase**: Always know when code is working
- **Fast Feedback**: Immediate detection of issues
- **High Confidence**: Safe refactoring and changes
- **Team Coordination**: Clear signal when work is ready

### Long-term Benefits
- **Quality Assurance**: Consistent code quality
- **Development Speed**: Faster iteration cycles
- **Team Productivity**: Less time debugging, more time building
- **Customer Satisfaction**: More reliable software delivery

## Enforcement

This rule is **ALWAYS ENFORCED** and has **ZERO TOLERANCE** for violations:
- Pre-commit hooks prevent commits with failing tests
- CI/CD pipelines fail on test failures
- IDE integrations provide real-time feedback
- Team communication ensures immediate awareness
- Development workflows are designed around this principle

**There are no exceptions to this rule. Failing tests must be fixed immediately.**

## Success Criteria

- **100% test pass rate** at all times
- **Zero test failures** in CI/CD pipelines
- **Immediate test failure resolution** (< 5 minutes)
- **All commits pass tests** without exception
- **All deployments require test success**
- **Team culture of test-first development**

## Remember

**"Red means stop, green means go."**

**"Failing tests are broken windows - fix them immediately."**

**"Quality is everyone's responsibility, starting with tests."**

**"Never let failing tests become normal - they indicate problems that must be fixed."**