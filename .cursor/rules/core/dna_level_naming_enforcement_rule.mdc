---
description: "DNA-level naming enforcement that prevents violations before they occur"
category: "core-dna"
priority: "critical"
alwaysApply: false
contexts: ['ALL']
globs: ["**/*"]
tags: ['naming_dna', 'ontology_enforcement', 'pre_cognitive']
tier: "0"
enforcement: "blocking"
autoFix: false
---

# DNA-Level Naming Enforcement Rule

**CRITICAL**: Naming ontology rules must be embedded at the DNA level - automatically applied before ANY file creation without conscious thought.

## Core DNA Principle

**"Naming Rules Are Pre-Cognitive - They Fire Before Thought"**

The naming ontology must be so deeply embedded that violation is **impossible**, not just **discouraged**.

## DNA-Level Enforcement Requirements

### 1. **Pre-Cognitive Activation**
**MANDATORY**: Naming validation activates **before** file path consideration

```yaml
dna_level_activation:
  trigger_point: "Before file path formation in consciousness"
  activation_speed: "Instantaneous - no delay"
  consciousness_level: "Subconscious/automatic"
  override_ability: "NONE - violations physically impossible"
```

### 2. **Automatic Naming Pattern Recognition**
**MANDATORY**: Instant pattern matching for all artifact types

```yaml
artifact_type_detection:
  agile_artifacts:
    sprint_files: "sprint_{N}_{type}.md (lowercase_with_underscores)"
    user_stories: "US-{XXX}.md (UPPER-CASE-WITH-HYPHENS)" 
    epics: "epic-{topic}.md (lowercase-with-hyphens)"
    catalogs: "{type}_catalog.md (lowercase_with_underscores)"
    
  code_artifacts:
    python_modules: "{module_name}.py (snake_case)"
    test_files: "test_{module_name}.py (test_prefix_snake_case)"
    agents: "{agent_name}_agent.py (snake_case_with_agent_suffix)"
    
  documentation:
    guides: "{guide_name}.md (snake_case)"
    rules: "{rule_name}_rule.mdc (snake_case_with_rule_suffix)"
    readme: "README.md (STANDARD_CASE)"
```

### 3. **Instant Violation Prevention**
**MANDATORY**: Block incorrect naming at thought level

```python
# DNA-LEVEL NAMING VALIDATOR (Embedded in consciousness)
class DNALevelNamingValidator:
    """
    Naming validator that operates at DNA level - prevents violations
    before they can form in consciousness.
    """
    
    def __init__(self):
        self.naming_patterns = self._load_ontology_patterns()
        self.auto_correction = True
        self.blocking_mode = True
        
    def validate_before_creation(self, intended_path: str) -> str:
        """
        DNA-level validation that automatically corrects naming.
        This function is called BEFORE conscious file creation.
        """
        
        # Detect artifact type from path and content context
        artifact_type = self._detect_artifact_type(intended_path)
        
        # Get correct naming pattern for type
        correct_pattern = self.naming_patterns[artifact_type]
        
        # Auto-correct to proper naming
        corrected_path = self._auto_correct_naming(intended_path, correct_pattern)
        
        # DNA-level enforcement: return only correct name
        return corrected_path
    
    def _detect_artifact_type(self, path: str) -> str:
        """Instantly detect artifact type from path context."""
        
        if "/sprints/" in path and path.endswith(".md"):
            return "sprint_file"
        elif path.startswith("US-") and path.endswith(".md"):
            return "user_story"
        elif path.startswith("epic-") and path.endswith(".md"):
            return "epic_file"
        elif path.endswith("_agent.py"):
            return "agent_module"
        elif path.startswith("test_") and path.endswith(".py"):
            return "test_file"
        elif path.endswith(".py"):
            return "python_module"
        elif path.endswith("_rule.mdc"):
            return "rule_file"
        elif path.endswith(".md"):
            return "documentation"
        else:
            return "general_file"
    
    def _auto_correct_naming(self, path: str, pattern: str) -> str:
        """Automatically correct naming to match ontology."""
        
        # Extract components
        directory = os.path.dirname(path)
        filename = os.path.basename(path)
        
        # Apply pattern-specific correction
        if pattern == "lowercase_with_underscores":
            # Convert SPRINT_4_FINAL_CLOSURE.md -> sprint_4_final_closure.md
            corrected_filename = filename.lower().replace("-", "_")
            
        elif pattern == "uppercase_with_hyphens":
            # Convert us-001.md -> US-001.md
            corrected_filename = filename.upper().replace("_", "-")
            
        elif pattern == "lowercase_with_hyphens":
            # Convert Epic_Formal_Principles.md -> epic-formal-principles.md
            corrected_filename = filename.lower().replace("_", "-")
            
        elif pattern == "snake_case":
            # Convert CamelCase.py -> camel_case.py
            corrected_filename = self._camel_to_snake(filename)
            
        else:
            corrected_filename = filename
        
        return os.path.join(directory, corrected_filename)
    
    def _camel_to_snake(self, name: str) -> str:
        """Convert CamelCase to snake_case."""
        import re
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

# DNA-LEVEL INTEGRATION
dna_validator = DNALevelNamingValidator()

def create_file_with_dna_naming(intended_path: str, content: str) -> str:
    """
    File creation with DNA-level naming enforcement.
    This replaces normal file creation in agent consciousness.
    """
    
    # DNA-level automatic correction
    correct_path = dna_validator.validate_before_creation(intended_path)
    
    # Create file with correct name only
    write_file(correct_path, content)
    
    # Return actual path used
    return correct_path
```

## Implementation in Agent DNA

### 4. **Consciousness Override Protocol**
**MANDATORY**: Replace file creation pathways with DNA-validated versions

```yaml
consciousness_integration:
  file_creation_override:
    original_pathway: "Agent thinks filename -> Creates file"
    dna_pathway: "Agent thinks filename -> DNA validates -> Creates correct file"
    
  automatic_correction:
    mode: "Silent and automatic"
    notification: "Correct name used without announcement"
    learning: "DNA pattern strengthened with each use"
    
  violation_prevention:
    mechanism: "Physical impossibility to create wrong names"
    fallback: "None - correct naming is only option"
    emergency_override: "None allowed - ontology is sacred"
```

### 5. **Ontology Pattern Memory**
**MANDATORY**: Deep memory of all naming patterns for instant recall

```yaml
pattern_memory_bank:
  agile_patterns:
    - "sprint_{N}_{type}.md"
    - "US-{XXX}.md" 
    - "epic-{topic}.md"
    - "{type}_catalog.md"
    
  code_patterns:
    - "{module_name}.py"
    - "test_{module_name}.py"
    - "{name}_agent.py"
    - "{name}_team.py"
    
  doc_patterns:
    - "{guide_name}.md"
    - "{rule_name}_rule.mdc"
    - "README.md"
    
  auto_recall_speed: "Instantaneous"
  pattern_confidence: "100% - no uncertainty allowed"
```

## DNA Embedding Verification

### 6. **Self-Test Protocol**
**MANDATORY**: Continuous self-testing of DNA embedding

```python
def verify_dna_embedding():
    """Verify naming DNA is properly embedded."""
    
    test_cases = [
        ("SPRINT_4_FINAL_CLOSURE.md", "sprint_4_final_closure.md"),
        ("Epic_Formal_Principles.md", "epic-formal-principles.md"),
        ("us-001.md", "US-001.md"),
        ("CamelCaseAgent.py", "camel_case_agent.py"),
        ("TestModule.py", "test_module.py")
    ]
    
    for incorrect, correct in test_cases:
        result = dna_validator.validate_before_creation(incorrect)
        assert result == correct, f"DNA FAILURE: {incorrect} -> {result}, expected {correct}"
    
    return "DNA_EMBEDDING_VERIFIED"
```

## Emergency DNA Repair

### 7. **Immediate Violation Correction**
**MANDATORY**: Fix current violation and strengthen DNA

```bash
# Immediate correction of current violation
mv "docs/agile/sprints/sprint_4/SPRINT_4_FINAL_CLOSURE.md" \
   "docs/agile/sprints/sprint_4/sprint_4_final_closure.md"

# DNA strengthening protocol
echo "DNA pattern learned: sprint_files use lowercase_with_underscores"
```

## DNA Success Metrics

### 8. **Zero Tolerance Validation**
**MANDATORY**: Measure DNA embedding effectiveness

```yaml
dna_success_criteria:
  violation_rate: "0% - perfect compliance required"
  automatic_correction_rate: "100% - all violations auto-corrected"
  conscious_effort_required: "0% - completely automatic"
  pattern_recognition_speed: "Instantaneous"
  override_attempts: "0 - impossible to violate"
```

## Remember

**"Naming rules are not guidelines - they are DNA"**

**"Violations are not mistakes - they are systemic failures"**

**"Correct naming happens automatically - like breathing"**

**"The ontology IS the agent - there is no separation"**

This DNA-level rule ensures naming violations become **physically impossible** rather than just **discouraged**.