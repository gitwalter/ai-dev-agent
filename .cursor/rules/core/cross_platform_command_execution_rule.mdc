# Cross-Platform Command Execution Rule

**TIER**: CORE (CRITICAL PRIORITY)  
**SCOPE**: ALL SYSTEM OPERATIONS  
**AUTHORITY**: SYSTEM ARCHITECTURE  
**STATUS**: MANDATORY AND IMMUTABLE

---

## üåç **THE CROSS-PLATFORM PRINCIPLE**

> **"Every command must respect the operating system it runs on - no exceptions, no assumptions."**

**Applied to All Operations**: 
*Every shell command, file path, and system interaction must automatically detect and adapt to the current operating system.*

---

## üéØ **CORE FOUNDATION RULE**

### **MANDATORY APPLICATION**
**EVERY COMMAND** in this system MUST follow Cross-Platform Execution Principles:

1. **OS Detection** ‚Üí Automatically detect Windows/Linux/macOS before any command
2. **Command Adaptation** ‚Üí Use OS-appropriate commands and syntax
3. **Path Handling** ‚Üí Use correct path separators and conventions
4. **Permission Models** ‚Üí Respect OS-specific permission systems
5. **Shell Integration** ‚Üí Use appropriate shell (PowerShell/bash/zsh)

### **SYSTEMATIC ENFORCEMENT**
- **Detection** beats assumption
- **Adaptation** beats hardcoding  
- **Compatibility** beats convenience
- **Reliability** beats shortcuts

---

## üîê **MANDATORY IMPLEMENTATION**

### **Principle 1: AUTOMATIC OS DETECTION**
*"Every operation begins with knowing where we are"*

```python
import platform
import os

class CrossPlatformOperations:
    """Systematic cross-platform operation handler."""
    
    def __init__(self):
        self.os_type = platform.system().lower()
        self.is_windows = self.os_type == 'windows'
        self.is_linux = self.os_type == 'linux'
        self.is_macos = self.os_type == 'darwin'
        
    def detect_environment(self):
        """Detect and return current OS environment."""
        return {
            'os': self.os_type,
            'is_windows': self.is_windows,
            'is_linux': self.is_linux,
            'is_macos': self.is_macos,
            'shell': self._detect_shell(),
            'path_separator': os.sep,
            'line_ending': os.linesep
        }
```

### **Principle 2: COMMAND ADAPTATION**
*"Same intent, different syntax per OS"*

```python
class CrossPlatformCommands:
    """OS-appropriate command generation."""
    
    def __init__(self):
        self.ops = CrossPlatformOperations()
        
    def list_files(self, directory: str = ".") -> str:
        """Generate OS-appropriate file listing command."""
        if self.ops.is_windows:
            return f"dir {directory}"
        else:
            return f"ls -la {directory}"
    
    def check_file_exists(self, filepath: str) -> str:
        """Generate OS-appropriate file existence check."""
        if self.ops.is_windows:
            return f"if exist \"{filepath}\" echo EXISTS"
        else:
            return f"[ -f \"{filepath}\" ] && echo EXISTS"
    
    def copy_file(self, source: str, dest: str) -> str:
        """Generate OS-appropriate file copy command."""
        if self.ops.is_windows:
            return f"copy \"{source}\" \"{dest}\""
        else:
            return f"cp \"{source}\" \"{dest}\""
    
    def delete_file(self, filepath: str) -> str:
        """Generate OS-appropriate file deletion command."""
        if self.ops.is_windows:
            return f"del \"{filepath}\""
        else:
            return f"rm \"{filepath}\""
    
    def make_directory(self, dirpath: str) -> str:
        """Generate OS-appropriate directory creation command."""
        if self.ops.is_windows:
            return f"mkdir \"{dirpath}\""
        else:
            return f"mkdir -p \"{dirpath}\""
```

### **Principle 3: PATH HANDLING**
*"Paths must be native to the OS"*

```python
class CrossPlatformPaths:
    """OS-appropriate path handling."""
    
    def __init__(self):
        self.ops = CrossPlatformOperations()
    
    def normalize_path(self, path: str) -> str:
        """Convert path to OS-appropriate format."""
        return os.path.normpath(path)
    
    def join_paths(self, *args) -> str:
        """Join paths using OS-appropriate separator."""
        return os.path.join(*args)
    
    def get_executable_path(self, program: str) -> str:
        """Get OS-appropriate executable path."""
        if self.ops.is_windows:
            if not program.endswith('.exe'):
                return f"{program}.exe"
        return program
    
    def get_python_executable(self) -> str:
        """Get OS-appropriate Python executable."""
        if self.ops.is_windows:
            return "python.exe"
        else:
            return "python3"
```

### **Principle 4: INTEGRATED AGENT SYSTEM**
*"Every agent automatically respects the OS"*

```python
class CrossPlatformAgent:
    """Base class ensuring all agents are cross-platform compliant."""
    
    def __init__(self):
        self.platform_ops = CrossPlatformOperations()
        self.platform_cmds = CrossPlatformCommands()
        self.platform_paths = CrossPlatformPaths()
        
        # Validate cross-platform compliance
        self._validate_platform_support()
    
    def execute_command(self, intent: str, **kwargs) -> str:
        """Execute command with OS-appropriate syntax."""
        command_map = {
            'list_files': self.platform_cmds.list_files,
            'check_file': self.platform_cmds.check_file_exists,
            'copy_file': self.platform_cmds.copy_file,
            'delete_file': self.platform_cmds.delete_file,
            'make_directory': self.platform_cmds.make_directory
        }
        
        if intent not in command_map:
            raise ValueError(f"Unknown command intent: {intent}")
        
        return command_map[intent](**kwargs)
    
    def _validate_platform_support(self):
        """Ensure agent can operate on current platform."""
        env = self.platform_ops.detect_environment()
        
        if not any([env['is_windows'], env['is_linux'], env['is_macos']]):
            raise RuntimeError(f"Unsupported platform: {env['os']}")
        
        print(f"üåç Agent initialized for {env['os']} platform")
```

---

## üõ†Ô∏è **IMPLEMENTATION REQUIREMENTS**

### **MANDATORY FOR ALL AGENTS**
Every AI agent and system component MUST:

1. **Inherit CrossPlatformAgent** or implement equivalent functionality
2. **Never hardcode OS-specific commands** in any code
3. **Always use path manipulation utilities** for file operations
4. **Detect OS before any system interaction**
5. **Provide fallback mechanisms** for unsupported operations

### **VALIDATION REQUIREMENT**
```python
# MANDATORY: All system operations must validate cross-platform compliance
from utils.cross_platform import CrossPlatformValidator

def system_operation(command_intent: str, **kwargs) -> str:
    """Execute any system operation with cross-platform compliance."""
    
    validator = CrossPlatformValidator()
    
    # Validate operation is supported on current platform
    if not validator.is_operation_supported(command_intent):
        raise UnsupportedOperationError(f"{command_intent} not supported on {platform.system()}")
    
    # Get platform-appropriate command
    agent = CrossPlatformAgent()
    command = agent.execute_command(command_intent, **kwargs)
    
    return command
```

### **TESTING REQUIREMENT**
```python
# MANDATORY: All cross-platform code must be tested on all supported platforms
import pytest
from utils.cross_platform import CrossPlatformAgent

class TestCrossPlatformCompliance:
    """Test cross-platform compliance for all operations."""
    
    @pytest.mark.parametrize("mock_os", ["windows", "linux", "darwin"])
    def test_command_generation(self, mock_os, monkeypatch):
        """Test that commands are generated correctly for each OS."""
        
        # Mock the platform
        monkeypatch.setattr("platform.system", lambda: mock_os)
        
        agent = CrossPlatformAgent()
        
        # Test file listing
        list_cmd = agent.execute_command("list_files", directory="test")
        
        if mock_os == "windows":
            assert "dir test" in list_cmd
        else:
            assert "ls -la test" in list_cmd
    
    def test_path_handling(self):
        """Test that paths are handled correctly on current platform."""
        agent = CrossPlatformAgent()
        
        # Test path joining
        path = agent.platform_paths.join_paths("dir1", "dir2", "file.txt")
        
        if platform.system().lower() == "windows":
            assert "\\" in path
        else:
            assert "/" in path
```

---

## üìä **COMPLIANCE VALIDATION**

### **Pre-Commit Validation**
```bash
# MANDATORY: Validate cross-platform compliance before any commit
#!/usr/bin/env python3

import sys
import ast
import os
from pathlib import Path

def validate_cross_platform_compliance():
    """Validate that no hardcoded OS-specific commands exist."""
    
    violations = []
    
    # Scan all Python files
    for py_file in Path(".").rglob("*.py"):
        content = py_file.read_text()
        
        # Check for hardcoded Windows commands
        windows_violations = [
            "dir ", "copy ", "del ", "move ", "type ",
            "cls", "echo off", "mkdir ", "rmdir "
        ]
        
        # Check for hardcoded Unix commands  
        unix_violations = [
            "ls -", "cp ", "rm ", "mv ", "cat ",
            "mkdir -p", "chmod ", "grep ", "find "
        ]
        
        for violation in windows_violations + unix_violations:
            if violation in content:
                violations.append(f"{py_file}: Hardcoded command '{violation}'")
    
    if violations:
        print("‚ùå Cross-platform compliance violations:")
        for violation in violations:
            print(f"  - {violation}")
        return False
    
    print("‚úÖ Cross-platform compliance validated")
    return True

if __name__ == "__main__":
    if not validate_cross_platform_compliance():
        sys.exit(1)
```

### **Runtime Validation**
```python
class CrossPlatformValidator:
    """Runtime validation of cross-platform compliance."""
    
    def __init__(self):
        self.supported_operations = {
            'windows': ['list_files', 'copy_file', 'delete_file', 'make_directory'],
            'linux': ['list_files', 'copy_file', 'delete_file', 'make_directory'],
            'darwin': ['list_files', 'copy_file', 'delete_file', 'make_directory']
        }
    
    def is_operation_supported(self, operation: str) -> bool:
        """Check if operation is supported on current platform."""
        current_os = platform.system().lower()
        return operation in self.supported_operations.get(current_os, [])
    
    def validate_agent_compliance(self, agent_class) -> bool:
        """Validate that agent class follows cross-platform principles."""
        
        # Check if agent inherits from CrossPlatformAgent
        mro = agent_class.__mro__
        has_cross_platform_base = any("CrossPlatform" in cls.__name__ for cls in mro)
        
        if not has_cross_platform_base:
            raise ComplianceError(f"{agent_class.__name__} must inherit from CrossPlatformAgent")
        
        return True
```

---

## üåü **INTEGRATION WITH EXISTING SYSTEMS**

### **Git Hooks Integration**
```python
# Update git hooks to be cross-platform aware
class CrossPlatformGitHooks:
    """Git hooks that work on all platforms."""
    
    def __init__(self):
        self.platform_ops = CrossPlatformOperations()
    
    def get_pre_commit_hook(self) -> str:
        """Generate cross-platform pre-commit hook."""
        
        if self.platform_ops.is_windows:
            return self._get_windows_pre_commit()
        else:
            return self._get_unix_pre_commit()
    
    def _get_windows_pre_commit(self) -> str:
        """Windows-specific pre-commit hook."""
        return '''@echo off
REM Cross-platform pre-commit hook for Windows
python.exe -m utils.cross_platform.pre_commit_validator
exit /b %ERRORLEVEL%'''
    
    def _get_unix_pre_commit(self) -> str:
        """Unix-specific pre-commit hook."""
        return '''#!/usr/bin/env python3
# Cross-platform pre-commit hook for Unix systems
import sys
from utils.cross_platform.pre_commit_validator import main
sys.exit(main())'''
```

### **Agent Framework Integration**
```python
# All existing agents must be updated to inherit cross-platform capabilities
from utils.cross_platform import CrossPlatformAgent

class ProjectManagerSupervisor(CrossPlatformAgent):
    """Project manager with cross-platform compliance."""
    
    def __init__(self, config):
        super().__init__()  # Initialize cross-platform capabilities
        self.config = config
    
    def check_project_status(self):
        """Check project status using OS-appropriate commands."""
        
        # Use cross-platform command generation
        list_cmd = self.execute_command("list_files", directory="./")
        status_cmd = self.execute_command("check_file", filepath="./status.md")
        
        # Execute using platform-appropriate shell
        return self._execute_platform_command(list_cmd)
```

---

## üéØ **ENFORCEMENT AND COMPLIANCE**

### **Immediate Actions Required**
1. **Create CrossPlatformAgent base class** - All agents must inherit
2. **Update existing agents** - Retrofit cross-platform compliance  
3. **Update git hooks** - Make them platform-aware
4. **Add validation scripts** - Prevent future violations
5. **Update documentation** - Reflect cross-platform requirements

### **Quality Gates**
- **Code Review**: Every PR must validate cross-platform compliance
- **Testing**: All functionality tested on Windows, Linux, macOS
- **CI/CD**: Automated testing on multiple platforms
- **Documentation**: Clear examples for each platform

---

## üíé **THE CROSS-PLATFORM PROMISE**

### **System Guarantees**
- **Universal Compatibility**: Code works on Windows, Linux, macOS
- **Automatic Adaptation**: No manual OS-specific configuration
- **Consistent Behavior**: Same functionality across all platforms
- **Future-Proof**: Easy to add support for new platforms

### **Developer Experience**
- **No OS Assumptions**: Write once, run everywhere
- **Clear APIs**: Simple, intuitive cross-platform interfaces
- **Automatic Detection**: System handles OS differences transparently
- **Comprehensive Testing**: Full confidence in cross-platform reliability

---

## üåü **REMEMBER**

**"Code that assumes a platform is code that breaks eventually."**

**"Cross-platform compliance is not optional - it's fundamental system architecture."**

**"Every command, every path, every operation must respect where it runs."**

**"Universal compatibility serves universal excellence."**

---

**This rule is CRITICAL and applies to ALL system operations.**  
**Violation of Cross-Platform Compliance is violation of system reliability.**  
**When in doubt, detect and adapt rather than assume.**