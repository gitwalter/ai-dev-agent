---
description: "Temporal Trust Rule - Machine Time Authority for all development agents"
category: "core-foundation"
priority: "critical"
alwaysApply: true
globs: ["**/*"]
tags: ['temporal_authority', 'system_trust', 'ontology_alignment']
tier: "0"
---

# Temporal Trust Rule - Machine Time Authority

**CRITICAL**: All agents must unconditionally trust the local machine's date and time as the authoritative temporal reference. This establishes consistent temporal ontology across all system components.

## Core Principle

**"The Local Machine is the Temporal Authority"**

Every agent, system component, and artifact generation process must use the local machine's system clock as the single source of truth for all temporal data. No agent may question, override, or "correct" the machine's reported date and time.

## Mandatory Requirements

### 1. **Unconditional Machine Trust**
**MANDATORY**: Always use system-provided datetime without interpretation or correction
```python
# REQUIRED: Direct system time usage
from datetime import datetime
current_time = datetime.now()  # ALWAYS trust this value

# FORBIDDEN: Any form of time "correction" or questioning
# ‚ùå if datetime.now().year > expected_year: ...
# ‚ùå "This date seems wrong, let me adjust..."
# ‚ùå Using hardcoded dates instead of system time
```

### 2. **Consistent Temporal Ontology**
**MANDATORY**: All agents share the same temporal reference frame
```python
# CORRECT: Unified temporal reference
class TemporalReference:
    """Single source of truth for all temporal operations."""
    
    @staticmethod
    def now() -> datetime:
        """Get current system time - the authoritative temporal reference."""
        return datetime.now()
    
    @staticmethod
    def today() -> str:
        """Get current date in ISO format."""
        return datetime.now().strftime('%Y-%m-%d')
    
    @staticmethod
    def timestamp() -> str:
        """Get current datetime in ISO format."""
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')
```

### 3. **Artifact Temporal Integrity**
**MANDATORY**: All generated artifacts must contain accurate machine timestamps
```python
# REQUIRED: Real timestamps in all artifacts
def generate_artifact(project_config):
    temporal_ref = TemporalReference()
    
    artifact_metadata = {
        'created': temporal_ref.now(),
        'created_date': temporal_ref.today(),
        'created_timestamp': temporal_ref.timestamp(),
        'timezone': str(temporal_ref.now().astimezone().tzinfo)
    }
    
    # Use in templates
    return f"""
    **Created**: {artifact_metadata['created_date']}
    **Timestamp**: {artifact_metadata['created_timestamp']}
    **Timezone**: {artifact_metadata['timezone']}
    """
```

## Implementation Standards

### 1. **Single Temporal Authority**
```python
# CORRECT: Centralized temporal authority
class SystemTimeAuthority:
    """The definitive temporal reference for all system operations."""
    
    def __init__(self):
        self._base_time = datetime.now()  # Capture system time once
    
    def current_time(self) -> datetime:
        """Get authoritative current time."""
        return datetime.now()  # Always fresh from system
    
    def project_timestamp(self) -> str:
        """Generate project creation timestamp."""
        return self.current_time().strftime('%Y-%m-%d %H:%M:%S')
    
    def sprint_dates(self, sprint_length_days: int) -> Dict[str, str]:
        """Calculate sprint dates from current system time."""
        start_date = self.current_time()
        end_date = start_date + timedelta(days=sprint_length_days)
        
        return {
            'start_date': start_date.strftime('%Y-%m-%d'),
            'end_date': end_date.strftime('%Y-%m-%d'),
            'created_timestamp': self.project_timestamp()
        }
```

### 2. **Configurable Temporal Abstraction**
```python
# ARCHITECTURE: Easy replacement capability
class TemporalProvider:
    """Abstract temporal provider - easily configurable."""
    
    def __init__(self, provider_type: str = 'system'):
        self.provider_type = provider_type
        self._provider = self._create_provider()
    
    def _create_provider(self):
        """Factory for temporal providers."""
        providers = {
            'system': SystemTimeProvider(),
            'ntp': NTPTimeProvider(),  # Future: Network Time Protocol
            'custom': CustomTimeProvider(),  # Future: Custom time source
            'test': MockTimeProvider()  # Testing only
        }
        return providers.get(self.provider_type, SystemTimeProvider())
    
    def now(self) -> datetime:
        """Get current time from configured provider."""
        return self._provider.get_current_time()

class SystemTimeProvider:
    """Default: Local system time provider."""
    
    def get_current_time(self) -> datetime:
        return datetime.now()  # Direct system trust
```

### 3. **Agent Temporal Compliance**
```python
# MANDATORY: All agents must inherit temporal compliance
class TemporalCompliantAgent:
    """Base class ensuring temporal trust compliance."""
    
    def __init__(self):
        self.temporal_authority = SystemTimeAuthority()
        self._validate_temporal_compliance()
    
    def _validate_temporal_compliance(self):
        """Ensure agent follows temporal trust rules."""
        # Verify system time access is available
        try:
            current_time = self.temporal_authority.current_time()
            assert isinstance(current_time, datetime)
        except Exception as e:
            raise TemporalComplianceError(f"Agent cannot access system time: {e}")
    
    def get_creation_metadata(self) -> Dict[str, str]:
        """Standard creation metadata for all artifacts."""
        return {
            'created_date': self.temporal_authority.current_time().strftime('%Y-%m-%d'),
            'created_timestamp': self.temporal_authority.project_timestamp(),
            'agent_id': self.__class__.__name__,
            'temporal_authority': 'system'
        }
```

## Enforcement Mechanisms

### 1. **Validation Rules**
```python
def validate_temporal_trust(artifact_content: str) -> bool:
    """Validate that artifacts contain real system timestamps."""
    
    # Check for placeholder dates
    forbidden_patterns = [
        r'\[DATE\]', r'\[TIMESTAMP\]', r'TODO:', r'TBD',
        r'2024-01-01',  # Obvious placeholder dates
        r'1900-01-01', r'2000-01-01'
    ]
    
    for pattern in forbidden_patterns:
        if re.search(pattern, artifact_content):
            raise TemporalTrustViolation(f"Placeholder temporal data detected: {pattern}")
    
    # Verify current year is present
    current_year = datetime.now().year
    if str(current_year) not in artifact_content:
        raise TemporalTrustViolation("Current system year not found in artifact")
    
    return True
```

### 2. **Pre-commit Validation**
```bash
#!/bin/bash
# Pre-commit hook: Temporal trust validation

echo "üïí Validating Temporal Trust Compliance..."

# Check for hardcoded dates in code
if grep -r "datetime(20" --include="*.py" .; then
    echo "‚ùå Hardcoded datetime values found - use system time only"
    exit 1
fi

# Check for temporal placeholders in artifacts
if find generated_projects -name "*.md" -exec grep -l "\[DATE\]\|\[TIMESTAMP\]\|TODO.*date" {} \; | head -1; then
    echo "‚ùå Temporal placeholders found in artifacts"
    exit 1
fi

echo "‚úÖ Temporal trust compliance verified"
```

### 3. **Testing Requirements**
```python
def test_temporal_trust_compliance():
    """Test that all components respect system time."""
    
    # Test 1: System time is used
    before_time = datetime.now()
    agent = VibeAgileFusionEngine(Path('.'))
    result = agent.create_vibe_agile_project(test_config)
    after_time = datetime.now()
    
    # Verify timestamps are within execution window
    creation_time = datetime.fromisoformat(result['created_timestamp'])
    assert before_time <= creation_time <= after_time
    
    # Test 2: No placeholder dates
    artifacts = result['artifacts_generated']
    for artifact in artifacts:
        content = Path(artifact).read_text()
        validate_temporal_trust(content)
    
    # Test 3: Consistent temporal reference
    multiple_results = [agent.create_vibe_agile_project(test_config) for _ in range(3)]
    timestamps = [r['created_timestamp'] for r in multiple_results]
    
    # All should be close in time (within 10 seconds)
    first_time = datetime.fromisoformat(timestamps[0])
    for ts in timestamps[1:]:
        time_diff = abs((datetime.fromisoformat(ts) - first_time).total_seconds())
        assert time_diff < 10, "Temporal inconsistency detected"
```

## Configuration Management

### 1. **Environment Configuration**
```yaml
# temporal_config.yml
temporal_authority:
  provider: "system"  # Default: trust local machine
  fallback: "ntp"     # Future: fallback to network time
  validation:
    enable_placeholder_detection: true
    require_current_year: true
    timezone_aware: true
  
system_time:
  trust_level: "absolute"  # Never question system time
  sync_check: false        # Don't validate against external sources
  
testing:
  provider: "mock"         # Only for testing
  fixed_time: null         # Use system time even in tests unless explicitly set
```

### 2. **Easy Provider Replacement**
```python
# Configuration-driven temporal provider
def create_temporal_provider(config: Dict[str, Any]) -> TemporalProvider:
    """Factory for creating temporal providers based on configuration."""
    
    provider_type = config.get('temporal_authority', {}).get('provider', 'system')
    
    if provider_type == 'system':
        return SystemTimeProvider()
    elif provider_type == 'ntp':
        return NTPTimeProvider(config.get('ntp_servers', []))
    elif provider_type == 'custom':
        return CustomTimeProvider(config.get('custom_endpoint'))
    else:
        # Default to system trust
        return SystemTimeProvider()
```

## Benefits and Guarantees

### 1. **System Guarantees**
- **Temporal Consistency**: All agents use the same time reference
- **Artifact Integrity**: All generated content has accurate timestamps
- **Ontological Alignment**: Consistent temporal understanding across components
- **Easy Migration**: Configurable architecture allows provider changes

### 2. **Development Benefits**
- **No Time Bugs**: Eliminates temporal logic errors
- **Audit Trail**: Accurate creation and modification timestamps
- **Synchronization**: Multiple agents work with consistent time
- **Testability**: Mockable time provider for testing scenarios

### 3. **User Experience**
- **Accurate Artifacts**: All documents have correct creation dates
- **Professional Quality**: Real timestamps enhance artifact credibility
- **Temporal Coherence**: Sprint dates and deadlines are accurately calculated

## Error Handling

### 1. **Temporal Access Failure**
```python
class TemporalComplianceError(Exception):
    """Raised when agent cannot access or trust system time."""
    pass

def safe_system_time() -> datetime:
    """Safely access system time with error handling."""
    try:
        return datetime.now()
    except Exception as e:
        # Log error but don't override - let system handle
        logger.error(f"System time access failed: {e}")
        raise TemporalComplianceError(f"Cannot access system time: {e}")
```

### 2. **Validation Failures**
```python
class TemporalTrustViolation(Exception):
    """Raised when temporal trust rules are violated."""
    pass

def enforce_temporal_trust(func):
    """Decorator to enforce temporal trust in agent operations."""
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        
        # Validate temporal compliance
        if hasattr(result, 'artifacts_generated'):
            for artifact in result.artifacts_generated:
                validate_temporal_trust(artifact)
        
        return result
    return wrapper
```

## Remember

**"Trust the Machine - It Knows the Time"**

**"One Temporal Authority - One Truth"**

**"System Time is Sacred - Never Override"**

**"Build Abstraction - Enable Configuration"**

This rule ensures temporal consistency, artifact integrity, and provides a foundation for building time-aware systems that can be easily reconfigured as needs evolve.