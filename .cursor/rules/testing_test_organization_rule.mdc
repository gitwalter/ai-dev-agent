# Test Organization Rule

## Description
Organize tests in clear, logical structure for easy maintenance and execution.

## Core Requirements

### 1. Test Directory Structure
```
tests/
├── unit/                    # Unit tests for individual components
│   ├── agents/             # Agent unit tests
│   ├── models/             # Model unit tests
│   ├── utils/              # Utility function tests
│   └── workflow/           # Workflow component tests
├── integration/            # Integration tests for component interactions
│   ├── agent_workflows/    # Multi-agent workflow tests
│   ├── api_integration/    # API integration tests
│   └── database/           # Database integration tests
├── system/                 # System-level end-to-end tests
│   ├── complete_workflow/  # Full workflow tests
│   ├── performance/        # Performance tests
│   └── stress/             # Stress and load tests
├── langgraph/              # LangGraph-specific tests
│   ├── nodes/              # Individual node tests
│   ├── workflows/          # Workflow tests
│   └── state/              # State management tests
├── isolated/               # Isolated tests for problematic components
│   └── agents/             # Agent-specific isolated tests
├── supervisor/             # Supervisor agent tests
├── fixtures/               # Test fixtures and helpers
├── mocks/                  # Mock objects and stubs
└── conftest.py            # Pytest configuration
```

### 2. Test File Naming Conventions
- **Unit tests**: `test_[component_name].py`
- **Integration tests**: `test_[component]_integration.py`
- **System tests**: `test_[feature]_system.py`
- **Isolated tests**: `test_[component]_isolated.py`
- **Performance tests**: `test_[component]_performance.py`

### 3. Test Class Organization
```python
class TestComponentName:
    """Tests for ComponentName functionality."""
    
    def test_basic_functionality(self):
        """Test basic component functionality."""
        pass
    
    def test_error_handling(self):
        """Test error handling scenarios."""
        pass
    
    def test_edge_cases(self):
        """Test edge cases and boundary conditions."""
        pass
    
    def test_integration(self):
        """Test integration with other components."""
        pass
```

### 4. Test Method Naming
- **Descriptive names**: `test_[what]_[when]_[expected_result]`
- **Clear purpose**: Each test method should have a clear, specific purpose
- **Consistent format**: Use consistent naming patterns across all tests
- **Action-oriented**: Test names should describe what is being tested

### 5. Test Data Organization
- **Fixtures**: Use pytest fixtures for reusable test data
- **Test data files**: Store test data in separate files when needed
- **Mock objects**: Use mocks for external dependencies
- **Test databases**: Use separate test databases for database tests

## Implementation Guidelines

### Test Execution Commands
```bash
# Run all tests
python -m pytest tests/

# Run specific test types
python -m pytest tests/unit/          # Unit tests only
python -m pytest tests/integration/   # Integration tests only
python -m pytest tests/system/        # System tests only
python -m pytest tests/langgraph/     # LangGraph tests only

# Run specific test files
python -m pytest tests/unit/agents/test_requirements_analyst.py

# Run with coverage
python -m pytest tests/ --cov=. --cov-report=html

# Run with verbose output
python -m pytest tests/ -v

# Run and stop on first failure
python -m pytest tests/ -x
```

### Test Configuration
```python
# conftest.py
import pytest
import sys
import os
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

@pytest.fixture(scope="session")
def test_config():
    """Provide test configuration."""
    return {
        "test_mode": True,
        "api_key": "test-api-key",
        "model": "gemini-2.5-flash-lite"
    }

@pytest.fixture(scope="function")
def clean_state():
    """Provide clean state for each test."""
    # Setup clean state
    yield
    # Cleanup after test
```

### Test Quality Standards
- **Isolation**: Each test should be independent of others
- **Speed**: Tests should run quickly (under 1 second each)
- **Reliability**: Tests should be deterministic and repeatable
- **Coverage**: Aim for 90%+ coverage for core components
- **Clarity**: Tests should be easy to understand and maintain

## Benefits

### Maintenance Benefits
- **Easy navigation** - clear structure makes tests easy to find
- **Logical grouping** - related tests are grouped together
- **Scalable organization** - structure supports growth
- **Clear ownership** - easy to identify test responsibilities

### Development Benefits
- **Faster test execution** - run only relevant tests
- **Better debugging** - isolated tests are easier to debug
- **Clearer failures** - organized tests provide better error context
- **Easier refactoring** - well-organized tests are easier to update

### Team Benefits
- **Consistent standards** - everyone follows the same organization
- **Easier onboarding** - new team members can quickly understand structure
- **Better collaboration** - clear organization reduces conflicts
- **Knowledge sharing** - organized tests serve as documentation

## Application

### When to Apply
- **Creating new tests** - follow the established structure
- **Refactoring tests** - maintain organization during changes
- **Adding new components** - create appropriate test directories
- **Reviewing test quality** - ensure tests follow organization standards

### How to Apply
1. **Follow directory structure** - place tests in appropriate directories
2. **Use consistent naming** - follow established naming conventions
3. **Organize test methods** - group related tests in classes
4. **Use fixtures** - create reusable test data and setup
5. **Maintain quality** - ensure tests meet quality standards

### Success Criteria
- **Clear structure** - tests are organized logically
- **Easy navigation** - tests are easy to find and understand
- **Consistent naming** - all tests follow naming conventions
- **Good coverage** - comprehensive test coverage for all components
- **Fast execution** - tests run quickly and efficiently
- **Reliable results** - tests are deterministic and repeatable

---

**This rule ensures that tests are organized in a clear, logical structure that supports efficient development and maintenance.**
description: Test organization and structure
globs: ["tests/**/*.py", "**/*test*.py"]
alwaysApply: true
---
description:
globs:
alwaysApply: true
---
