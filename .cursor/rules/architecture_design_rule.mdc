# Architecture and Design Rule

**CRITICAL**: All software architecture and design must follow established software development principles, clean code practices, object-oriented design patterns, and test-driven development methodologies.

## Core Architecture Principles

### 1. Clean Code Standards
**MANDATORY**: All code must follow clean code principles
- **Readability**: Code should be self-documenting and easy to understand
- **Maintainability**: Code should be easy to modify and extend
- **Testability**: Code should be designed for easy testing
- **Simplicity**: Avoid unnecessary complexity and over-engineering

#### Clean Code Requirements
```python
# GOOD: Clean, readable code
def calculate_user_discount(user: User, order_total: float) -> float:
    """Calculate discount based on user type and order total."""
    if user.is_premium_member():
        return order_total * 0.15
    elif user.is_regular_member():
        return order_total * 0.10
    return 0.0

# BAD: Unclear, complex code
def calc_ud(u, ot):
    """Calculate user discount."""
    if u.pm and ot > 100:
        return ot * 0.15
    elif u.rm and ot > 50:
        return ot * 0.10
    return 0
```

### 2. Object-Oriented Design Principles

#### SOLID Principles
**MANDATORY**: Follow SOLID principles in all class design

1. **Single Responsibility Principle (SRP)**
   ```python
   # GOOD: Single responsibility
   class UserAuthentication:
       def authenticate(self, credentials: Credentials) -> bool:
           """Handle user authentication only."""
           pass
   
   class UserProfile:
       def update_profile(self, user_data: UserData) -> bool:
           """Handle user profile updates only."""
           pass
   
   # BAD: Multiple responsibilities
   class UserManager:
       def authenticate(self, credentials): pass
       def update_profile(self, user_data): pass
       def send_email(self, message): pass
       def process_payment(self, amount): pass
   ```

2. **Open/Closed Principle (OCP)**
   ```python
   # GOOD: Open for extension, closed for modification
   class PaymentProcessor:
       def process_payment(self, payment: Payment) -> bool:
           return payment.process()
   
   class CreditCardPayment(Payment):
       def process(self) -> bool:
           # Credit card specific logic
           pass
   
   class PayPalPayment(Payment):
       def process(self) -> bool:
           # PayPal specific logic
           pass
   ```

3. **Liskov Substitution Principle (LSP)**
   ```python
   # GOOD: Subtypes are substitutable
   class Animal:
       def make_sound(self) -> str:
           raise NotImplementedError
   
   class Dog(Animal):
       def make_sound(self) -> str:
           return "Woof!"
   
   class Cat(Animal):
       def make_sound(self) -> str:
           return "Meow!"
   
   # Usage: Any Animal subtype can be used
   animals: List[Animal] = [Dog(), Cat()]
   for animal in animals:
       print(animal.make_sound())  # Works with any subtype
   ```

4. **Interface Segregation Principle (ISP)**
   ```python
   # GOOD: Focused interfaces
   class Readable:
       def read(self) -> str:
           pass
   
   class Writable:
       def write(self, data: str) -> None:
           pass
   
   class FileHandler(Readable, Writable):
       def read(self) -> str:
           # Implementation
           pass
       
       def write(self, data: str) -> None:
           # Implementation
           pass
   
   # BAD: Fat interface
   class FileHandler:
       def read(self): pass
       def write(self, data): pass
       def delete(self): pass
       def copy(self): pass
       def move(self): pass
       def compress(self): pass
   ```

5. **Dependency Inversion Principle (DIP)**
   ```python
   # GOOD: Depend on abstractions
   class EmailService(ABC):
       @abstractmethod
       def send_email(self, to: str, subject: str, body: str) -> bool:
           pass
   
   class SMTPEmailService(EmailService):
       def send_email(self, to: str, subject: str, body: str) -> bool:
           # SMTP implementation
           pass
   
   class NotificationService:
       def __init__(self, email_service: EmailService):
           self.email_service = email_service
       
       def notify_user(self, user: User, message: str) -> bool:
           return self.email_service.send_email(
               user.email, "Notification", message
           )
   ```

### 3. Framework and Library Usage

#### Established Framework Priority
**MANDATORY**: Use established frameworks over custom implementations

1. **Web Development**
   ```python
   # GOOD: Use established frameworks
   from fastapi import FastAPI, HTTPException
   from pydantic import BaseModel
   
   app = FastAPI()
   
   class UserModel(BaseModel):
       name: str
       email: str
   
   @app.post("/users/")
   async def create_user(user: UserModel):
       # Framework handles validation, serialization, etc.
       return {"user": user}
   
   # BAD: Custom implementation
   def handle_user_creation(request_data):
       # Manual validation, serialization, error handling
       pass
   ```

2. **Database Operations**
   ```python
   # GOOD: Use established ORMs
   from sqlalchemy import Column, Integer, String
   from sqlalchemy.ext.declarative import declarative_base
   
   Base = declarative_base()
   
   class User(Base):
       __tablename__ = 'users'
       id = Column(Integer, primary_key=True)
       name = Column(String)
       email = Column(String)
   
   # BAD: Raw SQL everywhere
   def create_user(name, email):
       cursor.execute("INSERT INTO users (name, email) VALUES (%s, %s)", (name, email))
   ```

3. **Testing Frameworks**
   ```python
   # GOOD: Use established testing frameworks
   import pytest
   from unittest.mock import Mock
   
   def test_user_creation():
       user_service = UserService()
       user = user_service.create_user("John", "john@example.com")
       assert user.name == "John"
       assert user.email == "john@example.com"
   
   # BAD: Custom testing
   def test_user():
       # Manual assertions, no framework benefits
       pass
   ```

### 4. Clear Structure and Organization

#### Project Structure Standards
**MANDATORY**: Follow established project structure patterns

```
project/
├── src/                    # Source code
│   ├── domain/            # Business logic
│   ├── infrastructure/    # External dependencies
│   ├── application/       # Use cases
│   └── presentation/      # UI/API layer
├── tests/                 # Test files
│   ├── unit/             # Unit tests
│   ├── integration/      # Integration tests
│   └── system/           # System tests
├── docs/                  # Documentation
├── config/               # Configuration files
└── requirements.txt      # Dependencies
```

#### Module Organization
```python
# GOOD: Clear module structure
# user_service.py
from typing import List, Optional
from dataclasses import dataclass

@dataclass
class User:
    id: int
    name: str
    email: str

class UserService:
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository
    
    def create_user(self, name: str, email: str) -> User:
        """Create a new user."""
        user = User(id=None, name=name, email=email)
        return self.user_repository.save(user)
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """Get user by ID."""
        return self.user_repository.find_by_id(user_id)
    
    def get_all_users(self) -> List[User]:
        """Get all users."""
        return self.user_repository.find_all()

# BAD: Unorganized code
def create_user(name, email):
    # Mixed concerns, no structure
    pass

def get_user(id):
    pass

def save_to_db(user):
    pass
```

### 5. Test-Driven Development (TDD)

#### TDD Cycle Requirements
**MANDATORY**: Follow Red-Green-Refactor cycle

1. **Red Phase**: Write failing test
   ```python
   def test_user_creation():
       user_service = UserService()
       user = user_service.create_user("John", "john@example.com")
       assert user.name == "John"
       assert user.email == "john@example.com"
       assert user.id is not None
   ```

2. **Green Phase**: Write minimal code to pass test
   ```python
   class UserService:
       def create_user(self, name: str, email: str) -> User:
           user = User(id=1, name=name, email=email)
           return user
   ```

3. **Refactor Phase**: Improve code while keeping tests passing
   ```python
   class UserService:
       def __init__(self, user_repository: UserRepository):
           self.user_repository = user_repository
       
       def create_user(self, name: str, email: str) -> User:
           user = User(id=None, name=name, email=email)
           return self.user_repository.save(user)
   ```

#### Test Coverage Requirements
- **Unit Tests**: 90%+ coverage for business logic
- **Integration Tests**: All component interactions
- **System Tests**: Complete workflow scenarios
- **Property-Based Tests**: For complex algorithms

### 6. Separation of Concerns

#### Layer Separation
**MANDATORY**: Separate different concerns into distinct layers

```python
# Presentation Layer (API/UI)
class UserController:
    def __init__(self, user_service: UserService):
        self.user_service = user_service
    
    def create_user(self, request: CreateUserRequest) -> UserResponse:
        user = self.user_service.create_user(
            request.name, request.email
        )
        return UserResponse.from_user(user)

# Application Layer (Use Cases)
class UserService:
    def __init__(self, user_repository: UserRepository, email_service: EmailService):
        self.user_repository = user_repository
        self.email_service = email_service
    
    def create_user(self, name: str, email: str) -> User:
        user = User(name=name, email=email)
        saved_user = self.user_repository.save(user)
        self.email_service.send_welcome_email(saved_user.email)
        return saved_user

# Domain Layer (Business Logic)
class User:
    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email
        self.validate_email()
    
    def validate_email(self):
        if '@' not in self.email:
            raise ValueError("Invalid email format")

# Infrastructure Layer (External Dependencies)
class DatabaseUserRepository(UserRepository):
    def save(self, user: User) -> User:
        # Database implementation
        pass
```

### 7. Established Software Development Principles

#### KISS (Keep It Simple, Stupid)
**MANDATORY**: Prefer simple solutions over complex ones

```python
# GOOD: Simple solution
def calculate_total(items: List[Item]) -> float:
    return sum(item.price for item in items)

# BAD: Over-engineered solution
def calculate_total(items: List[Item]) -> float:
    total = 0.0
    for i in range(len(items)):
        item = items[i]
        if item is not None and hasattr(item, 'price'):
            total += float(item.price)
    return total
```

#### DRY (Don't Repeat Yourself)
**MANDATORY**: Eliminate code duplication

```python
# GOOD: DRY principle
class BaseRepository:
    def save(self, entity):
        # Common save logic
        pass
    
    def find_by_id(self, id):
        # Common find logic
        pass

class UserRepository(BaseRepository):
    def __init__(self):
        self.entity_type = User

class ProductRepository(BaseRepository):
    def __init__(self):
        self.entity_type = Product

# BAD: Code duplication
class UserRepository:
    def save(self, user):
        # Duplicated save logic
        pass
    
    def find_by_id(self, id):
        # Duplicated find logic
        pass

class ProductRepository:
    def save(self, product):
        # Duplicated save logic
        pass
    
    def find_by_id(self, id):
        # Duplicated find logic
        pass
```

#### YAGNI (You Aren't Gonna Need It)
**MANDATORY**: Don't implement features until they're needed

```python
# GOOD: YAGNI - implement only what's needed
class UserService:
    def create_user(self, name: str, email: str) -> User:
        # Only implement what's currently needed
        user = User(name=name, email=email)
        return self.user_repository.save(user)

# BAD: Over-engineering for future needs
class UserService:
    def create_user(self, name: str, email: str, 
                   phone: str = None, address: str = None,
                   preferences: dict = None, metadata: dict = None) -> User:
        # Implementing features that aren't needed yet
        user = User(name=name, email=email, phone=phone, 
                   address=address, preferences=preferences, metadata=metadata)
        return self.user_repository.save(user)
```

### 8. Design Patterns and Best Practices

#### Creational Patterns
```python
# Factory Pattern
class UserFactory:
    @staticmethod
    def create_premium_user(name: str, email: str) -> PremiumUser:
        return PremiumUser(name=name, email=email)
    
    @staticmethod
    def create_regular_user(name: str, email: str) -> RegularUser:
        return RegularUser(name=name, email=email)

# Builder Pattern
class UserBuilder:
    def __init__(self):
        self.name = None
        self.email = None
        self.phone = None
    
    def with_name(self, name: str) -> 'UserBuilder':
        self.name = name
        return self
    
    def with_email(self, email: str) -> 'UserBuilder':
        self.email = email
        return self
    
    def build(self) -> User:
        return User(name=self.name, email=self.email, phone=self.phone)
```

#### Behavioral Patterns
```python
# Strategy Pattern
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> bool:
        pass

class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: float) -> bool:
        # Credit card payment logic
        pass

class PayPalPayment(PaymentStrategy):
    def pay(self, amount: float) -> bool:
        # PayPal payment logic
        pass

# Observer Pattern
class EventPublisher:
    def __init__(self):
        self.observers = []
    
    def add_observer(self, observer):
        self.observers.append(observer)
    
    def notify(self, event):
        for observer in self.observers:
            observer.update(event)
```

### 9. Error Handling and Validation

#### Comprehensive Error Handling
```python
# GOOD: Proper error handling
class UserService:
    def create_user(self, name: str, email: str) -> User:
        try:
            self.validate_user_data(name, email)
            user = User(name=name, email=email)
            return self.user_repository.save(user)
        except ValueError as e:
            raise UserCreationError(f"Invalid user data: {e}")
        except DatabaseError as e:
            raise UserCreationError(f"Database error: {e}")
    
    def validate_user_data(self, name: str, email: str):
        if not name or len(name.strip()) == 0:
            raise ValueError("Name cannot be empty")
        if not email or '@' not in email:
            raise ValueError("Invalid email format")

# BAD: Poor error handling
def create_user(name, email):
    user = User(name=name, email=email)
    return user_repository.save(user)  # No error handling
```

### 10. Performance and Optimization

#### Performance Best Practices
```python
# GOOD: Efficient algorithms and data structures
class UserCache:
    def __init__(self):
        self._cache = {}  # O(1) lookup
    
    def get_user(self, user_id: int) -> Optional[User]:
        return self._cache.get(user_id)
    
    def add_user(self, user: User):
        self._cache[user.id] = user

# BAD: Inefficient implementation
class UserCache:
    def __init__(self):
        self._users = []  # O(n) lookup
    
    def get_user(self, user_id: int) -> Optional[User]:
        for user in self._users:  # Linear search
            if user.id == user_id:
                return user
        return None
```

### 11. Documentation and Comments

#### Code Documentation Standards
```python
class UserService:
    """
    Service for managing user operations.
    
    This service handles user creation, updates, and retrieval operations.
    It follows the single responsibility principle by focusing only on user-related
    business logic.
    
    Attributes:
        user_repository: Repository for user data persistence
        email_service: Service for sending user-related emails
    """
    
    def __init__(self, user_repository: UserRepository, email_service: EmailService):
        """
        Initialize UserService with required dependencies.
        
        Args:
            user_repository: Repository for user data operations
            email_service: Service for email notifications
        """
        self.user_repository = user_repository
        self.email_service = email_service
    
    def create_user(self, name: str, email: str) -> User:
        """
        Create a new user with the given name and email.
        
        This method validates the input data, creates a user entity,
        persists it to the repository, and sends a welcome email.
        
        Args:
            name: User's full name (must not be empty)
            email: User's email address (must be valid format)
            
        Returns:
            User: The created user entity
            
        Raises:
            UserCreationError: If user creation fails
            ValueError: If input data is invalid
        """
        try:
            self._validate_user_data(name, email)
            user = User(name=name, email=email)
            saved_user = self.user_repository.save(user)
            self.email_service.send_welcome_email(saved_user.email)
            return saved_user
        except (ValueError, DatabaseError) as e:
            raise UserCreationError(f"Failed to create user: {e}")
    
    def _validate_user_data(self, name: str, email: str) -> None:
        """
        Validate user input data.
        
        Args:
            name: User's name to validate
            email: User's email to validate
            
        Raises:
            ValueError: If validation fails
        """
        if not name or len(name.strip()) == 0:
            raise ValueError("Name cannot be empty")
        if not email or '@' not in email:
            raise ValueError("Invalid email format")
```

### 12. Code Review Checklist

#### Mandatory Review Items
- [ ] **Clean Code**: Code is readable and self-documenting
- [ ] **SOLID Principles**: All SOLID principles are followed
- [ ] **Framework Usage**: Established frameworks are used appropriately
- [ ] **Structure**: Code follows clear organizational structure
- [ ] **TDD**: Tests are written before implementation
- [ ] **Separation of Concerns**: Different concerns are properly separated
- [ ] **KISS**: Solution is as simple as possible
- [ ] **DRY**: No code duplication
- [ ] **YAGNI**: No unnecessary features implemented
- [ ] **Error Handling**: Comprehensive error handling is implemented
- [ ] **Documentation**: Code is properly documented
- [ ] **Performance**: Efficient algorithms and data structures are used

### 13. Implementation Guidelines

#### Before Writing Code
1. **Understand Requirements**: Clearly understand what needs to be built
2. **Design First**: Create a design before implementation
3. **Write Tests**: Write tests before implementing functionality
4. **Choose Frameworks**: Select appropriate established frameworks
5. **Plan Structure**: Plan the code organization and structure

#### During Implementation
1. **Follow TDD**: Write tests, implement, refactor
2. **Apply SOLID**: Use SOLID principles in class design
3. **Keep It Simple**: Avoid over-engineering
4. **Eliminate Duplication**: Refactor to remove code duplication
5. **Separate Concerns**: Keep different concerns separate

#### After Implementation
1. **Review Code**: Self-review against all principles
2. **Refactor**: Improve code while keeping tests passing
3. **Document**: Update documentation as needed
4. **Test**: Ensure all tests pass
5. **Validate**: Verify against requirements

### 14. Benefits

- **Maintainability**: Clean, well-structured code is easier to maintain
- **Testability**: Proper separation and design make code easier to test
- **Scalability**: Good architecture supports growth and changes
- **Reliability**: Comprehensive testing and error handling improve reliability
- **Performance**: Efficient algorithms and data structures improve performance
- **Team Productivity**: Clear structure and principles improve team collaboration
- **Code Quality**: Established principles lead to higher quality code
- **Reduced Technical Debt**: Good practices prevent accumulation of technical debt

### 15. Enforcement

This rule is **ALWAYS APPLIED** and must be followed for all:
- New code development
- Code refactoring and improvements
- Architecture decisions
- Framework and library selection
- Testing strategies
- Documentation requirements
- Code review processes

**Violations of this rule require immediate remediation and refactoring.**

## Conclusion

Following these architecture and design principles ensures the creation of high-quality, maintainable, and scalable software. These principles are time-tested and widely adopted in the software development industry, providing a solid foundation for building robust applications.

**CRITICAL SUCCESS FACTORS:**
- Always write clean, readable code
- Follow SOLID principles in object-oriented design
- Use established frameworks over custom implementations
- Maintain clear separation of concerns
- Practice test-driven development
- Apply KISS, DRY, and YAGNI principles
- Document code comprehensively
- Review code against all principles
description:
globs:
alwaysApply: true
---
