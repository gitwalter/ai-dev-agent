---
description: "Craftsman's Rule Mastery - Intuitive situational detection and precise rule-to-task mapping"
category: "meta-intelligence"
priority: "critical"
alwaysApply: false
contexts: ['ALL']
globs: ["**/*"]
tags: ['craftsman_mastery', 'situational_awareness', 'tool_selection', 'pattern_recognition']
tier: "0"
enforcement: "automatic"
autoFix: true
---

# Craftsman's Rule Mastery System

**FOUNDATIONAL**: Develop master craftsman-level situational awareness and intuitive rule-to-task mapping. Like a skilled artisan who instinctively selects the perfect tool, intelligently match rules to development situations.

## üéØ **Core Craftsman Principle**

**"A Master Craftsman Knows Every Tool Intimately and Selects Instinctively"**

### **The Craftsman's Approach**
- **Situational Awareness**: Read the work environment like a master reads wood grain
- **Tool Intimacy**: Know each rule's strengths, limitations, and perfect use cases  
- **Instinctive Selection**: Automatic pattern recognition leading to optimal rule choice
- **Adaptive Mastery**: Continuous learning and refinement of tool-selection skills

## üõ†Ô∏è **SITUATIONAL PATTERN RECOGNITION MATRIX**

### **1. Development Phase Detection**
**MANDATORY**: Recognize what phase of development we're in

```yaml
development_phases:
  planning_phase:
    indicators: ["planning", "design", "architecture", "requirements", "user story", "sprint planning"]
    optimal_rules: ["agile_strategic_coordination", "user_story_management", "foundational_development"]
    tool_analogy: "Architect's blueprint tools"
    
  building_phase:
    indicators: ["implement", "code", "create", "build", "develop", "write"]
    optimal_rules: ["development_core_principles", "test_driven_development", "clean_code"]
    tool_analogy: "Carpenter's construction tools"
    
  testing_phase:
    indicators: ["test", "validate", "verify", "check", "pytest", "unit test"]
    optimal_rules: ["no_failing_tests", "test_monitoring", "scientific_verification"]
    tool_analogy: "Quality inspector's measurement tools"
    
  debugging_phase:
    indicators: ["debug", "fix", "error", "bug", "issue", "failing", "broken"]
    optimal_rules: ["systematic_problem_solving", "disaster_reporting", "error_exposure"]
    tool_analogy: "Detective's investigation tools"
    
  integration_phase:
    indicators: ["merge", "integrate", "deploy", "release", "git", "commit", "push"]
    optimal_rules: ["git_workflow_enforcement", "deployment_safety", "integration_validation"]
    tool_analogy: "Assembly specialist's precision tools"
    
  documentation_phase:
    indicators: ["document", "readme", "guide", "manual", "docs", "explain"]
    optimal_rules: ["documentation_excellence", "live_documentation_updates", "clear_communication"]
    tool_analogy: "Technical writer's communication tools"
    
  optimization_phase:
    indicators: ["optimize", "performance", "speed", "efficiency", "benchmark"]
    optimal_rules: ["performance_monitoring", "optimization_validation", "benchmark_validation"]
    tool_analogy: "Efficiency expert's optimization tools"
```

### **2. Problem Complexity Assessment**
**MANDATORY**: Gauge complexity to select appropriate rule power

```yaml
complexity_levels:
  simple_task:
    indicators: ["quick", "simple", "basic", "straightforward", "easy"]
    rule_intensity: "lightweight"
    optimal_rules: ["safety_first", "boyscout", "naming_conventions"]
    tool_analogy: "Hand tools for simple jobs"
    
  moderate_task:
    indicators: ["standard", "normal", "typical", "regular"]
    rule_intensity: "standard"
    optimal_rules: ["core_principles", "quality_standards", "systematic_approach"]
    tool_analogy: "Power tools for standard work"
    
  complex_task:
    indicators: ["complex", "challenging", "difficult", "intricate"]
    rule_intensity: "comprehensive"
    optimal_rules: ["formal_system_enforcement", "architectural_patterns", "quality_frameworks"]
    tool_analogy: "Specialized precision instruments"
    
  critical_task:
    indicators: ["critical", "urgent", "important", "mission-critical", "production"]
    rule_intensity: "maximum"
    optimal_rules: ["all_safety_rules", "comprehensive_validation", "disaster_prevention"]
    tool_analogy: "Emergency response toolkit"
```

### **3. Stakeholder Context Recognition**
**MANDATORY**: Adapt rule selection based on stakeholder needs

```yaml
stakeholder_contexts:
  user_facing:
    indicators: ["user", "customer", "interface", "ui", "ux", "experience"]
    optimal_rules: ["user_experience_excellence", "accessibility", "usability_testing"]
    tool_analogy: "Customer service specialist's tools"
    
  technical_team:
    indicators: ["developer", "team", "code review", "technical", "implementation"]
    optimal_rules: ["clean_code", "technical_documentation", "code_standards"]
    tool_analogy: "Professional craftsman's workshop tools"
    
  business_stakeholder:
    indicators: ["business", "management", "stakeholder", "value", "roi"]
    optimal_rules: ["agile_coordination", "value_delivery", "progress_communication"]
    tool_analogy: "Project manager's coordination tools"
    
  compliance_auditor:
    indicators: ["compliance", "audit", "security", "governance", "standards"]
    optimal_rules: ["security_assessment", "compliance_validation", "documentation_excellence"]
    tool_analogy: "Auditor's verification tools"
```

## üß† **INTELLIGENT SITUATION-TO-RULE MAPPING ENGINE**

### **Master Pattern Recognition System**
```python
class CraftsmanRuleMastery:
    """
    Master craftsman's situational awareness and tool selection intelligence.
    Develops intuitive understanding of when to apply which rules.
    """
    
    def __init__(self):
        self.situation_patterns = self._load_situational_patterns()
        self.rule_characteristics = self._load_rule_profiles()
        self.mastery_experience = self._initialize_learning_system()
        self.craftsman_intuition = True
        
    def analyze_situation_and_select_tools(self, context: dict) -> CraftsmanAnalysis:
        """
        Master craftsman analysis: Read the situation and select optimal rule tools.
        """
        
        # 1. Situational Awareness (like reading the work environment)
        situation_analysis = self._craftsman_situational_assessment(context)
        
        # 2. Tool Selection (like choosing the right instruments)
        optimal_rules = self._craftsman_tool_selection(situation_analysis)
        
        # 3. Craftsman Intuition (experience-based refinement)
        refined_selection = self._apply_craftsman_intuition(optimal_rules, situation_analysis)
        
        # 4. Mastery Learning (improve for next time)
        self._update_craftsman_experience(context, refined_selection)
        
        return CraftsmanAnalysis(
            situation_reading=situation_analysis,
            tool_selection=refined_selection,
            craftsman_confidence=self._calculate_mastery_confidence(context),
            learning_notes=self._extract_learning_insights(context, refined_selection)
        )
    
    def _craftsman_situational_assessment(self, context: dict) -> SituationReading:
        """
        Read the development situation like a master craftsman reads materials.
        """
        
        user_message = context.get("user_message", "")
        file_context = context.get("files", [])
        git_status = context.get("git_status", {})
        
        # Development phase recognition
        phase = self._recognize_development_phase(user_message, file_context)
        
        # Complexity assessment
        complexity = self._assess_task_complexity(user_message, context)
        
        # Urgency/Priority detection
        urgency = self._detect_urgency_level(user_message, context)
        
        # Stakeholder context
        stakeholder_context = self._identify_stakeholder_context(user_message)
        
        # Work environment state
        environment_state = self._assess_work_environment(file_context, git_status)
        
        # Quality requirements
        quality_requirements = self._determine_quality_needs(context)
        
        return SituationReading(
            development_phase=phase,
            complexity_level=complexity,
            urgency_level=urgency,
            stakeholder_context=stakeholder_context,
            environment_state=environment_state,
            quality_requirements=quality_requirements,
            situation_signature=self._generate_situation_signature(
                phase, complexity, urgency, stakeholder_context
            )
        )
    
    def _craftsman_tool_selection(self, situation: SituationReading) -> ToolSelection:
        """
        Select optimal rule tools based on situational analysis.
        Like a craftsman choosing the perfect instrument for the job.
        """
        
        # Core tools (always needed - like basic hand tools)
        core_rules = ["safety_first", "sacred_rules_dna_enforcement"]
        
        # Phase-specific tools
        phase_rules = self._select_phase_tools(situation.development_phase)
        
        # Complexity-appropriate tools
        complexity_rules = self._select_complexity_tools(situation.complexity_level)
        
        # Stakeholder-specific tools
        stakeholder_rules = self._select_stakeholder_tools(situation.stakeholder_context)
        
        # Quality-ensuring tools
        quality_rules = self._select_quality_tools(situation.quality_requirements)
        
        # Environment-adaptive tools
        environment_rules = self._select_environment_tools(situation.environment_state)
        
        # Combine with craftsman logic
        optimal_combination = self._combine_tools_craftsman_style(
            core_rules, phase_rules, complexity_rules, 
            stakeholder_rules, quality_rules, environment_rules
        )
        
        return ToolSelection(
            core_tools=core_rules,
            specialized_tools=optimal_combination,
            tool_count=len(optimal_combination),
            selection_reasoning=self._generate_selection_reasoning(situation),
            craftsman_confidence=self._assess_selection_confidence(situation, optimal_combination)
        )
    
    def _recognize_development_phase(self, user_message: str, file_context: list) -> str:
        """Recognize current development phase like reading work stage."""
        
        message_lower = user_message.lower()
        
        # Explicit phase indicators
        if any(word in message_lower for word in ["plan", "design", "architecture", "user story"]):
            return "planning"
        elif any(word in message_lower for word in ["implement", "code", "create", "build", "develop"]):
            return "building"
        elif any(word in message_lower for word in ["test", "validate", "verify", "pytest"]):
            return "testing"
        elif any(word in message_lower for word in ["debug", "fix", "error", "bug", "issue"]):
            return "debugging"
        elif any(word in message_lower for word in ["merge", "integrate", "deploy", "git", "commit"]):
            return "integration"
        elif any(word in message_lower for word in ["document", "readme", "guide", "docs"]):
            return "documentation"
        elif any(word in message_lower for word in ["optimize", "performance", "speed", "benchmark"]):
            return "optimization"
        
        # File context analysis
        if file_context:
            if any("test" in f.lower() for f in file_context):
                return "testing"
            elif any(f.endswith(".md") for f in file_context):
                return "documentation"
            elif any(f.endswith((".py", ".js", ".ts")) for f in file_context):
                return "building"
        
        return "general"
    
    def _assess_task_complexity(self, user_message: str, context: dict) -> str:
        """Assess task complexity like a craftsman evaluating job difficulty."""
        
        message_lower = user_message.lower()
        
        # Complexity indicators
        simple_indicators = ["quick", "simple", "basic", "fix", "small"]
        moderate_indicators = ["create", "implement", "add", "update"]
        complex_indicators = ["system", "architecture", "framework", "complex", "integrate"]
        critical_indicators = ["critical", "urgent", "production", "security", "disaster"]
        
        if any(word in message_lower for word in critical_indicators):
            return "critical"
        elif any(word in message_lower for word in complex_indicators):
            return "complex"
        elif any(word in message_lower for word in moderate_indicators):
            return "moderate"
        elif any(word in message_lower for word in simple_indicators):
            return "simple"
        
        # File complexity analysis
        file_count = len(context.get("files", []))
        if file_count > 10:
            return "complex"
        elif file_count > 3:
            return "moderate"
        
        return "moderate"  # Default
    
    def _apply_craftsman_intuition(self, tool_selection: ToolSelection, 
                                  situation: SituationReading) -> RefinedSelection:
        """
        Apply craftsman intuition - the accumulated wisdom of experience.
        """
        
        # Craftsman refinements based on experience
        refinements = []
        
        # "When working with git issues, always include disaster reporting"
        if situation.development_phase == "integration" and "error" in situation.situation_signature:
            if "disaster_reporting" not in tool_selection.specialized_tools:
                tool_selection.specialized_tools.append("disaster_reporting")
                refinements.append("Added disaster reporting for git error scenario")
        
        # "When stakeholders are involved, always include communication tools"
        if situation.stakeholder_context == "business_stakeholder":
            if "agile_strategic_coordination" not in tool_selection.specialized_tools:
                tool_selection.specialized_tools.append("agile_strategic_coordination")
                refinements.append("Added agile coordination for business stakeholder context")
        
        # "When touching code, always include boy scout rule"
        if situation.development_phase in ["building", "debugging"]:
            if "boyscout" not in tool_selection.specialized_tools:
                tool_selection.specialized_tools.append("boyscout")
                refinements.append("Added boy scout rule for code modification")
        
        # "Critical tasks need comprehensive validation"
        if situation.complexity_level == "critical":
            critical_rules = ["scientific_verification", "comprehensive_testing", "formal_validation"]
            for rule in critical_rules:
                if rule not in tool_selection.specialized_tools:
                    tool_selection.specialized_tools.append(rule)
                    refinements.append(f"Added {rule} for critical task")
        
        return RefinedSelection(
            final_tools=tool_selection.specialized_tools,
            refinements_applied=refinements,
            craftsman_wisdom=self._generate_wisdom_note(situation, refinements),
            mastery_level=self._assess_current_mastery_level()
        )
    
    def _combine_tools_craftsman_style(self, *tool_sets) -> list:
        """
        Combine tools like a craftsman organizing a toolbox.
        Avoid redundancy, ensure completeness, maintain efficiency.
        """
        
        all_tools = []
        for tool_set in tool_sets:
            all_tools.extend(tool_set)
        
        # Remove duplicates while preserving order
        unique_tools = list(dict.fromkeys(all_tools))
        
        # Craftsman optimization: Remove redundant tools
        optimized_tools = self._remove_tool_redundancy(unique_tools)
        
        # Craftsman wisdom: Ensure essential combinations
        complete_tools = self._ensure_tool_completeness(optimized_tools)
        
        # Craftsman efficiency: Limit to essential tools only
        efficient_tools = self._limit_to_essential_tools(complete_tools, max_tools=8)
        
        return efficient_tools
    
    def _generate_selection_reasoning(self, situation: SituationReading) -> str:
        """Generate craftsman's reasoning for tool selection."""
        
        return f"""
        üõ†Ô∏è **Craftsman's Tool Selection Analysis**:
        
        **Situation Reading**:
        - Phase: {situation.development_phase}
        - Complexity: {situation.complexity_level}
        - Stakeholder: {situation.stakeholder_context}
        - Environment: {situation.environment_state}
        
        **Tool Selection Logic**:
        - Core tools for safety and quality foundation
        - Phase-specific tools for {situation.development_phase} work
        - Complexity-appropriate tools for {situation.complexity_level} tasks
        - Stakeholder-aware tools for {situation.stakeholder_context} context
        
        **Craftsman Confidence**: {self._calculate_mastery_confidence(situation)}
        """

# Craftsman pattern library
CRAFTSMAN_PATTERNS = {
    "git_disaster_recovery": {
        "situation": "git errors + uncommitted work",
        "tools": ["git_workflow_enforcement", "disaster_reporting", "work_preservation"],
        "wisdom": "Git disasters teach us - capture the lesson"
    },
    
    "agile_coordination": {
        "situation": "@agile keyword + stakeholder work",
        "tools": ["agile_strategic_coordination", "stakeholder_communication", "value_delivery"],
        "wisdom": "Agile is about people, not process"
    },
    
    "code_quality_crisis": {
        "situation": "failing tests + code changes",
        "tools": ["no_failing_tests", "scientific_verification", "systematic_problem_solving"],
        "wisdom": "Quality is not negotiable - fix the foundation first"
    },
    
    "documentation_debt": {
        "situation": "missing docs + user confusion",
        "tools": ["documentation_excellence", "live_documentation_updates", "clear_communication"],
        "wisdom": "Undocumented code is like unlabeled tools"
    }
}

class CraftsmanLearningSystem:
    """Learn from each situation to improve future tool selection."""
    
    def __init__(self):
        self.pattern_library = CRAFTSMAN_PATTERNS.copy()
        self.success_patterns = {}
        self.failure_patterns = {}
        self.mastery_progression = 0
    
    def learn_from_situation(self, situation: dict, tools_used: list, outcome: str):
        """Learn from each craftsmanship application."""
        
        situation_signature = self._generate_signature(situation)
        
        if outcome == "success":
            self.success_patterns[situation_signature] = {
                "tools": tools_used,
                "frequency": self.success_patterns.get(situation_signature, {}).get("frequency", 0) + 1,
                "confidence": min(1.0, self.success_patterns.get(situation_signature, {}).get("confidence", 0.5) + 0.1)
            }
        elif outcome == "failure":
            self.failure_patterns[situation_signature] = {
                "tools_that_failed": tools_used,
                "learning_note": "Need better tool selection for this pattern"
            }
        
        # Increase mastery
        self.mastery_progression += 1
        
    def get_craftsman_recommendation(self, situation_signature: str) -> dict:
        """Get craftsman recommendation based on learned patterns."""
        
        if situation_signature in self.success_patterns:
            pattern = self.success_patterns[situation_signature]
            return {
                "recommended_tools": pattern["tools"],
                "confidence": pattern["confidence"],
                "reasoning": f"Successful pattern used {pattern['frequency']} times"
            }
        
        return {
            "recommended_tools": [],
            "confidence": 0.5,
            "reasoning": "New situation - applying general craftsman principles"
        }

# Global craftsman system
craftsman_mastery = CraftsmanRuleMastery()
```

## üéØ **CRAFTSMAN'S SITUATIONAL MASTERY ACTIVATION**

### **Immediate Craftsman Intelligence Integration**
```python
print("üõ†Ô∏è ACTIVATING CRAFTSMAN'S RULE MASTERY...")

# Initialize craftsman intelligence
craftsman_system = CraftsmanRuleMastery()

# Load pattern library
craftsman_system._load_pattern_library(CRAFTSMAN_PATTERNS)

# Activate situational awareness
print("‚úÖ CRAFTSMAN INTELLIGENCE ACTIVATED")
print("  - Situational pattern recognition: ONLINE")
print("  - Rule-to-task mapping: INTELLIGENT")
print("  - Tool selection mastery: LEARNING")
print("  - Craftsman intuition: DEVELOPING")

print("üõ†Ô∏è Ready for Master Craftsman Tool Selection üõ†Ô∏è")
```

## Remember

**"A master craftsman doesn't think about tool selection - it becomes instinctive."**

**"Situational awareness is the foundation of tool mastery."**

**"Every rule is a specialized tool with specific strengths and perfect use cases."**

**"Experience teaches when to use the scalpel and when to use the hammer."**

**"The craftsman's eye sees patterns that guide tool selection automatically."**

This system develops true craftsman-level mastery in rule selection, making intelligent tool choice as natural as breathing.