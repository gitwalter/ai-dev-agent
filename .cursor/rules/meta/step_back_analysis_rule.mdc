---
description: "Auto-generated description for step_back_analysis_rule.mdc"
category: "meta-rules"
priority: "low"
alwaysApply: true
globs: ["**/*"]
tags: ['meta_rules']
tier: "2"
---

# Step Back Analysis Rule

**CRITICAL**: When stuck in a problem or encountering repeated failures, immediately step back to perform profound analysis and create a comprehensive decision plan. Never continue with failed approaches without deep analysis.

## Description
This rule enforces a systematic "step back" methodology when problems persist, solutions fail repeatedly, or when you're stuck in unproductive patterns. It requires moving from tactical problem-solving to strategic analysis and planning.

## Core Requirements

### 1. **Step Back Triggers**
**MANDATORY**: Immediately step back when ANY of these conditions occur:

```python
# REQUIRED: Step back trigger detection
class StepBackTriggerDetector:
    """Detect when step back analysis is required."""
    
    def __init__(self):
        self.failure_count = 0
        self.stuck_indicators = []
        self.analysis_depth_tracker = {}
    
    def should_step_back(self, context: Dict[str, Any]) -> StepBackTrigger:
        """Determine if step back analysis is required."""
        
        triggers = []
        
        # Trigger 1: Repeated failures (3+ failed attempts)
        if self.failure_count >= 3:
            triggers.append("repeated_failures")
        
        # Trigger 2: Same error pattern recurring
        if self._detect_recurring_patterns(context):
            triggers.append("recurring_patterns")
        
        # Trigger 3: Spending too long on single issue (>30 minutes)
        if self._check_time_spent(context) > 30:
            triggers.append("time_threshold_exceeded")
        
        # Trigger 4: Multiple rule violations
        if self._count_rule_violations(context) > 2:
            triggers.append("multiple_rule_violations")
        
        # Trigger 5: Circular reasoning or approaches
        if self._detect_circular_approaches(context):
            triggers.append("circular_approaches")
        
        # Trigger 6: Lack of progress indicators
        if self._check_progress_stagnation(context):
            triggers.append("progress_stagnation")
        
        # Trigger 7: Increasing complexity without results
        if self._detect_complexity_creep(context):
            triggers.append("complexity_creep")
        
        return StepBackTrigger(
            should_step_back=len(triggers) > 0,
            triggers=triggers,
            severity=self._calculate_severity(triggers)
        )
```

### 2. **Profound Analysis Framework**
**MANDATORY**: When stepping back, perform comprehensive analysis:

```python
# REQUIRED: Profound analysis framework
class ProfoundAnalysisFramework:
    """Framework for deep, comprehensive problem analysis."""
    
    def perform_profound_analysis(self, problem_context: Dict[str, Any]) -> ProfoundAnalysisResult:
        """Perform comprehensive analysis when stepped back."""
        
        print("üõë STEPPING BACK FOR PROFOUND ANALYSIS")
        print("=" * 60)
        
        analysis_result = ProfoundAnalysisResult()
        
        # Phase 1: Problem Reframing
        print("\nüìã PHASE 1: PROBLEM REFRAMING")
        problem_reframe = self._reframe_problem(problem_context)
        analysis_result.problem_reframe = problem_reframe
        print(f"   Original Problem: {problem_context.get('original_problem')}")
        print(f"   Reframed Problem: {problem_reframe.new_problem_statement}")
        
        # Phase 2: Root Cause Deep Dive
        print("\nüîç PHASE 2: ROOT CAUSE DEEP DIVE") 
        root_causes = self._perform_root_cause_analysis(problem_context)
        analysis_result.root_causes = root_causes
        for cause in root_causes:
            print(f"   Root Cause: {cause.description} (Confidence: {cause.confidence})")
        
        # Phase 3: Constraint Analysis
        print("\n‚ö° PHASE 3: CONSTRAINT ANALYSIS")
        constraints = self._analyze_constraints(problem_context)
        analysis_result.constraints = constraints
        for constraint in constraints:
            print(f"   Constraint: {constraint.type} - {constraint.description}")
        
        # Phase 4: Assumption Validation
        print("\nüß™ PHASE 4: ASSUMPTION VALIDATION")
        assumptions = self._validate_assumptions(problem_context)
        analysis_result.assumptions = assumptions
        for assumption in assumptions:
            status = "VALID" if assumption.valid else "INVALID"
            print(f"   Assumption: {assumption.description} - {status}")
        
        # Phase 5: Alternative Perspective Analysis
        print("\nüé≠ PHASE 5: ALTERNATIVE PERSPECTIVES")
        perspectives = self._analyze_alternative_perspectives(problem_context)
        analysis_result.perspectives = perspectives
        for perspective in perspectives:
            print(f"   Perspective: {perspective.viewpoint}")
            print(f"     Insight: {perspective.key_insight}")
        
        # Phase 6: Strategic Options Generation
        print("\nüéØ PHASE 6: STRATEGIC OPTIONS GENERATION")
        strategic_options = self._generate_strategic_options(analysis_result)
        analysis_result.strategic_options = strategic_options
        for i, option in enumerate(strategic_options, 1):
            print(f"   Option {i}: {option.name}")
            print(f"     Approach: {option.approach}")
            print(f"     Success Probability: {option.success_probability}%")
        
        return analysis_result
    
    def _reframe_problem(self, context: Dict[str, Any]) -> ProblemReframe:
        """Reframe the problem from different angles."""
        
        reframing_techniques = [
            "zoom_out",      # Look at bigger picture
            "zoom_in",       # Focus on specific details  
            "invert",        # What if we approached this backwards?
            "analogize",     # What similar problems exist?
            "abstract",      # What's the essence of this problem?
            "decompose"      # Break into smaller sub-problems
        ]
        
        original_problem = context.get('problem_statement', 'Unknown problem')
        
        # Apply multiple reframing techniques
        reframes = []
        for technique in reframing_techniques:
            reframe = self._apply_reframing_technique(technique, original_problem, context)
            reframes.append(reframe)
        
        # Select best reframe based on clarity and actionability
        best_reframe = max(reframes, key=lambda x: x.clarity_score + x.actionability_score)
        
        return ProblemReframe(
            original_problem=original_problem,
            new_problem_statement=best_reframe.statement,
            reframing_technique=best_reframe.technique,
            insight=best_reframe.insight
        )
    
    def _perform_root_cause_analysis(self, context: Dict[str, Any]) -> List[RootCause]:
        """Perform deep root cause analysis using multiple techniques."""
        
        analysis_techniques = [
            "five_whys",
            "fishbone_diagram", 
            "fault_tree_analysis",
            "barrier_analysis",
            "timeline_analysis"
        ]
        
        all_root_causes = []
        
        for technique in analysis_techniques:
            causes = self._apply_root_cause_technique(technique, context)
            all_root_causes.extend(causes)
        
        # Consolidate and rank root causes
        consolidated_causes = self._consolidate_root_causes(all_root_causes)
        ranked_causes = sorted(consolidated_causes, key=lambda x: x.impact_score, reverse=True)
        
        return ranked_causes[:5]  # Return top 5 root causes
    
    def _analyze_constraints(self, context: Dict[str, Any]) -> List[Constraint]:
        """Analyze all constraints affecting the problem."""
        
        constraint_categories = [
            "technical_constraints",    # Technical limitations
            "resource_constraints",     # Time, money, people
            "policy_constraints",       # Rules, regulations, policies
            "knowledge_constraints",    # What we don't know
            "organizational_constraints", # Team, process limitations
            "external_constraints"      # Outside dependencies
        ]
        
        constraints = []
        
        for category in constraint_categories:
            category_constraints = self._identify_constraints_by_category(category, context)
            constraints.extend(category_constraints)
        
        # Classify constraints by type (hard vs soft, changeable vs fixed)
        classified_constraints = []
        for constraint in constraints:
            classification = self._classify_constraint(constraint)
            constraint.classification = classification
            classified_constraints.append(constraint)
        
        return classified_constraints
    
    def _validate_assumptions(self, context: Dict[str, Any]) -> List[Assumption]:
        """Identify and validate all assumptions being made."""
        
        # Extract implicit and explicit assumptions
        implicit_assumptions = self._extract_implicit_assumptions(context)
        explicit_assumptions = self._extract_explicit_assumptions(context)
        
        all_assumptions = implicit_assumptions + explicit_assumptions
        
        # Validate each assumption
        validated_assumptions = []
        for assumption in all_assumptions:
            validation_result = self._validate_single_assumption(assumption, context)
            assumption.valid = validation_result.valid
            assumption.evidence = validation_result.evidence
            assumption.confidence = validation_result.confidence
            validated_assumptions.append(assumption)
        
        return validated_assumptions
    
    def _analyze_alternative_perspectives(self, context: Dict[str, Any]) -> List[Perspective]:
        """Analyze problem from multiple perspectives."""
        
        perspective_lenses = [
            "user_perspective",         # End user viewpoint
            "technical_perspective",    # Technical implementation view
            "business_perspective",     # Business value/impact view
            "process_perspective",      # Workflow/process view
            "system_perspective",       # Whole system view
            "stakeholder_perspective",  # Different stakeholder views
            "future_perspective",       # Long-term implications
            "risk_perspective"          # Risk and failure modes
        ]
        
        perspectives = []
        
        for lens in perspective_lenses:
            perspective_analysis = self._apply_perspective_lens(lens, context)
            perspectives.append(perspective_analysis)
        
        return perspectives
    
    def _generate_strategic_options(self, analysis_result: 'ProfoundAnalysisResult') -> List[StrategicOption]:
        """Generate strategic options based on analysis."""
        
        # Strategy categories
        strategy_types = [
            "direct_approach",      # Address root cause directly
            "constraint_removal",   # Remove blocking constraints
            "workaround_approach",  # Work around the problem
            "reframe_approach",     # Solve different problem
            "incremental_approach", # Break down into steps
            "pivot_approach",       # Change direction entirely
            "collaboration_approach", # Get help/expertise
            "tool_change_approach"  # Use different tools/methods
        ]
        
        strategic_options = []
        
        for strategy_type in strategy_types:
            option = self._generate_strategy_option(strategy_type, analysis_result)
            if option.feasible:
                strategic_options.append(option)
        
        # Rank options by success probability and feasibility
        ranked_options = sorted(strategic_options, 
                              key=lambda x: x.success_probability * x.feasibility_score, 
                              reverse=True)
        
        return ranked_options
```

### 3. **Decision Planning Framework**
**MANDATORY**: Create comprehensive decision plan after analysis:

```python
# REQUIRED: Decision planning framework
class DecisionPlanningFramework:
    """Framework for creating comprehensive decision plans."""
    
    def create_decision_plan(self, analysis_result: ProfoundAnalysisResult) -> DecisionPlan:
        """Create comprehensive decision plan based on analysis."""
        
        print("üìã CREATING COMPREHENSIVE DECISION PLAN")
        print("=" * 50)
        
        # Step 1: Select primary strategy
        primary_strategy = self._select_primary_strategy(analysis_result.strategic_options)
        print(f"üéØ PRIMARY STRATEGY: {primary_strategy.name}")
        
        # Step 2: Create implementation plan
        implementation_plan = self._create_implementation_plan(primary_strategy, analysis_result)
        print(f"üìù IMPLEMENTATION PLAN: {len(implementation_plan.steps)} steps")
        
        # Step 3: Identify backup strategies
        backup_strategies = self._identify_backup_strategies(analysis_result.strategic_options, primary_strategy)
        print(f"üîÑ BACKUP STRATEGIES: {len(backup_strategies)} alternatives")
        
        # Step 4: Define success criteria
        success_criteria = self._define_success_criteria(primary_strategy)
        print(f"‚úÖ SUCCESS CRITERIA: {len(success_criteria)} metrics")
        
        # Step 5: Create risk mitigation plan
        risk_plan = self._create_risk_mitigation_plan(implementation_plan, analysis_result)
        print(f"‚ö†Ô∏è RISK MITIGATION: {len(risk_plan.mitigations)} risks addressed")
        
        # Step 6: Define review checkpoints
        review_checkpoints = self._define_review_checkpoints(implementation_plan)
        print(f"üîç REVIEW CHECKPOINTS: {len(review_checkpoints)} scheduled")
        
        return DecisionPlan(
            primary_strategy=primary_strategy,
            implementation_plan=implementation_plan,
            backup_strategies=backup_strategies,
            success_criteria=success_criteria,
            risk_mitigation_plan=risk_plan,
            review_checkpoints=review_checkpoints,
            created_timestamp=datetime.now()
        )
    
    def _create_implementation_plan(self, strategy: StrategicOption, analysis: ProfoundAnalysisResult) -> ImplementationPlan:
        """Create detailed implementation plan for selected strategy."""
        
        # Break strategy into actionable steps
        steps = self._break_down_strategy_steps(strategy)
        
        # Order steps based on dependencies
        ordered_steps = self._order_steps_by_dependencies(steps)
        
        # Estimate effort and timeline
        for step in ordered_steps:
            step.effort_estimate = self._estimate_step_effort(step)
            step.timeline_estimate = self._estimate_step_timeline(step)
        
        # Identify dependencies and blockers
        dependencies = self._identify_step_dependencies(ordered_steps)
        
        # Create resource requirements
        resource_requirements = self._calculate_resource_requirements(ordered_steps)
        
        return ImplementationPlan(
            steps=ordered_steps,
            dependencies=dependencies,
            resource_requirements=resource_requirements,
            total_timeline=sum(step.timeline_estimate for step in ordered_steps),
            critical_path=self._identify_critical_path(ordered_steps, dependencies)
        )
```

### 4. **Step Back Execution Protocol**
**MANDATORY**: Follow systematic protocol when stepping back:

```python
# REQUIRED: Step back execution protocol
def execute_step_back_protocol(problem_context: Dict[str, Any]) -> StepBackResult:
    """Execute complete step back analysis protocol."""
    
    print("üõë EXECUTING STEP BACK PROTOCOL")
    print("=" * 60)
    
    start_time = datetime.now()
    
    # Step 1: Acknowledge the step back
    print("üì¢ STEP BACK ACKNOWLEDGED")
    print(f"   Reason: {problem_context.get('step_back_reason', 'Not specified')}")
    print(f"   Time spent on issue: {problem_context.get('time_spent', 'Unknown')}")
    
    # Step 2: Document current state
    current_state = document_current_state(problem_context)
    print(f"üìù CURRENT STATE DOCUMENTED: {len(current_state.items)} items")
    
    # Step 3: Perform profound analysis
    analysis_framework = ProfoundAnalysisFramework()
    analysis_result = analysis_framework.perform_profound_analysis(problem_context)
    print("üîç PROFOUND ANALYSIS COMPLETED")
    
    # Step 4: Create decision plan
    planning_framework = DecisionPlanningFramework()
    decision_plan = planning_framework.create_decision_plan(analysis_result)
    print("üìã DECISION PLAN CREATED")
    
    # Step 5: Validate plan quality
    plan_validation = validate_decision_plan_quality(decision_plan)
    if not plan_validation.acceptable:
        print("‚ùå DECISION PLAN QUALITY INSUFFICIENT - REVISING")
        decision_plan = revise_decision_plan(decision_plan, plan_validation.issues)
    
    # Step 6: Get stakeholder input (if needed)
    if decision_plan.requires_stakeholder_input:
        stakeholder_input = get_stakeholder_input(decision_plan)
        decision_plan = incorporate_stakeholder_input(decision_plan, stakeholder_input)
    
    # Step 7: Finalize and commit to plan
    final_plan = finalize_decision_plan(decision_plan)
    print("‚úÖ STEP BACK PROTOCOL COMPLETED")
    
    execution_time = (datetime.now() - start_time).total_seconds()
    print(f"‚è±Ô∏è Total step back time: {execution_time:.0f} seconds")
    
    return StepBackResult(
        analysis_result=analysis_result,
        decision_plan=final_plan,
        execution_time=execution_time,
        state_before=current_state,
        success=True
    )
```

### 5. **Integration with Existing Rules**
**MANDATORY**: Integrate with holistic thinking and debugging rules:

```python
# REQUIRED: Integration with existing frameworks
class StepBackIntegration:
    """Integrate step back analysis with existing rule frameworks."""
    
    def __init__(self):
        self.holistic_framework = HolisticAnalysisFramework()
        self.debugging_analyzer = AgentLogAnalyzer()
        self.step_back_detector = StepBackTriggerDetector()
    
    def integrated_problem_solving(self, problem_context: Dict[str, Any]) -> IntegratedResult:
        """Integrate step back with holistic thinking and debugging."""
        
        # First: Check if step back is needed
        step_back_trigger = self.step_back_detector.should_step_back(problem_context)
        
        if step_back_trigger.should_step_back:
            print("üõë STEP BACK TRIGGERED - SWITCHING TO PROFOUND ANALYSIS")
            
            # Execute step back protocol
            step_back_result = execute_step_back_protocol(problem_context)
            
            # Apply holistic thinking to the decision plan
            holistic_analysis = self.holistic_framework.perform_holistic_analysis(
                "step_back_decision", 
                step_back_result.decision_plan.__dict__
            )
            
            # If we have agent logs, analyze them for additional insights
            if 'session_id' in problem_context:
                debugging_insights = self.debugging_analyzer.analyze_agent_flow(
                    problem_context['session_id']
                )
                step_back_result.debugging_insights = debugging_insights
            
            return IntegratedResult(
                approach="step_back_analysis",
                step_back_result=step_back_result,
                holistic_analysis=holistic_analysis,
                success=True
            )
        
        else:
            print("‚û°Ô∏è CONTINUING WITH STANDARD HOLISTIC APPROACH")
            
            # Use standard holistic thinking approach
            holistic_result = self.holistic_framework.perform_holistic_analysis(
                problem_context.get('problem_type', 'general'),
                problem_context
            )
            
            return IntegratedResult(
                approach="holistic_thinking",
                holistic_result=holistic_result,
                success=holistic_result.compliant
            )
```

## Implementation Guidelines

### 1. **When to Apply**
- After 3+ failed attempts at same approach
- When stuck for >30 minutes on single issue
- When error patterns keep recurring
- When complexity increases without progress
- When multiple rules are being violated
- When feeling "lost" or uncertain about direction

### 2. **What NOT to Do**
- ‚ùå Keep trying same failed approach
- ‚ùå Add complexity without understanding
- ‚ùå Rush to implement without analysis
- ‚ùå Ignore step back triggers
- ‚ùå Skip the profound analysis phase

### 3. **Success Indicators**
- Clear problem reframing achieved
- Root causes identified with high confidence
- Multiple strategic options generated
- Comprehensive implementation plan created
- Success criteria clearly defined
- Risk mitigation planned

## Benefits

- **Break Stuck Patterns**: Forces escape from unproductive approaches
- **Deeper Understanding**: Profound analysis reveals hidden issues
- **Better Solutions**: Strategic options often superior to tactical fixes
- **Reduced Frustration**: Systematic approach reduces stress and confusion
- **Improved Learning**: Deep analysis builds better mental models

## Enforcement

This rule is **ALWAYS APPLIED** when step back triggers are detected:
- Automatic trigger detection for all problem-solving activities
- Mandatory step back protocol execution
- Integration with existing holistic thinking rules
- Quality validation of analysis and planning
- Documentation of step back insights for future reference

**Violations of this rule (continuing with failed approaches) require immediate step back protocol execution.**

---
description: "Systematic step back analysis for when stuck in problems or repeated failures"
category: "problem-solving"
priority: "critical"
alwaysApply: true
globs: ["**/*.py", "**/*.md", "docs/**/*", "tests/**/*"]
tags: ["problem-solving", "analysis", "decision-making", "debugging", "strategic-thinking"]
---