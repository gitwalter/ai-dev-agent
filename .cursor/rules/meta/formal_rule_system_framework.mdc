---
alwaysApply: false
autoFix: true
category: foundational-axiomatic
contexts:
- ALL
dependencies: []
description: Logical Consistency Principle - axiomatic layer rule
enforcement: blocking
formalLayer: axiomatic
globs:
- '**/*'
languageGames:
- consistency_validation
- logical_coherence
linguisticFramework: foundational
logicalType: 1
priority: critical
tags:
- axiomatic
- foundational
- type_1
- priority_1
- consistency_validation
- logical_coherence
tier: '1'
---

# Formal Rule System Framework

**CRITICAL**: The cursor rule system IS a formal system with axioms, inference rules, syntax, semantics, and systematic application procedures. This meta-rule enforces the formal system properties and ensures consistent, efficient, and complete rule application.

## Core Principle

**"Every Rule is Part of a Mathematical Formal System"**

The cursor rule system operates as a rigorous formal system where every rule, application, and validation follows mathematical principles of consistency, completeness, and decidability.

## Formal System Components

### 1. **Axioms (Foundation Rules)**
**IMMUTABLE**: Base axioms that cannot be violated
```yaml
foundation_axioms:
  safety_axiom: "Safety First Principle - never compromise user or system safety"
  evidence_axiom: "Scientific Verification - all claims require concrete evidence"
  consistency_axiom: "No Premature Victory Declaration - validation before success claims"
  quality_axiom: "Excellence Standards - systematic quality in all work"
  learning_axiom: "Disaster Report Learning - every failure becomes wisdom"
  harmony_axiom: "Divine Harmony Integration - all phases work together"
  
axiom_properties:
  independence: "Each axiom is logically independent"
  consistency: "No axioms contradict each other"
  completeness: "Axioms cover all fundamental system requirements"
  minimality: "No axiom derivable from others"
```

### 2. **Inference Rules (Application Logic)**
**MANDATORY**: Formal procedures for rule combination and application
```yaml
inference_rules:
  priority_hierarchy:
    tier_1_critical: "Safety, Security, Formal System Integrity"
    tier_2_foundation: "Core principles, Evidence requirements"
    tier_3_quality: "Excellence standards, Documentation"
    tier_4_optimization: "Performance, Efficiency improvements"
  
  combination_logic:
    sequential_application: "Higher tiers must be satisfied before lower tiers"
    parallel_opportunities: "Rules within same tier can apply simultaneously"
    dependency_resolution: "Prerequisites must be met before rule activation"
    conflict_resolution: "Higher priority rules override lower priority"
  
  completeness_validation:
    coverage_check: "Verify all applicable rules identified"
    application_verification: "Confirm all rules properly applied"
    evidence_collection: "Validate compliance with concrete evidence"
```

### 3. **Syntax (Rule Structure)**
**MANDATORY**: Standardized .mdc rule format
```yaml
mdc_syntax_requirements:
  header_section:
    description: "REQUIRED - Clear description of rule purpose"
    category: "REQUIRED - Logical categorization"
    priority: "REQUIRED - critical|high|medium|low"
    alwaysApply: "REQUIRED - boolean"
    globs: "REQUIRED - file patterns"
    tags: "REQUIRED - searchable tags array"
    tier: "REQUIRED - 1|2|3|4"
    enforcement: "OPTIONAL - blocking|warning|advisory"
    autoFix: "OPTIONAL - boolean"
    contexts: "OPTIONAL - context arrays"
  
  content_structure:
    title: "# Rule Name"
    criticality: "**CRITICAL/MANDATORY/IMPORTANT**: Brief statement"
    core_principle: "## Core Principle with memorable quote"
    requirements: "## Requirements with numbered items"
    implementation: "## Implementation with code examples"
    enforcement: "## Enforcement with validation criteria"
    benefits: "## Benefits with measurable outcomes"
```

### 4. **Semantics (Interpretation Framework)**
**MANDATORY**: Formal interpretation rules
```python
class FormalRuleSemantics:
    """
    Formal interpretation framework ensuring consistent rule meaning.
    """
    
    def interpret_rule_application(self, rule_mdc: str, context: dict) -> dict:
        """
        Formal interpretation of rule application in context.
        
        Args:
            rule_mdc: Path to .mdc rule file
            context: Current development context
            
        Returns:
            Formal interpretation with application guidance
        """
        rule_metadata = self._parse_mdc_header(rule_mdc)
        rule_content = self._parse_mdc_content(rule_mdc)
        
        interpretation = {
            "is_applicable": self._check_applicability(rule_metadata, context),
            "priority_level": rule_metadata.get("priority", "medium"),
            "enforcement_type": rule_metadata.get("enforcement", "advisory"),
            "auto_fix_available": rule_metadata.get("autoFix", False),
            "required_contexts": rule_metadata.get("contexts", ["ALL"]),
            "validation_criteria": self._extract_validation_criteria(rule_content),
            "success_metrics": self._extract_success_metrics(rule_content)
        }
        
        return interpretation
    
    def validate_rule_consistency(self, rule_set: list) -> dict:
        """
        Validate logical consistency across rule set.
        """
        consistency_check = {
            "is_consistent": True,
            "contradictions": [],
            "missing_dependencies": [],
            "circular_dependencies": []
        }
        
        # Check for logical contradictions
        for rule_a in rule_set:
            for rule_b in rule_set:
                if self._detect_contradiction(rule_a, rule_b):
                    consistency_check["contradictions"].append({
                        "rule_a": rule_a,
                        "rule_b": rule_b,
                        "conflict_type": self._classify_conflict(rule_a, rule_b)
                    })
                    consistency_check["is_consistent"] = False
        
        return consistency_check
```

### 5. **Systematic Application Algorithm**
**MANDATORY**: Formal rule application procedure
```python
def apply_formal_rule_system(task_context: dict) -> dict:
    """
    Systematic application of formal rule system.
    
    Args:
        task_context: Current task context and requirements
        
    Returns:
        Complete rule application result with evidence
    """
    application_result = {
        "applied_rules": [],
        "validation_results": [],
        "evidence_collected": [],
        "quality_score": 0,
        "completeness_verified": False
    }
    
    # PHASE 1: Rule Discovery
    applicable_rules = discover_applicable_rules(task_context)
    
    # PHASE 2: Priority Ordering
    prioritized_rules = sort_by_formal_hierarchy(applicable_rules)
    
    # PHASE 3: Conflict Resolution
    resolved_rules = resolve_conflicts_formally(prioritized_rules, task_context)
    
    # PHASE 4: Systematic Application
    for rule in resolved_rules:
        rule_result = apply_single_rule_with_validation(rule, task_context)
        application_result["applied_rules"].append(rule_result)
        
        # Validate before proceeding
        if not rule_result["validation_passed"]:
            return {
                "status": "FAILED",
                "failed_rule": rule,
                "errors": rule_result["validation_errors"]
            }
    
    # PHASE 5: Completeness Verification
    completeness = verify_complete_coverage(applicable_rules, application_result)
    application_result["completeness_verified"] = completeness["is_complete"]
    
    # PHASE 6: Evidence Collection
    evidence = collect_application_evidence(application_result)
    application_result["evidence_collected"] = evidence
    application_result["quality_score"] = calculate_quality_score(application_result)
    
    return application_result
```

### 6. **Consistency and Completeness Validation**
**MANDATORY**: Formal validation of system properties
```python
class FormalSystemValidator:
    """
    Validates formal properties of the entire rule system.
    """
    
    def validate_system_consistency(self) -> dict:
        """
        Validate entire rule system for logical consistency.
        """
        all_rules = self._load_all_mdc_rules()
        consistency_result = {
            "is_consistent": True,
            "total_rules": len(all_rules),
            "contradictions_found": 0,
            "contradiction_details": []
        }
        
        # Cross-validate all rule pairs
        for i, rule_a in enumerate(all_rules):
            for j, rule_b in enumerate(all_rules[i+1:], i+1):
                contradiction = self._detect_logical_contradiction(rule_a, rule_b)
                if contradiction:
                    consistency_result["contradictions_found"] += 1
                    consistency_result["contradiction_details"].append(contradiction)
                    consistency_result["is_consistent"] = False
        
        return consistency_result
    
    def validate_system_completeness(self, domain: str) -> dict:
        """
        Validate rule system completely covers development domain.
        """
        domain_requirements = self._get_domain_requirements(domain)
        rule_coverage = self._analyze_rule_coverage(domain_requirements)
        
        completeness_result = {
            "coverage_percentage": rule_coverage["percentage"],
            "is_complete": rule_coverage["percentage"] >= 95.0,
            "missing_areas": rule_coverage["gaps"],
            "recommendations": self._generate_completeness_recommendations(rule_coverage)
        }
        
        return completeness_result
```

## Active Integration Points

### 1. **Rule Creation Validation**
**AUTOMATIC**: Every new rule must pass formal validation
```yaml
rule_creation_requirements:
  syntax_validation: "Must conform to .mdc format specification"
  consistency_check: "Must not contradict existing rules"
  completeness_contribution: "Must address identified gaps"
  evidence_requirements: "Must include validation criteria"
```

### 2. **Rule Application Monitoring**
**CONTINUOUS**: Monitor rule application effectiveness
```yaml
application_monitoring:
  success_rate_tracking: "Measure rule application success rates"
  conflict_detection: "Identify emerging rule conflicts"
  performance_measurement: "Track application efficiency"
  coverage_analysis: "Ensure comprehensive rule coverage"
```

### 3. **System Evolution Management**
**SYSTEMATIC**: Formal system evolution procedures
```yaml
evolution_procedures:
  axiom_modification: "Requires formal proof of consistency preservation"
  inference_rule_addition: "Must preserve system completeness"
  syntax_updates: "Backward compatibility required"
  semantic_refinement: "Must improve interpretation clarity"
```

## Current Implementation Status

### ✅ **Successfully Implemented**
- Core axioms established in individual .mdc rules
- Priority hierarchy defined across rule tiers
- Enforcement mechanisms in place (blocking, autoFix)
- Context-aware rule application system

### 🔄 **Currently Integrating**
- Formal consistency validation across all rules
- Systematic completeness verification
- Evidence collection automation
- Quality score calculation

### 📋 **Next Implementation Steps**
1. **Rule Inventory Audit**: Catalog all existing .mdc rules in formal system
2. **Consistency Validation**: Run formal consistency check across all rules
3. **Completeness Analysis**: Identify and fill any coverage gaps
4. **Performance Optimization**: Optimize rule application efficiency

## Quality Assurance

### **Formal Properties Guaranteed**
- **Consistency**: No logical contradictions between rules
- **Completeness**: All development scenarios covered
- **Decidability**: Clear algorithms for all rule applications
- **Soundness**: Applied rules always produce valid results

### **Practical Benefits Delivered**
- **Systematic Clarity**: Eliminates guesswork in rule application
- **Cognitive Load Reduction**: Clear patterns and decision trees
- **Error Prevention**: Formal validation prevents rule violations
- **Quality Assurance**: Mathematical guarantees of correct application

## Enforcement

This rule is **TIER 1 CRITICAL** and **ALWAYS APPLIED** to:
- All rule system design and modification
- All new rule creation and validation
- All rule application and interpretation
- All system consistency and completeness verification

**Violations of formal system properties require immediate system halt and correction.**

## Benefits

### **Mathematical Rigor**
- Logical consistency guaranteed through formal validation
- Completeness ensured through systematic coverage analysis
- Decidability provided through clear application algorithms
- Soundness maintained through evidence-based validation

### **Practical Effectiveness**
- Faster rule application through systematic procedures
- Fewer errors through formal validation
- Complete coverage through systematic analysis
- Continuous improvement through formal evolution

### **Human Comprehension**
- Clear structure through standardized .mdc format
- Predictable behavior through formal semantics
- Easy learning through systematic organization
- Reliable guidance through validation criteria

## Remember

**"Every rule is part of a mathematical formal system."**

**"Consistency, completeness, and decidability are not optional."**

**"Formal systems enable both rigor and flexibility."**

**"Mathematical precision serves human understanding."**

This meta-rule ensures our entire rule system operates as a cohesive, mathematically sound, and practically effective formal system.