# Automated Commit and Restore Point Rule

**CRITICAL**: Always automatically commit and push tested, error-free work as restore points to maintain repository integrity and provide reliable backup points.

## Core Requirements

### 1. Automatic Commit Triggers
**MANDATORY**: Automatically commit when any of these conditions are met:
- **New Feature Implementation**: Complete, tested feature modules
- **Framework Foundation**: Core architectural components
- **Testing Framework**: Comprehensive testing systems
- **Documentation Updates**: Significant documentation changes
- **Bug Fixes**: Verified error corrections
- **Refactoring**: Clean, tested code improvements
- **Integration Points**: Working integration between components

### 2. Commit Quality Standards
**MANDATORY**: Only commit work that meets these criteria:
- **Tested**: All code has been executed and verified
- **Error-Free**: No syntax errors, runtime errors, or logical issues
- **Functional**: Code performs its intended purpose
- **Documented**: Proper documentation and comments included
- **Clean**: No temporary files, debug code, or sensitive data
- **Consistent**: Follows project coding standards and patterns

### 3. Commit Message Standards
**MANDATORY**: Use structured commit messages:
```bash
# Format: type: brief description
git commit -m "feat: Implement comprehensive prompt engineering framework - Task 3.2 foundation

- Add multi-layer testing framework (Unit, Integration, Performance, Quality, A/B, Regression)
- Support WorkflowMode enum for waterfall, agile_xp, adaptive_mixed
- Add comprehensive logging and error handling
- Include test scoring and validation logic
- Foundation for prompt optimization and lifecycle management

This establishes the core architecture for Task 3.2: Prompt Design and Optimization"
```

### 4. Commit Types
**MANDATORY**: Use appropriate commit types:
- **feat**: New features or major functionality
- **fix**: Bug fixes and error corrections
- **docs**: Documentation updates
- **refactor**: Code refactoring and improvements
- **test**: Test framework and test cases
- **chore**: Maintenance tasks and configuration
- **perf**: Performance improvements
- **ci**: CI/CD and build system changes

## Implementation Guidelines

### 1. Pre-Commit Validation
**MANDATORY**: Validate before committing:
```python
# Check for errors
try:
    # Execute the code
    result = await test_function()
    if result.success:
        # Ready for commit
        return True
except Exception as e:
    logger.error(f"Pre-commit validation failed: {e}")
    return False
```

### 2. File Selection
**MANDATORY**: Only commit relevant files:
- ✅ **Source code**: `.py` files with working functionality
- ✅ **Documentation**: `.md` files with updated content
- ✅ **Configuration**: `.json`, `.yaml`, `.toml` files
- ✅ **Tests**: Test files with passing tests
- ❌ **Temporary files**: `.tmp`, `.log`, `.cache` files
- ❌ **Sensitive data**: API keys, passwords, secrets
- ❌ **Build artifacts**: `__pycache__`, `.pyc` files

### 3. Automated Commit Process
**MANDATORY**: Follow this automated process:
```bash
# 1. Check repository status
git status

# 2. Add relevant files only
git add utils/prompt_engineering_framework.py
git add utils/prompt_optimizer.py

# 3. Create structured commit message
git commit -m "feat: Implement comprehensive prompt optimization system

- Add multi-strategy optimization (Template, Performance, A/B, ML, Context, Mode-specific)
- Integration with prompt testing framework
- Advanced optimization algorithms
- Performance tracking and analytics
- Mode-specific optimization strategies

This completes the core optimization framework for Task 3.2"

# 4. Push to remote repository
git push
```

### 4. Error Handling
**MANDATORY**: Handle commit failures gracefully:
```python
try:
    # Attempt commit
    subprocess.run(['git', 'commit', '-m', commit_message], check=True)
    subprocess.run(['git', 'push'], check=True)
    logger.info("Successfully committed and pushed changes")
except subprocess.CalledProcessError as e:
    logger.error(f"Commit failed: {e}")
    # Retry or notify user
except Exception as e:
    logger.error(f"Unexpected error during commit: {e}")
```

## Task-Specific Commit Rules

### 1. Task 3.2: Prompt Design and Optimization
**MANDATORY**: Commit after each major component:
- ✅ **Testing Framework**: After implementing multi-layer testing
- ✅ **Optimization Engine**: After implementing optimization strategies
- ✅ **Integration Layer**: After connecting testing and optimization
- ✅ **MCP Integration**: After implementing MCP server integration
- ✅ **Analytics System**: After implementing performance analytics

### 2. Framework Development
**MANDATORY**: Commit after each framework layer:
- ✅ **Core Framework**: After base framework implementation
- ✅ **Testing Layer**: After testing framework completion
- ✅ **Optimization Layer**: After optimization framework completion
- ✅ **Integration Layer**: After integration framework completion
- ✅ **Management Layer**: After management framework completion

### 3. Documentation Updates
**MANDATORY**: Commit after significant documentation:
- ✅ **Concept Papers**: After major concept paper updates
- ✅ **Architecture Docs**: After architecture documentation updates
- ✅ **Implementation Guides**: After implementation guide updates
- ✅ **API Documentation**: After API documentation updates

## Quality Assurance

### 1. Code Review Before Commit
**MANDATORY**: Review code before committing:
- [ ] Code follows project standards
- [ ] All functions are documented
- [ ] Error handling is implemented
- [ ] Logging is comprehensive
- [ ] No hardcoded values or secrets
- [ ] Tests are included where appropriate

### 2. Testing Before Commit
**MANDATORY**: Test before committing:
- [ ] Code executes without errors
- [ ] Basic functionality works
- [ ] Integration points are functional
- [ ] No regression issues
- [ ] Performance is acceptable

### 3. Cleanup Before Commit
**MANDATORY**: Clean up before committing:
- [ ] Remove temporary files
- [ ] Remove debug code
- [ ] Remove sensitive data
- [ ] Update .gitignore if needed
- [ ] Check for large files

## Repository Management

### 1. Branch Strategy
**MANDATORY**: Use appropriate branching:
- **main**: Production-ready code only
- **develop**: Integration branch for features
- **feature/task-3.2**: Feature branches for specific tasks
- **hotfix/**: Emergency fixes

### 2. Commit Frequency
**MANDATORY**: Commit frequency guidelines:
- **Small Changes**: Commit immediately after testing
- **Medium Changes**: Commit after component completion
- **Large Changes**: Commit after major milestone
- **Never**: Wait more than 2 hours without committing working code

### 3. Restore Point Strategy
**MANDATORY**: Create restore points:
- **Daily**: At least one commit per day with working code
- **Milestone**: After each major milestone completion
- **Integration**: After successful integration of components
- **Testing**: After comprehensive testing completion

## Automation Scripts

### 1. Pre-Commit Hook
**MANDATORY**: Implement pre-commit validation:
```python
#!/usr/bin/env python3
"""
Pre-commit hook for automated validation
"""
import subprocess
import sys
import os

def validate_code():
    """Validate code before commit"""
    try:
        # Run basic syntax check
        subprocess.run([sys.executable, '-m', 'py_compile', 'utils/prompt_engineering_framework.py'], check=True)
        subprocess.run([sys.executable, '-m', 'py_compile', 'utils/prompt_optimizer.py'], check=True)
        
        # Run basic tests
        subprocess.run([sys.executable, '-m', 'pytest', 'tests/unit/test_prompt_framework.py', '-v'], check=True)
        
        print("✅ Pre-commit validation passed")
        return True
    except subprocess.CalledProcessError as e:
        print(f"❌ Pre-commit validation failed: {e}")
        return False

if __name__ == "__main__":
    if not validate_code():
        sys.exit(1)
```

### 2. Automated Commit Script
**MANDATORY**: Implement automated commit script:
```python
#!/usr/bin/env python3
"""
Automated commit script for tested work
"""
import subprocess
import logging
from datetime import datetime

def auto_commit(commit_type: str, description: str, files: list):
    """Automatically commit tested work"""
    try:
        # Add files
        for file in files:
            subprocess.run(['git', 'add', file], check=True)
        
        # Create commit message
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        commit_message = f"{commit_type}: {description}\n\n- Automated commit at {timestamp}\n- Files: {', '.join(files)}"
        
        # Commit
        subprocess.run(['git', 'commit', '-m', commit_message], check=True)
        
        # Push
        subprocess.run(['git', 'push'], check=True)
        
        logging.info(f"✅ Successfully committed: {description}")
        return True
    except subprocess.CalledProcessError as e:
        logging.error(f"❌ Auto-commit failed: {e}")
        return False

# Usage example
# auto_commit("feat", "Implement prompt optimization framework", ["utils/prompt_optimizer.py"])
```

## Enforcement

### 1. Mandatory Compliance
**CRITICAL**: This rule is **ALWAYS APPLIED** and must be followed for:
- All code development
- All testing implementation
- All documentation updates
- All integration work
- All bug fixes

### 2. Quality Gates
**MANDATORY**: Code must pass these gates before commit:
- [ ] Syntax validation
- [ ] Basic functionality test
- [ ] Error handling verification
- [ ] Documentation completeness
- [ ] Code style compliance

### 3. Monitoring and Alerts
**MANDATORY**: Monitor commit quality:
- Track commit frequency
- Monitor commit message quality
- Alert on failed commits
- Report on repository health

## Benefits

- **Reliable Restore Points**: Always have working code to revert to
- **Clean Repository**: Maintain organized, clean codebase
- **Progress Tracking**: Clear history of development progress
- **Team Collaboration**: Reliable code sharing and integration
- **Quality Assurance**: Enforce code quality standards
- **Risk Mitigation**: Reduce risk of losing work

## Violations

**CRITICAL**: Violations of this rule require immediate remediation:
- Commit untested code: **FORBIDDEN**
- Commit code with errors: **FORBIDDEN**
- Commit without proper message: **FORBIDDEN**
- Commit sensitive data: **FORBIDDEN**
- Skip pre-commit validation: **FORBIDDEN**

**Remember**: Every commit should be a reliable restore point that can be safely deployed or shared with the team.
description:
globs:
alwaysApply: true
---
