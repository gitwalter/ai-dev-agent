#!/usr/bin/env python3
"""
Git Hooks Installation Script
============================

Automatically installs git hooks for enforcing automated git workflow compliance.
Prevents uncommitted work accumulation and ensures GitHub sync.

Usage:
    python scripts/install_git_hooks.py
"""

import os
import stat
import shutil
from pathlib import Path
import subprocess


class GitHooksInstaller:
    """Install and configure git hooks for workflow enforcement."""
    
    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self.hooks_dir = self.project_root / ".git" / "hooks"
        self.scripts_dir = self.project_root / "scripts" / "git_hooks"
        
    def install_all_hooks(self):
        """Install all git workflow enforcement hooks."""
        
        print("üîß **Installing Git Workflow Enforcement Hooks**")
        print("=" * 50)
        
        # Ensure hooks directory exists
        self.hooks_dir.mkdir(exist_ok=True)
        
        # Install each hook
        hooks_installed = 0
        
        # Pre-commit hook
        if self.install_pre_commit_hook():
            hooks_installed += 1
        
        # Post-commit hook
        if self.install_post_commit_hook():
            hooks_installed += 1
        
        # Pre-push hook
        if self.install_pre_push_hook():
            hooks_installed += 1
        
        print(f"\n‚úÖ **Installation Complete**: {hooks_installed} hooks installed")
        print("üéØ **Git workflow enforcement is now active**")
        
        return hooks_installed > 0
    
    def install_pre_commit_hook(self):
        """Install pre-commit hook for workflow validation."""
        
        hook_content = '''#!/bin/bash
# Pre-commit hook for git workflow enforcement
# Auto-generated by AI-Dev-Agent system

echo "üîç **PRE-COMMIT WORKFLOW VALIDATION**"

# Check for large commits (>15 files)
CHANGED_FILES=$(git diff --cached --name-only | wc -l)

if [ "$CHANGED_FILES" -gt 15 ]; then
    echo "‚ö†Ô∏è  **WARNING**: Large commit detected ($CHANGED_FILES files)"
    echo "üí° **RECOMMENDATION**: Consider breaking into logical commits"
    echo ""
    echo "Files being committed:"
    git diff --cached --name-only | head -20
    if [ "$CHANGED_FILES" -gt 20 ]; then
        echo "... and $(($CHANGED_FILES - 20)) more files"
    fi
    echo ""
    echo "ü§î **Continue with large commit? (y/N):**"
    read -r RESPONSE
    if [[ ! "$RESPONSE" =~ ^[Yy]$ ]]; then
        echo "‚ùå **Commit cancelled** - break into smaller commits"
        exit 1
    fi
fi

# Check for agile artifact updates
CODE_CHANGES=$(git diff --cached --name-only | grep -E "\\.(py|js|ts|java|cpp|c|h)$" | wc -l)
AGILE_CHANGES=$(git diff --cached --name-only | grep -E "docs/agile/" | wc -l)

if [ "$CODE_CHANGES" -gt 5 ] && [ "$AGILE_CHANGES" -eq 0 ]; then
    echo "üìã **AGILE REMINDER**: Significant code changes without agile updates"
    echo "üí° **CONSIDER**: Updating user stories or sprint documentation"
fi

# Check for test files with code changes
if [ "$CODE_CHANGES" -gt 0 ]; then
    TEST_CHANGES=$(git diff --cached --name-only | grep -E "test.*\\.(py|js|ts)$" | wc -l)
    if [ "$TEST_CHANGES" -eq 0 ]; then
        echo "üß™ **TEST REMINDER**: Code changes without test updates"
        echo "üí° **CONSIDER**: Adding or updating tests for new functionality"
    fi
fi

# Validate commit message length (if provided)
if [ -f ".git/COMMIT_EDITMSG" ]; then
    MSG_LENGTH=$(head -1 .git/COMMIT_EDITMSG | wc -c)
    if [ "$MSG_LENGTH" -lt 10 ]; then
        echo "üìù **MESSAGE WARNING**: Commit message seems very short"
        echo "üí° **RECOMMENDATION**: Use descriptive commit messages"
    fi
fi

echo "‚úÖ **Pre-commit validation complete**"
exit 0
'''
        
        hook_path = self.hooks_dir / "pre-commit"
        return self._write_hook(hook_path, hook_content, "pre-commit")
    
    def install_post_commit_hook(self):
        """Install post-commit hook for immediate push reminder."""
        
        hook_content = '''#!/bin/bash
# Post-commit hook for git workflow enforcement
# Auto-generated by AI-Dev-Agent system

echo "üéâ **COMMIT SUCCESSFUL**"

# Check if we have unpushed commits
UNPUSHED=$(git log --oneline @{u}..HEAD 2>/dev/null | wc -l)

if [ "$UNPUSHED" -gt 0 ]; then
    echo "üì§ **PUSH REMINDER**: $UNPUSHED unpushed commit(s)"
    echo "üí° **RECOMMENDATION**: Push to GitHub for backup and collaboration"
    echo "   Command: git push"
    
    # Auto-push for small commits (if configured)
    if [ "$UNPUSHED" -eq 1 ] && [ "$AI_DEV_AGENT_AUTO_PUSH" = "true" ]; then
        echo "üöÄ **AUTO-PUSHING**: Single commit detected"
        git push
        if [ $? -eq 0 ]; then
            echo "‚úÖ **AUTO-PUSH SUCCESSFUL**"
        else
            echo "‚ùå **AUTO-PUSH FAILED**: Manual push required"
        fi
    fi
fi

exit 0
'''
        
        hook_path = self.hooks_dir / "post-commit"
        return self._write_hook(hook_path, hook_content, "post-commit")
    
    def install_pre_push_hook(self):
        """Install pre-push hook for final validation."""
        
        hook_content = '''#!/bin/bash
# Pre-push hook for git workflow enforcement
# Auto-generated by AI-Dev-Agent system

echo "üöÄ **PRE-PUSH VALIDATION**"

# Check working directory is clean
if ! git diff-index --quiet HEAD --; then
    echo "‚ö†Ô∏è  **WARNING**: Uncommitted changes detected"
    echo "üìã **STATUS**:"
    git status --porcelain
    echo ""
    echo "üí° **RECOMMENDATION**: Commit changes before pushing"
    echo "ü§î **Continue with uncommitted changes? (y/N):**"
    read -r RESPONSE
    if [[ ! "$RESPONSE" =~ ^[Yy]$ ]]; then
        echo "‚ùå **Push cancelled** - commit changes first"
        exit 1
    fi
fi

# Get commits being pushed
LOCAL_REF=$1
REMOTE_REF=$2

if [ "$LOCAL_REF" != "refs/heads/main" ] && [ "$LOCAL_REF" != "refs/heads/master" ]; then
    echo "üåø **BRANCH PUSH**: Pushing to branch $(echo $LOCAL_REF | sed 's|refs/heads/||')"
fi

COMMITS_TO_PUSH=$(git rev-list --count $REMOTE_REF..$LOCAL_REF 2>/dev/null || echo "unknown")

if [ "$COMMITS_TO_PUSH" != "unknown" ]; then
    echo "üìä **PUSH SUMMARY**: $COMMITS_TO_PUSH commit(s) being pushed"
    
    if [ "$COMMITS_TO_PUSH" -gt 10 ]; then
        echo "‚ö†Ô∏è  **LARGE PUSH**: $COMMITS_TO_PUSH commits"
        echo "üí° **INFO**: Consider more frequent pushes for collaboration"
    fi
fi

echo "‚úÖ **Pre-push validation complete**"
exit 0
'''
        
        hook_path = self.hooks_dir / "pre-push"
        return self._write_hook(hook_path, hook_content, "pre-push")
    
    def _write_hook(self, hook_path, content, hook_name):
        """Write hook file and make it executable."""
        
        try:
            # Write hook content
            hook_path.write_text(content)
            
            # Make executable
            current_permissions = hook_path.stat().st_mode
            hook_path.chmod(current_permissions | stat.S_IEXEC)
            
            print(f"‚úÖ Installed {hook_name} hook: {hook_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to install {hook_name} hook: {e}")
            return False
    
    def uninstall_hooks(self):
        """Uninstall git workflow hooks."""
        
        print("üóëÔ∏è  **Uninstalling Git Workflow Hooks**")
        
        hooks_to_remove = ["pre-commit", "post-commit", "pre-push"]
        removed_count = 0
        
        for hook_name in hooks_to_remove:
            hook_path = self.hooks_dir / hook_name
            if hook_path.exists():
                try:
                    hook_path.unlink()
                    print(f"‚úÖ Removed {hook_name} hook")
                    removed_count += 1
                except Exception as e:
                    print(f"‚ùå Failed to remove {hook_name} hook: {e}")
        
        print(f"üìä **Uninstall Complete**: {removed_count} hooks removed")
        return removed_count > 0
    
    def check_git_repository(self):
        """Check if we're in a git repository."""
        
        if not (self.project_root / ".git").exists():
            print("‚ùå **Error**: Not in a git repository")
            print("üí° **Solution**: Run 'git init' to initialize repository")
            return False
        
        return True
    
    def configure_auto_push(self, enable=True):
        """Configure automatic push after single commits."""
        
        if enable:
            print("üîß **Enabling auto-push for single commits**")
            subprocess.run([
                "git", "config", "ai-dev-agent.auto-push", "true"
            ])
            # Set environment variable
            os.environ["AI_DEV_AGENT_AUTO_PUSH"] = "true"
        else:
            print("üîß **Disabling auto-push**")
            subprocess.run([
                "git", "config", "--unset", "ai-dev-agent.auto-push"
            ])
            if "AI_DEV_AGENT_AUTO_PUSH" in os.environ:
                del os.environ["AI_DEV_AGENT_AUTO_PUSH"]


def main():
    """Main installation function."""
    
    installer = GitHooksInstaller()
    
    if not installer.check_git_repository():
        return False
    
    print("üéØ **AI-Dev-Agent Git Workflow Enforcement**")
    print("==========================================")
    print()
    print("This will install hooks to:")
    print("‚Ä¢ Validate commits before they're made")
    print("‚Ä¢ Remind about pushes after commits")
    print("‚Ä¢ Prevent large uncommitted work accumulation")
    print("‚Ä¢ Ensure agile artifacts stay updated")
    print()
    
    # Install hooks
    success = installer.install_all_hooks()
    
    if success:
        print()
        print("üîß **Configuration Options**")
        print("Would you like to enable auto-push for single commits? (y/N):")
        
        # For automated installation, default to no
        # In interactive mode, could read user input
        enable_auto_push = False  # Default to conservative
        
        installer.configure_auto_push(enable_auto_push)
        
        print()
        print("üéâ **Installation Complete!**")
        print("Git workflow enforcement is now active.")
        print()
        print("üìã **What happens now:**")
        print("‚Ä¢ Pre-commit: Validates commit size and content")
        print("‚Ä¢ Post-commit: Reminds about pushing to GitHub") 
        print("‚Ä¢ Pre-push: Final validation before push")
        print()
        print("üí° **To uninstall**: python scripts/install_git_hooks.py --uninstall")
        
    return success


if __name__ == "__main__":
    import sys
    
    if "--uninstall" in sys.argv:
        installer = GitHooksInstaller()
        installer.uninstall_hooks()
    else:
        main()
