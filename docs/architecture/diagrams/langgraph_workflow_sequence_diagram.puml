@startuml LangGraph Workflow System - Sequence Diagram

skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true
skinparam maxMessageSize 150

actor User
participant "LangGraphWorkflowManager" as WFM
participant "StateGraph" as SG
participant "MemoryManager" as MM
participant "HandoffManager" as HM
participant "AgentNodeFactory" as ANF
participant "WorkflowNode" as WN
participant "ChatGoogleGenerativeAI" as LLM
participant "Chroma Vector Store" as CVS
participant "ErrorHandler" as EH
participant "QualityGate" as QG

User -> WFM: execute_workflow(project_context)
activate WFM

WFM -> WFM: _setup_llm()
WFM -> WFM: _create_workflow()
activate WFM

WFM -> SG: StateGraph(AgentState)
activate SG

WFM -> ANF: create_requirements_node(llm)
activate ANF
ANF -> WN: new WorkflowNode("requirements_analysis")
activate WN
ANF --> WFM: requirements_node_function
deactivate ANF

WFM -> SG: add_node("requirements_analysis", node_func)
WFM -> SG: add_node("architecture_design", node_func)
WFM -> SG: add_node("code_generation", node_func)
WFM -> SG: add_node("test_generation", node_func)
WFM -> SG: add_node("code_review", node_func)
WFM -> SG: add_node("security_analysis", node_func)
WFM -> SG: add_node("documentation_generation", node_func)

WFM -> SG: add_edge("requirements_analysis", "architecture_design")
WFM -> SG: add_edge("architecture_design", "code_generation")
WFM -> SG: add_edge("code_generation", "test_generation")
WFM -> SG: add_edge("test_generation", "code_review")
WFM -> SG: add_edge("code_review", "security_analysis")
WFM -> SG: add_edge("security_analysis", "documentation_generation")

WFM -> SG: compile(checkpointer=MemorySaver())
SG --> WFM: compiled_workflow
deactivate SG

WFM -> WFM: create_initial_state(project_context)
WFM -> MM: __init__(user_id="default")
activate MM
MM -> CVS: Chroma(persist_directory, embedding_function)
activate CVS
CVS --> MM: vector_store
deactivate CVS
MM --> WFM: memory_manager
deactivate MM

WFM -> HM: __init__()
activate HM
HM --> WFM: handoff_manager
deactivate HM

WFM -> SG: invoke(initial_state)
activate SG

' Requirements Analysis Phase
SG -> WN: execute(state)
activate WN

WN -> MM: search_recall_memories("requirements analysis", k=5)
activate MM
MM -> CVS: similarity_search_with_relevance_scores(query, k=5)
activate CVS
CVS --> MM: relevant_memories
deactivate CVS
MM --> WN: memory_context
deactivate MM

WN -> WN: create_memory_context(state, query, k=5)
WN -> LLM: invoke(enhanced_prompt_with_memory)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> WN: parse_response(response)
WN -> MM: save_recall_memory(agent_output, context)
activate MM
MM -> CVS: add_documents([document])
activate CVS
CVS --> MM: memory_id
deactivate CVS
MM --> WN: memory_id
deactivate MM

WN -> MM: extract_knowledge_triples(agent_output)
activate MM
MM -> LLM: ainvoke(extraction_prompt)
activate LLM
LLM --> MM: triples_response
deactivate LLM
MM -> MM: parse_triples(response)
MM --> WN: knowledge_triples
deactivate MM

WN -> QG: validate_agent_output(output, "requirements_analyst")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_requirements
deactivate WN

' Architecture Design Phase
SG -> WN: execute(state)
activate WN

WN -> HM: validate_handoff_request(handoff, state)
activate HM
HM --> WN: validation_result
deactivate HM

WN -> LLM: invoke(architecture_prompt)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> QG: validate_agent_output(output, "architecture_designer")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_architecture
deactivate WN

' Code Generation Phase
SG -> WN: execute(state)
activate WN

WN -> HM: suggest_alternative_agents("code generation")
activate HM
HM --> WN: agent_suggestions
deactivate HM

WN -> LLM: invoke(code_generation_prompt)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> QG: validate_agent_output(output, "code_generator")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_code
deactivate WN

' Test Generation Phase
SG -> WN: execute(state)
activate WN

WN -> LLM: invoke(test_generation_prompt)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> QG: validate_agent_output(output, "test_generator")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_tests
deactivate WN

' Code Review Phase
SG -> WN: execute(state)
activate WN

WN -> LLM: invoke(code_review_prompt)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> QG: validate_agent_output(output, "code_reviewer")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_review
deactivate WN

' Security Analysis Phase
SG -> WN: execute(state)
activate WN

WN -> LLM: invoke(security_analysis_prompt)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> QG: validate_agent_output(output, "security_analyst")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_security
deactivate WN

' Documentation Generation Phase
SG -> WN: execute(state)
activate WN

WN -> LLM: invoke(documentation_prompt)
activate LLM
LLM --> WN: llm_response
deactivate LLM

WN -> QG: validate_agent_output(output, "documentation_generator")
activate QG
QG --> WN: validation_result
deactivate QG

WN --> SG: updated_state_with_documentation
deactivate WN

' Workflow Completion
SG -> QG: validate_workflow_state(final_state)
activate QG
QG --> SG: workflow_validation_result
deactivate QG

SG --> WFM: final_state
deactivate SG

WFM -> MM: get_memory_stats()
activate MM
MM --> WFM: memory_statistics
deactivate MM

WFM -> HM: process_handoff_queue(final_state)
activate HM
HM --> WFM: state_with_processed_handoffs
deactivate HM

WFM --> User: complete_project_artifacts
deactivate WFM

@enduml
