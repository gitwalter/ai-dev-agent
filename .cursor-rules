# Auto-reload trigger: 1756992089
# Context-Aware Rules (Working System)
# Context: DEFAULT
# Total Rules: 6
# Generated from: General development work...
# Timestamp: 04.09.2025 15:21


# === safety_first_principle ===
---
alwaysApply: true
autoFix: true
category: foundational-axiomatic
contexts:
- ALL
dependencies: []
description: Safety First Principle - axiomatic layer rule
enforcement: blocking
formalLayer: axiomatic
globs:
- '**/*'
languageGames:
- safety_consensus_building
- harm_prevention
linguisticFramework: foundational
logicalType: 0
priority: critical
tags:
- axiomatic
- foundational
- type_0
- priority_1
- safety_consensus_building
- harm_prevention
tier: '1'
---

# Safety First Principle

**CRITICAL**: Always prioritize safety over speed, convenience, or automation. If we shoot ourselves in the foot, we are not efficient.

## Core Principle

**"Safety First, Efficiency Second"**

Every development decision, automation, script, or process must be evaluated for safety before implementation. The cost of fixing disasters far exceeds the time saved by unsafe shortcuts.

## Safety Requirements

### 1. **No Automatic File Moving**
**MANDATORY**: Never automatically move, rename, or delete files without explicit human approval
```python
# FORBIDDEN: Automatic file operations
def organize_files():
    for file in files:
        move_file(file, new_location)  # DANGEROUS

# REQUIRED: Safe validation only
def validate_file_organization():
    issues = find_organization_issues()
    return generate_fix_suggestions(issues)  # SAFE
```

### 2. **No Destructive Operations**
**MANDATORY**: All destructive operations must require explicit confirmation
```python
# FORBIDDEN: Silent destructive operations
def cleanup():
    delete_all_temp_files()  # DANGEROUS

# REQUIRED: Safe with confirmation
def safe_cleanup():
    temp_files = find_temp_files()
    if confirm_deletion(temp_files):
        delete_files(temp_files)
    else:
        print("Cleanup cancelled - safety first")
```

### 3. **Validation Before Action**
**MANDATORY**: Always validate before taking any action
```python
# REQUIRED: Validate first
def safe_operation():
    # 1. Validate current state
    if not validate_current_state():
        raise SafetyException("Invalid state detected")
    
    # 2. Check prerequisites
    if not check_prerequisites():
        raise SafetyException("Prerequisites not met")
    
    # 3. Perform operation
    perform_operation()
    
    # 4. Validate result
    if not validate_result():
        raise SafetyException("Operation failed validation")
```

### 4. **Rollback Capability**
**MANDATORY**: Every operation must have a clear rollback path
```python
# REQUIRED: Always provide rollback
def safe_database_update():
    # 1. Create backup
    backup = create_backup()
    
    # 2. Perform update
    try:
        perform_update()
        validate_update()
    except Exception as e:
        # 3. Rollback on failure
        rollback_from_backup(backup)
        raise SafetyException(f"Update failed, rolled back: {e}")
```

### 5. **Platform-Safe Commands**
**MANDATORY**: Always use platform-appropriate commands to prevent system failures
```python
import platform

# REQUIRED: Platform detection and safe commands
def get_safe_command(operation: str) -> str:
    """Get platform-safe command."""
    system = platform.system()
    
    if system == "Windows":
        commands = {
            "list_files": "Get-ChildItem",
            "test_file": "Test-Path",
            "read_file": "Get-Content",
            "search_text": "Select-String"
        }
    else:  # Linux/macOS
        commands = {
            "list_files": "ls",
            "test_file": "test -f",
            "read_file": "cat", 
            "search_text": "grep"
        }
    
    return commands.get(operation, operation)

# FORBIDDEN: Using wrong platform commands
def unsafe_command():
    subprocess.run("ls utils/*.py")  # FAILS on Windows
    
# REQUIRED: Platform-safe commands
def safe_command():
    system = platform.system()
    if system == "Windows":
        cmd = "Get-ChildItem -Path 'utils' -Filter '*.py'"
    else:
        cmd = "ls utils/*.py"
    subprocess.run(cmd, shell=True)
```

### 6. **Safe Git Operations**
**MANDATORY**: Use safe git patterns with validation and rollback capability
```python
# REQUIRED: Safe git workflow with validation
def safe_git_commit_and_push(commit_message: str):
    """Safe git operations with validation and rollback."""
    try:
        # 1. Validate working directory state
        status_result = subprocess.run(['git', 'status', '--porcelain'], 
                                     capture_output=True, text=True)
        if not status_result.stdout.strip():
            print("No changes to commit")
            return False
        
        # 2. Safe three-command sequence
        subprocess.run(['git', 'add', '.'], check=True)
        subprocess.run(['git', 'commit', '-m', commit_message], check=True)
        subprocess.run(['git', 'push'], check=True)
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"Git operation failed: {e}")
        # Allow user to decide recovery action
        return False

# FORBIDDEN: Destructive git operations without confirmation
def unsafe_git_reset():
    subprocess.run(['git', 'reset', '--hard', 'HEAD~1'])  # DANGEROUS

# REQUIRED: Safe git operations with confirmation
def safe_git_reset():
    print("⚠️  WARNING: This will discard uncommitted changes")
    confirmation = input("Type 'YES' to confirm git reset: ")
    if confirmation == "YES":
        subprocess.run(['git', 'reset', '--hard', 'HEAD~1'])
    else:
        print("Git reset cancelled - safety first")
```

## Safety Patterns

### 1. **Read-Only by Default**
```python
# REQUIRED: Start with read-only operations
def safe_analysis():
    # Read and analyze only
    data = read_data()
    analysis = analyze_data(data)
    return generate_report(analysis)  # No modifications
```

### 2. **Dry-Run Mode**
```python
# REQUIRED: Always support dry-run
def safe_operation(dry_run=True):
    if dry_run:
        return simulate_operation()
    else:
        return perform_actual_operation()
```

### 3. **Explicit Confirmation**
```python
# REQUIRED: Always require explicit confirmation for dangerous operations
def dangerous_operation():
    print("⚠️  WARNING: This operation will delete files")
    print("Files to be deleted:", list_files_to_delete())
    
    confirmation = input("Type 'YES' to confirm: ")
    if confirmation != "YES":
        print("Operation cancelled - safety first")
        return False
    
    return perform_deletion()
```

## Safety Checklist

Before any operation, verify:

- [ ] **No automatic file moving/deletion**
- [ ] **Destructive operations require explicit confirmation**
- [ ] **Validation performed before action**
- [ ] **Rollback path exists**
- [ ] **Dry-run mode available**
- [ ] **Read-only analysis first**
- [ ] **Explicit confirmation for dangerous operations**
- [ ] **Platform-appropriate commands used (Windows vs Unix)**
- [ ] **Git operations validated before execution**
- [ ] **Safe git workflow: add, commit, push sequence**

## Implementation Examples

### Safe File Operations
```python
def safe_file_operation():
    # 1. Analyze current state
    current_files = scan_directory()
    
    # 2. Generate recommendations (read-only)
    recommendations = analyze_file_organization(current_files)
    
    # 3. Present options to user
    print("File organization recommendations:")
    for rec in recommendations:
        print(f"- {rec}")
    
    # 4. Wait for explicit approval
    if user_approves():
        perform_approved_operations()
    else:
        print("Operation cancelled - safety first")
```

### Safe Database Operations
```python
def safe_database_operation():
    # 1. Create backup
    backup = create_database_backup()
    
    # 2. Validate operation
    if not validate_operation_parameters():
        raise SafetyException("Invalid parameters")
    
    # 3. Perform operation with rollback
    try:
        result = perform_database_operation()
        validate_result(result)
        return result
    except Exception as e:
        rollback_from_backup(backup)
        raise SafetyException(f"Operation failed: {e}")
```

## Safety Enforcement

This rule is **ALWAYS ACTIVE** and applies to:

- All file operations
- All database operations
- All system modifications
- All automation scripts
- All deployment operations
- All configuration changes
- **All shell commands and terminal operations**
- **All git operations and version control**

### **Platform Command Safety**
**MANDATORY**: Always use correct commands for the target platform

**Windows Systems**: Use PowerShell commands
- `Get-ChildItem` instead of `ls`
- `Test-Path` instead of `test -f`
- `Get-Content` instead of `cat`
- `Select-String` instead of `grep`

**Unix/Linux Systems**: Use bash/shell commands
- `ls`, `cat`, `grep`, `test` work as expected

### **Git Operation Safety**
**MANDATORY**: Always use safe git patterns

**Safe Git Workflow**: Always use validated sequence
- `git add .` (stage all changes)
- `git commit -m "message"` (commit with descriptive message)
- `git push` (push to remote)

**Destructive Git Operations**: Require explicit confirmation
- `git reset --hard` (discards changes)
- `git rebase -i` (rewrites history)
- `git force push` (overwrites remote)

**Remember**: It's better to be slow and safe than fast and sorry. Safety first, always.



# === intelligent_context_aware_rule_system ===
# Rule not found: intelligent_context_aware_rule_system
Rule file missing or unreadable.


# === core_rule_application_framework ===
# Rule not found: core_rule_application_framework
Rule file missing or unreadable.


# === user_controlled_success_declaration_rule ===
# Rule not found: user_controlled_success_declaration_rule
Rule file missing or unreadable.


# === scientific_communication_rule ===
# Rule not found: scientific_communication_rule
Rule file missing or unreadable.


# === streamlined_git_operations_rule ===
# Rule not found: streamlined_git_operations_rule
Rule file missing or unreadable.

