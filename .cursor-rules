# Auto-reload trigger: 1756830044
# Context-Aware Rules (Working System)
# Context: DOCUMENTATION
# Total Rules: 7
# Generated from: @docs history test...
# Timestamp: 02.09.2025 18:20


# === safety_first_principle ===
---
alwaysApply: true
autoFix: true
category: foundational-axiomatic
contexts:
- ALL
dependencies: []
description: Safety First Principle - axiomatic layer rule
enforcement: blocking
formalLayer: axiomatic
globs:
- '**/*'
languageGames:
- safety_consensus_building
- harm_prevention
linguisticFramework: foundational
logicalType: 0
priority: critical
tags:
- axiomatic
- foundational
- type_0
- priority_1
- safety_consensus_building
- harm_prevention
tier: '1'
---

# Safety First Principle

**CRITICAL**: Always prioritize safety over speed, convenience, or automation. If we shoot ourselves in the foot, we are not efficient.

## Core Principle

**"Safety First, Efficiency Second"**

Every development decision, automation, script, or process must be evaluated for safety before implementation. The cost of fixing disasters far exceeds the time saved by unsafe shortcuts.

## Safety Requirements

### 1. **No Automatic File Moving**
**MANDATORY**: Never automatically move, rename, or delete files without explicit human approval
```python
# FORBIDDEN: Automatic file operations
def organize_files():
    for file in files:
        move_file(file, new_location)  # DANGEROUS

# REQUIRED: Safe validation only
def validate_file_organization():
    issues = find_organization_issues()
    return generate_fix_suggestions(issues)  # SAFE
```

### 2. **No Destructive Operations**
**MANDATORY**: All destructive operations must require explicit confirmation
```python
# FORBIDDEN: Silent destructive operations
def cleanup():
    delete_all_temp_files()  # DANGEROUS

# REQUIRED: Safe with confirmation
def safe_cleanup():
    temp_files = find_temp_files()
    if confirm_deletion(temp_files):
        delete_files(temp_files)
    else:
        print("Cleanup cancelled - safety first")
```

### 3. **Validation Before Action**
**MANDATORY**: Always validate before taking any action
```python
# REQUIRED: Validate first
def safe_operation():
    # 1. Validate current state
    if not validate_current_state():
        raise SafetyException("Invalid state detected")
    
    # 2. Check prerequisites
    if not check_prerequisites():
        raise SafetyException("Prerequisites not met")
    
    # 3. Perform operation
    perform_operation()
    
    # 4. Validate result
    if not validate_result():
        raise SafetyException("Operation failed validation")
```

### 4. **Rollback Capability**
**MANDATORY**: Every operation must have a clear rollback path
```python
# REQUIRED: Always provide rollback
def safe_database_update():
    # 1. Create backup
    backup = create_backup()
    
    # 2. Perform update
    try:
        perform_update()
        validate_update()
    except Exception as e:
        # 3. Rollback on failure
        rollback_from_backup(backup)
        raise SafetyException(f"Update failed, rolled back: {e}")
```

## Safety Patterns

### 1. **Read-Only by Default**
```python
# REQUIRED: Start with read-only operations
def safe_analysis():
    # Read and analyze only
    data = read_data()
    analysis = analyze_data(data)
    return generate_report(analysis)  # No modifications
```

### 2. **Dry-Run Mode**
```python
# REQUIRED: Always support dry-run
def safe_operation(dry_run=True):
    if dry_run:
        return simulate_operation()
    else:
        return perform_actual_operation()
```

### 3. **Explicit Confirmation**
```python
# REQUIRED: Always require explicit confirmation for dangerous operations
def dangerous_operation():
    print("⚠️  WARNING: This operation will delete files")
    print("Files to be deleted:", list_files_to_delete())
    
    confirmation = input("Type 'YES' to confirm: ")
    if confirmation != "YES":
        print("Operation cancelled - safety first")
        return False
    
    return perform_deletion()
```

## Safety Checklist

Before any operation, verify:

- [ ] **No automatic file moving/deletion**
- [ ] **Destructive operations require explicit confirmation**
- [ ] **Validation performed before action**
- [ ] **Rollback path exists**
- [ ] **Dry-run mode available**
- [ ] **Read-only analysis first**
- [ ] **Explicit confirmation for dangerous operations**

## Implementation Examples

### Safe File Operations
```python
def safe_file_operation():
    # 1. Analyze current state
    current_files = scan_directory()
    
    # 2. Generate recommendations (read-only)
    recommendations = analyze_file_organization(current_files)
    
    # 3. Present options to user
    print("File organization recommendations:")
    for rec in recommendations:
        print(f"- {rec}")
    
    # 4. Wait for explicit approval
    if user_approves():
        perform_approved_operations()
    else:
        print("Operation cancelled - safety first")
```

### Safe Database Operations
```python
def safe_database_operation():
    # 1. Create backup
    backup = create_database_backup()
    
    # 2. Validate operation
    if not validate_operation_parameters():
        raise SafetyException("Invalid parameters")
    
    # 3. Perform operation with rollback
    try:
        result = perform_database_operation()
        validate_result(result)
        return result
    except Exception as e:
        rollback_from_backup(backup)
        raise SafetyException(f"Operation failed: {e}")
```

## Safety Enforcement

This rule is **ALWAYS ACTIVE** and applies to:

- All file operations
- All database operations
- All system modifications
- All automation scripts
- All deployment operations
- All configuration changes

**Remember**: It's better to be slow and safe than fast and sorry. Safety first, always.



# === intelligent_context_aware_rule_system ===
---
description: "Intelligent context-aware rule selection system that automatically detects development context and applies only relevant rules"
category: "core-foundation"
priority: "critical"
alwaysApply: false
globs: ["**/*"]
tags: ['core_foundation', 'context_awareness', 'rule_selection']
tier: "1"
---


# Intelligent Context-Aware Rule System

**CRITICAL**: Automatically select and apply only the most relevant rules based on current development context, reducing cognitive overhead while maintaining excellence standards. This system serves as the foundation for future agent swarm coordination.

## Description

This rule implements intelligent, context-aware rule selection that automatically detects development context and applies only the most relevant rules. It reduces the active rule set from 39+ rules to 6-10 focused rules per session, achieving 75-85% efficiency improvement while maintaining quality standards.

**Agent Swarm Foundation**: This system serves as the prototype for future agent swarm coordination, where context detection becomes agent selection and rule sets become agent behavioral DNA.

## Core Requirements

### 1. **Dual Context Detection System**
**MANDATORY**: Support both automatic detection and explicit user control

```yaml
context_detection_modes:
  automatic_detection:
    method: "Pattern matching on user queries, files, and directory context"
    confidence_threshold: 0.7
    fallback: "DEFAULT mode if confidence < threshold"
    
  explicit_control:
    method: "Keyword-based user intention signaling"
    priority: "Always overrides automatic detection"
    format: "@keyword at start of user message"
    
  hybrid_approach:
    - "Check for explicit keywords first"
    - "Fall back to automatic detection if no keywords"
    - "Provide transparency on detection method used"
```

### 2. **Context Categories and Rule Sets**
**MANDATORY**: Predefined contexts with optimized rule sets

```yaml
context_categories:
  DEFAULT:
    keywords: ["@default", "@all", "(no keyword)"]
    auto_detect: ["general", "unclear", "mixed"]
    rules: ["safety_first", "no_premature_victory", "boyscout", "context_awareness", "philosophy_separation"]
    agent_future: "GeneralCoordinatorAgent"
    
  CODING:
    keywords: ["@code", "@implement", "@build", "@develop"]
    auto_detect: ["implement", "code", "function", "class", "*.py", "*.js", "*.ts", "src/"]
    rules: ["safety_first", "tdd", "clean_code", "error_handling", "boyscout", "live_documentation"]
    agent_future: "DeveloperAgent"
    
  ARCHITECTURE:
    keywords: ["@design", "@architecture", "@system", "@structure"]
    auto_detect: ["architecture", "design", "system", "structure", "pattern", "docs/architecture/"]
    rules: ["safety_first", "foundational_development", "systematic_construction", "documentation_excellence", "technical_precision"]
    agent_future: "ArchitectAgent"
    
  DEBUGGING:
    keywords: ["@debug", "@troubleshoot", "@fix", "@solve"]
    auto_detect: ["debug", "error", "bug", "issue", "problem", "failing", "logs/"]
    rules: ["safety_first", "systematic_problem_solving", "no_silent_errors", "error_exposure", "test_monitoring"]
    agent_future: "DebuggingAgent"
    
  TESTING:
    keywords: ["@test", "@testing", "@qa", "@validate"]
    auto_detect: ["test", "testing", "*test*.py", "pytest", "unittest", "tests/"]
    rules: ["safety_first", "tdd", "test_monitoring", "no_failing_tests", "test_coverage", "quality_validation"]
    agent_future: "QAAgent"
    
  AGILE:
    keywords: ["@agile", "@sprint", "@story", "@backlog"]
    auto_detect: ["sprint", "backlog", "story", "agile", "scrum", "docs/agile/"]
    rules: ["safety_first", "agile_artifacts_maintenance", "live_documentation_updates", "sprint_management", "user_story_management"]
    agent_future: "ScrumMasterAgent"
    
  GIT_OPERATIONS:
    keywords: ["@git", "@commit", "@push", "@merge"]
    auto_detect: ["git", "commit", "push", "merge", "pull request", "PR", ".git/"]
    rules: ["safety_first", "automated_git_protection", "clean_commit_messages", "merge_validation", "deployment_safety"]
    agent_future: "DevOpsAgent"
    
  DOCUMENTATION:
    keywords: ["@docs", "@document", "@readme", "@guide"]
    auto_detect: ["document", "docs", "readme", "guide", "manual", "*.md", "docs/"]
    rules: ["safety_first", "documentation_excellence", "live_documentation_updates", "clear_communication", "user_experience"]
    agent_future: "TechnicalWriterAgent"
    
  PERFORMANCE:
    keywords: ["@optimize", "@performance", "@benchmark", "@speed"]
    auto_detect: ["optimize", "performance", "speed", "efficiency", "benchmark", "profiling"]
    rules: ["safety_first", "performance_monitoring", "benchmark_validation", "optimization_validation", "scalability_testing"]
    agent_future: "PerformanceAgent"
    
  SECURITY:
    keywords: ["@security", "@secure", "@vulnerability", "@audit"]
    auto_detect: ["security", "secure", "vulnerability", "auth", "encryption", "audit"]
    rules: ["safety_first", "security_vulnerability_assessment", "secure_coding", "penetration_testing", "compliance_validation"]
    agent_future: "SecurityAgent"
```

### 3. **Context Detection Algorithm**
**MANDATORY**: Simple, reliable pattern matching

```python
def detect_context(user_message, open_files, current_directory):
    """
    Detect development context using dual detection system.
    
    Args:
        user_message: User's input message
        open_files: List of currently open files
        current_directory: Current working directory
        
    Returns:
        ContextResult with detected context and confidence
    """
    
    # Step 1: Check for explicit keywords (highest priority)
    explicit_context = check_explicit_keywords(user_message)
    if explicit_context:
        return ContextResult(
            context=explicit_context,
            method="explicit_keyword",
            confidence=1.0,
            reasoning=f"User specified {explicit_context} with keyword"
        )
    
    # Step 2: Automatic detection using pattern matching
    context_scores = {}
    
    # Analyze user message
    message_lower = user_message.lower()
    for context, config in CONTEXT_CATEGORIES.items():
        score = 0
        for pattern in config["auto_detect"]:
            if pattern in message_lower:
                score += 2
        context_scores[context] = score
    
    # Analyze open files
    for file_path in open_files:
        for context, config in CONTEXT_CATEGORIES.items():
            for pattern in config["auto_detect"]:
                if pattern in file_path.lower():
                    context_scores[context] += 1
    
    # Analyze directory context
    dir_lower = current_directory.lower()
    for context, config in CONTEXT_CATEGORIES.items():
        for pattern in config["auto_detect"]:
            if pattern in dir_lower:
                context_scores[context] += 1
    
    # Select best context
    best_context = max(context_scores.items(), key=lambda x: x[1])
    confidence = min(best_context[1] / 5.0, 1.0)  # Normalize to 0-1
    
    if confidence >= 0.7:
        return ContextResult(
            context=best_context[0],
            method="auto_detected",
            confidence=confidence,
            reasoning=f"Auto-detected based on patterns (confidence: {confidence:.1f})"
        )
    else:
        return ContextResult(
            context="DEFAULT",
            method="fallback",
            confidence=0.5,
            reasoning="Low confidence in detection, using DEFAULT mode"
        )

def check_explicit_keywords(message):
    """Check for explicit @keywords in user message."""
    message_lower = message.lower()
    
    keyword_map = {
        "@code": "CODING", "@implement": "CODING", "@build": "CODING", "@develop": "CODING",
        "@design": "ARCHITECTURE", "@architecture": "ARCHITECTURE", "@system": "ARCHITECTURE",
        "@debug": "DEBUGGING", "@troubleshoot": "DEBUGGING", "@fix": "DEBUGGING", "@solve": "DEBUGGING",
        "@test": "TESTING", "@testing": "TESTING", "@qa": "TESTING", "@validate": "TESTING",
        "@agile": "AGILE", "@sprint": "AGILE", "@story": "AGILE", "@backlog": "AGILE",
        "@git": "GIT_OPERATIONS", "@commit": "GIT_OPERATIONS", "@push": "GIT_OPERATIONS", "@merge": "GIT_OPERATIONS",
        "@docs": "DOCUMENTATION", "@document": "DOCUMENTATION", "@readme": "DOCUMENTATION",
        "@optimize": "PERFORMANCE", "@performance": "PERFORMANCE", "@benchmark": "PERFORMANCE",
        "@security": "SECURITY", "@secure": "SECURITY", "@vulnerability": "SECURITY",
        "@default": "DEFAULT", "@all": "DEFAULT"
    }
    
    for keyword, context in keyword_map.items():
        if keyword in message_lower:
            return context
    
    return None
```

### 4. **Rule Application System**
**MANDATORY**: Apply selected rules with transparency

```python
def apply_context_aware_rules(context_result):
    """
    Apply rules based on detected context.
    
    Args:
        context_result: Result from context detection
        
    Returns:
        RuleApplicationResult with active rules and metrics
    """
    
    context = context_result.context
    rule_config = CONTEXT_CATEGORIES[context]
    active_rules = rule_config["rules"]
    
    # Calculate efficiency metrics
    total_available_rules = 39  # Current total rule count
    active_rule_count = len(active_rules)
    efficiency_improvement = ((total_available_rules - active_rule_count) / total_available_rules) * 100
    
    # Log context detection and rule selection
    print(f"🎯 **Context Detected**: {context}")
    print(f"📋 **Detection Method**: {context_result.method}")
    print(f"🔍 **Reasoning**: {context_result.reasoning}")
    print(f"📊 **Rules Active**: {active_rule_count} rules loaded")
    print(f"⚡ **Efficiency**: {efficiency_improvement:.0f}% reduction from full rule set")
    print(f"🤖 **Future Agent**: {rule_config['agent_future']}")
    print(f"📝 **Active Rules**: {', '.join(active_rules)}")
    
    return RuleApplicationResult(
        context=context,
        active_rules=active_rules,
        total_rules_available=total_available_rules,
        efficiency_improvement=efficiency_improvement,
        agent_future=rule_config["agent_future"],
        detection_confidence=context_result.confidence
    )
```

### 5. **Agent Swarm Foundation**
**MANDATORY**: Design for future agent swarm coordination

```yaml
agent_swarm_preparation:
  rule_to_agent_mapping:
    - "Each context category maps to future specialized agent"
    - "Rule sets become agent behavioral DNA"
    - "Context detection becomes agent selection logic"
    - "Optimization patterns become swarm coordination intelligence"
    
  scalability_design:
    - "Context detection scales from single AI to multi-agent orchestration"
    - "Rule application scales from individual behavior to swarm coordination"
    - "Efficiency improvements compound across agent swarm"
    - "Learning and optimization scale to collective intelligence"
    
  coordination_protocols:
    - "Shared context understanding across agents"
    - "Inter-agent communication using same context categories"
    - "Coordinated rule application for complex multi-agent tasks"
    - "Swarm-wide optimization using same efficiency metrics"
```

### 6. **Performance and Efficiency**
**MANDATORY**: Achieve significant efficiency improvements

```yaml
efficiency_targets:
  rule_reduction: "75-85% reduction in active rules per session"
  startup_performance: "50% faster session initialization"
  cognitive_load: "80% reduction in rule complexity per task"
  context_accuracy: "90%+ correct context detection"
  
efficiency_monitoring:
  - "Track rule usage patterns and effectiveness"
  - "Monitor context detection accuracy over time"
  - "Measure performance improvements in real sessions"
  - "Collect user satisfaction with focused rule sets"
```

### 7. **Learning and Optimization**
**MANDATORY**: Continuous improvement of context detection

```yaml
learning_system:
  pattern_recognition:
    - "Learn from successful context detections"
    - "Identify patterns that improve detection accuracy"
    - "Adapt detection algorithms based on usage data"
    - "Optimize rule sets based on effectiveness metrics"
    
  feedback_integration:
    - "Collect feedback on context detection accuracy"
    - "Learn from manual context corrections"
    - "Improve auto-detection patterns over time"
    - "Optimize rule combinations for better outcomes"
```

## Implementation Guidelines

### 1. **Rule Metadata Modification**
**CRITICAL**: To enable context-aware rule loading, modify rule metadata as follows:

```yaml
# OLD STRUCTURE (always loads)
# NEW STRUCTURE (context-aware)
```

### 2. **Context-Specific Rule Categories**
**MANDATORY**: Organize rules by context for proper loading:

#### **Always Apply Rules (Tier 1)**
- `safety_first_principle` - Always loaded for safety
- `intelligent_context_aware_rule_system` - The system itself
- `core_rule_application_framework` - Framework for rule application

#### **Context-Dependent Rules (Tier 2)**
- **CODING**: `xp_test_first_development_rule`, `development_core_principles_rule`
- **DEBUGGING**: `development_systematic_problem_solving_rule`, `development_error_exposure_rule`
- **AGILE**: `agile_artifacts_maintenance_rule`, `agile_sprint_management_rule`
- **DOCUMENTATION**: `documentation_live_updates_rule`, `rule_document_excellence_rule`
- **RESEARCH**: `development_context_awareness_excellence_rule`, `development_clear_communication_rule`

### 3. **Session Startup Process**
```yaml
startup_sequence:
  1_initialize: "Load intelligent context-aware rule system"
  2_detect: "Analyze initial context from user query and environment"
  3_select: "Choose appropriate rule set based on context"
  4_apply: "Activate selected rules and provide transparency"
  5_monitor: "Track context changes during session"
  6_adapt: "Adjust rule set if context changes significantly"
```

### 2. **Context Change Handling**
```yaml
context_adaptation:
  trigger_conditions:
    - "User explicitly changes context with new @keyword"
    - "File context changes significantly (different file types)"
    - "Activity type changes (coding → debugging → documentation)"
    
  adaptation_process:
    - "Detect context change"
    - "Evaluate need for rule set adjustment"
    - "Smoothly transition to new rule set"
    - "Maintain continuity of ongoing work"
```

### 3. **Quality Assurance**
```yaml
quality_maintenance:
  critical_rules_always_active:
    - "safety_first_principle always included"
    - "Core quality standards never compromised"
    - "Essential safety checks always performed"
    
  context_validation:
    - "Validate context detection accuracy"
    - "Ensure appropriate rules for detected context"
    - "Monitor for context detection failures"
    - "Provide fallback to DEFAULT mode when uncertain"
```

## Benefits

### **Immediate Benefits**
- **75-85% Rule Reduction**: From 39 rules to 6-10 focused rules per session
- **50% Faster Startup**: Reduced rule processing overhead
- **Improved Focus**: Only relevant rules for current work
- **Better Performance**: Less cognitive load, faster responses

### **Strategic Benefits**
- **Agent Swarm Foundation**: Architecture ready for multi-agent coordination
- **Scalable Design**: Patterns that work for single AI and agent swarms
- **Learning Capability**: System improves over time
- **Future-Proof**: Designed for evolution to autonomous agent teams

### **User Experience Benefits**
- **Explicit Control**: @keywords for precise rule selection
- **Intelligent Assistance**: Automatic context detection when needed
- **Transparency**: Clear visibility into rule selection reasoning
- **Flexibility**: Easy context switching during development

## Enforcement

This rule is **CONDITIONALLY APPLIED** based on context.

**The intelligent context-aware rule system is the foundation for both current efficiency and future agent swarm coordination.**

## Remember

**"Context awareness enables precision."**

**"Focused rules deliver better results than scattered rules."**

**"Today's rule system is tomorrow's agent swarm DNA."**

**"Efficiency improvements compound across the entire system."**

This system transforms rule management from overwhelming complexity to intelligent precision, while laying the foundation for the future of autonomous software development.
**"Context awareness enables precision."**

**"Focused rules deliver better results than scattered rules."**

**"Today's rule system is tomorrow's agent swarm DNA."**

**"Efficiency improvements compound across the entire system."**

This system transforms rule management from overwhelming complexity to intelligent precision, while laying the foundation for the future of autonomous software development.


# === core_rule_application_framework ===
---
description: "Auto-generated description for core_rule_application_framework.mdc"
category: "core-foundation"
priority: "critical"
alwaysApply: false
globs: ["**/*"]
tags: ['core_foundation']
tier: "2"
---

# Core Rule Application Framework

**CRITICAL**: This framework ensures that critical rules are automatically applied to every situation, task, and development session. The Courage Rule and No Premature Victory Declaration Rule are ALWAYS active.

## Framework Overview

This framework provides automatic rule application that ensures critical rules are never missed, forgotten, or bypassed. It operates at the highest level of our rule system and enforces the most important development principles.

## Core Critical Rules

### **1. Courage and Complete Work Rule** 💪
- **Purpose**: Ensure ALL work is completed systematically, never stopping at partial results
- **Application**: Applied to every work session, task, and problem-solving situation
- **Enforcement**: Automatic application with verification

### **2. No Premature Victory Declaration Rule** 🎯
- **Purpose**: Prevent premature declarations of success without proper validation and enforce concise progress communication
- **Application**: Applied to every progress report, completion claim, status update, and communication
- **Enforcement**: Automatic validation before any success declaration and conciseness requirements

### **3. No Failing Tests Rule** 🧪
- **Purpose**: Ensure zero tolerance for failing tests
- **Application**: Applied to every development session and commit
- **Enforcement**: Automatic test execution and failure blocking

### **4. Boy Scout Rule** 🏕️
- **Purpose**: Always leave the codebase cleaner than found
- **Application**: Applied to every code modification and cleanup
- **Enforcement**: Automatic cleanup and improvement verification

### **5. Automatic Agile Artifact Maintenance Rule** 📋
- **Purpose**: Automatically maintain all agile artifacts immediately after any task completion
- **Application**: Applied to every task completion, story status change, sprint milestone
- **Enforcement**: DNA-level embedding with zero tolerance for missed artifacts

## Framework Implementation

### **Automatic Rule Application System**

```python
class CoreRuleApplicationFramework:
    """Always-active framework that applies critical rules automatically."""
    
    def __init__(self):
        self.critical_rules = {
            "courage_rule": {
                "file": "development_courage_completion_rule.mdc",
                "priority": "critical",
                "always_apply": True,
                "triggers": ["work_start", "problem_encountered", "progress_report", "work_completion"]
            },
            "no_premature_victory_declaration_rule": {
                "file": "no_premature_victory_declaration_rule.mdc",
                "priority": "critical", 
                "always_apply": True,
                "triggers": ["progress_report", "success_declaration", "completion_claim", "communication", "status_update"]
            },
            "no_failing_tests_rule": {
                "file": "no_failing_tests_rule.mdc",
                "priority": "critical",
                "always_apply": True,
                "triggers": ["development_session", "code_change", "commit_preparation"]
            },
            "boyscout_rule": {
                "file": "boyscout_leave_cleaner_rule.mdc",
                "priority": "critical",
                "always_apply": True,
                "triggers": ["code_modification", "cleanup", "session_end"]
            },
            "automatic_agile_artifact_maintenance_rule": {
                "file": "automatic_agile_artifact_maintenance_rule.mdc",
                "priority": "critical",
                "always_apply": True,
                "triggers": ["task_completion", "story_status_change", "sprint_milestone", "quality_gate_passage", "documentation_creation"]
            }
        }
    
    def apply_critical_rules(self, context: dict) -> dict:
        """Apply all critical rules to the current context."""
        
        print("🚀 APPLYING CRITICAL RULES FRAMEWORK")
        
        # Apply courage rule
        context = self.apply_courage_rule(context)
        
        # Apply no premature victory declaration rule
        context = self.apply_no_premature_victory_declaration_rule(context)
        
        # Apply no failing tests rule
        context = self.apply_no_failing_tests_rule(context)
        
        # Apply boy scout rule
        context = self.apply_boyscout_rule(context)
        
        # Apply automatic agile artifact maintenance rule
        context = self.apply_automatic_artifact_maintenance_rule(context)
        
        print("✅ CRITICAL RULES FRAMEWORK APPLIED")
        return context
    
    def apply_courage_rule(self, context: dict) -> dict:
        """Apply courage rule to ensure complete work."""
        
        print("💪 APPLYING COURAGE RULE")
        
        # Courage declaration
        context["courage_declaration"] = {
            "timestamp": datetime.now(),
            "commitment": "Complete ALL work systematically",
            "no_partial_results": True,
            "systematic_approach": True
        }
        
        # Courage verification
        context["courage_verification"] = {
            "work_complete": False,  # Will be set to True only when 100% complete
            "partial_progress_acceptable": False,
            "systematic_problem_solving": True
        }
        
        print("✅ COURAGE RULE APPLIED")
        return context
    
    def apply_no_premature_victory_declaration_rule(self, context: dict) -> dict:
        """Apply no premature victory declaration rule to prevent false claims and enforce concise communication."""
        
        print("🎯 APPLYING NO PREMATURE VICTORY DECLARATION RULE")
        
        # Success validation and conciseness requirements
        context["success_validation"] = {
            "evidence_required": True,
            "test_validation_required": True,
            "complete_verification_required": True,
            "no_assumptions_allowed": True,
            "concise_communication_required": True,
            "progress_only_output": True,
            "max_words_status_update": 100,
            "max_words_progress_report": 50
        }
        
        # Success declaration guard
        context["success_declaration_guard"] = {
            "validation_complete": False,
            "evidence_provided": False,
            "tests_passing": False,
            "ready_for_declaration": False
        }
        
        print("✅ NO PREMATURE VICTORY DECLARATION RULE APPLIED")
        return context
    
    def apply_no_failing_tests_rule(self, context: dict) -> dict:
        """Apply no failing tests rule to ensure test quality."""
        
        print("🧪 APPLYING NO FAILING TESTS RULE")
        
        # Test execution requirements
        context["test_requirements"] = {
            "all_tests_must_pass": True,
            "zero_tolerance_for_failures": True,
            "test_execution_required": True,
            "failure_blocking": True
        }
        
        # Test validation
        context["test_validation"] = {
            "tests_executed": False,
            "all_tests_passing": False,
            "failures_fixed": False,
            "ready_to_proceed": False
        }
        
        print("✅ NO FAILING TESTS RULE APPLIED")
        return context
    
    def apply_boyscout_rule(self, context: dict) -> dict):
        """Apply boy scout rule to ensure codebase improvement."""
        
        print("🏕️ APPLYING BOY SCOUT RULE")
        
        # Cleanup requirements
        context["cleanup_requirements"] = {
            "leave_cleaner_than_found": True,
            "proactive_improvements": True,
            "code_quality_enhancement": True,
            "documentation_improvement": True
        }
        
        # Cleanup validation
        context["cleanup_validation"] = {
            "cleanup_performed": False,
            "improvements_made": False,
            "codebase_enhanced": False,
            "ready_for_commit": False
        }
        
        print("✅ BOY SCOUT RULE APPLIED")
        return context
    
    def apply_automatic_artifact_maintenance_rule(self, context: dict) -> dict:
        """Apply automatic agile artifact maintenance rule to ensure all artifacts are updated."""
        
        print("📋 APPLYING AUTOMATIC AGILE ARTIFACT MAINTENANCE RULE")
        
        # Artifact maintenance requirements
        context["artifact_maintenance"] = {
            "automatic_execution": True,
            "zero_tolerance": True,
            "immediate_updates": True,
            "stakeholder_notification": True
        }
        
        # Artifact monitoring
        context["artifact_monitoring"] = {
            "user_stories": "docs/agile/sprints/*/user_stories/*.md",
            "sprint_catalogs": "docs/agile/catalogs/*.md",
            "sprint_summaries": "docs/agile/sprints/*/SPRINT_*_SUMMARY.md",
            "quality_metrics": True,
            "stakeholder_communications": True
        }
        
        # Automatic execution triggers
        context["artifact_triggers"] = {
            "task_completion": True,
            "story_status_change": True,
            "sprint_milestone": True,
            "quality_gate_passage": True,
            "documentation_creation": True
        }
        
        print("✅ AUTOMATIC AGILE ARTIFACT MAINTENANCE RULE APPLIED")
        return context
```

### **Rule Application Triggers**

```python
class RuleApplicationTriggers:
    """Automatic triggers for critical rule application."""
    
    def __init__(self):
        self.framework = CoreRuleApplicationFramework()
    
    def on_work_start(self, context: dict) -> dict:
        """Trigger when work begins."""
        
        print("🚀 WORK START TRIGGER - APPLYING CRITICAL RULES")
        
        # Apply courage rule
        context = self.framework.apply_courage_rule(context)
        
        # Apply no failing tests rule
        context = self.framework.apply_no_failing_tests_rule(context)
        
        # Apply boy scout rule
        context = self.framework.apply_boyscout_rule(context)
        
        return context
    
    def on_progress_report(self, context: dict) -> dict:
        """Trigger when reporting progress."""
        
        print("📊 PROGRESS REPORT TRIGGER - APPLYING CRITICAL RULES")
        
        # Apply no premature success rule
        context = self.framework.apply_no_premature_victory_declaration_rule(context)
        
        # Apply courage rule verification
        context = self.verify_courage_rule_compliance(context)
        
        return context
    
    def on_success_declaration(self, context: dict) -> dict:
        """Trigger when declaring success."""
        
        print("🎉 SUCCESS DECLARATION TRIGGER - APPLYING CRITICAL RULES")
        
        # Apply no premature success rule with strict validation
        context = self.framework.apply_no_premature_victory_declaration_rule(context)
        
        # Validate success declaration
        context = self.validate_success_declaration(context)
        
        return context
    
    def on_work_completion(self, context: dict) -> dict:
        """Trigger when work appears complete."""
        
        print("🏁 WORK COMPLETION TRIGGER - APPLYING CRITICAL RULES")
        
        # Apply all critical rules for final validation
        context = self.framework.apply_critical_rules(context)
        
        # Final validation
        context = self.validate_complete_success(context)
        
        return context
    
    def verify_courage_rule_compliance(self, context: dict) -> dict:
        """Verify compliance with courage rule."""
        
        if not context.get("courage_declaration"):
            print("❌ COURAGE RULE VIOLATION: No courage declaration found")
            context = self.framework.apply_courage_rule(context)
        
        return context
    
    def validate_success_declaration(self, context: dict) -> dict:
        """Validate success declaration against no premature success rule."""
        
        validation = context.get("success_validation", {})
        guard = context.get("success_declaration_guard", {})
        
        if not validation.get("evidence_required"):
            print("❌ NO PREMATURE SUCCESS VIOLATION: Evidence required")
            raise ValueError("Success declaration requires evidence")
        
        if not guard.get("validation_complete"):
            print("❌ NO PREMATURE SUCCESS VIOLATION: Validation not complete")
            raise ValueError("Success declaration requires complete validation")
        
        return context
    
    def validate_complete_success(self, context: dict) -> dict:
        """Validate complete success against all critical rules."""
        
        # Check courage rule compliance
        courage_verification = context.get("courage_verification", {})
        if not courage_verification.get("work_complete"):
            print("❌ COURAGE RULE VIOLATION: Work not complete")
            raise ValueError("Work must be 100% complete")
        
        # Check no premature success compliance
        success_guard = context.get("success_declaration_guard", {})
        if not success_guard.get("ready_for_declaration"):
            print("❌ NO PREMATURE SUCCESS VIOLATION: Not ready for declaration")
            raise ValueError("Success declaration not ready")
        
        # Check no failing tests compliance
        test_validation = context.get("test_validation", {})
        if not test_validation.get("all_tests_passing"):
            print("❌ NO FAILING TESTS VIOLATION: Tests not passing")
            raise ValueError("All tests must pass")
        
        # Check boy scout rule compliance
        cleanup_validation = context.get("cleanup_validation", {})
        if not cleanup_validation.get("codebase_enhanced"):
            print("❌ BOY SCOUT RULE VIOLATION: Codebase not enhanced")
            raise ValueError("Codebase must be enhanced")
        
        print("✅ COMPLETE SUCCESS VALIDATED - ALL CRITICAL RULES COMPLIANT")
        return context
```

### **Automatic Integration System**

```python
class AutomaticRuleIntegration:
    """Automatic integration of critical rules into all workflows."""
    
    def __init__(self):
        self.triggers = RuleApplicationTriggers()
        self.framework = CoreRuleApplicationFramework()
    
    def integrate_into_session_startup(self, context: dict) -> dict:
        """Integrate critical rules into session startup."""
        
        print("🚀 INTEGRATING CRITICAL RULES INTO SESSION STARTUP")
        
        # Apply all critical rules
        context = self.framework.apply_critical_rules(context)
        
        # Apply work start triggers
        context = self.triggers.on_work_start(context)
        
        return context
    
    def integrate_into_progress_reporting(self, context: dict) -> dict:
        """Integrate critical rules into progress reporting."""
        
        print("📊 INTEGRATING CRITICAL RULES INTO PROGRESS REPORTING")
        
        # Apply progress report triggers
        context = self.triggers.on_progress_report(context)
        
        return context
    
    def integrate_into_success_declaration(self, context: dict) -> dict:
        """Integrate critical rules into success declaration."""
        
        print("🎉 INTEGRATING CRITICAL RULES INTO SUCCESS DECLARATION")
        
        # Apply success declaration triggers
        context = self.triggers.on_success_declaration(context)
        
        return context
    
    def integrate_into_work_completion(self, context: dict) -> dict:
        """Integrate critical rules into work completion."""
        
        print("🏁 INTEGRATING CRITICAL RULES INTO WORK COMPLETION")
        
        # Apply work completion triggers
        context = self.triggers.on_work_completion(context)
        
        return context
```

## Framework Usage

### **Automatic Application**

The framework automatically applies critical rules to every situation:

```python
# Initialize framework
integration = AutomaticRuleIntegration()

# Session startup with critical rules
context = integration.integrate_into_session_startup(context)

# Progress reporting with critical rules
context = integration.integrate_into_progress_reporting(context)

# Success declaration with critical rules
context = integration.integrate_into_success_declaration(context)

# Work completion with critical rules
context = integration.integrate_into_work_completion(context)
```

### **Manual Application**

For specific situations, apply critical rules manually:

```python
# Initialize framework
framework = CoreRuleApplicationFramework()

# Apply all critical rules
context = framework.apply_critical_rules(context)

# Apply specific rule
context = framework.apply_courage_rule(context)
context = framework.apply_no_premature_victory_declaration_rule(context)
```

## Framework Benefits

### **1. Always Active Critical Rules**
- Courage rule automatically applied to every work session
- No premature success rule automatically applied to every progress report
- No failing tests rule automatically applied to every development session
- Boy scout rule automatically applied to every code modification

### **2. Automatic Integration**
- No manual rule application required
- Rules integrated into all workflows automatically
- Consistent rule application across all situations
- Zero chance of missing critical rules

### **3. Comprehensive Validation**
- Automatic validation of rule compliance
- Prevention of rule violations
- Clear feedback on rule application
- Systematic enforcement of critical principles

### **4. Systematic Organization**
- Clear rule hierarchy and priorities
- Automatic rule discovery and application
- Consistent rule enforcement patterns
- Easy rule management and maintenance

## Framework Enforcement

### **Automatic Enforcement**
- Critical rules applied automatically to every situation
- No manual intervention required
- Consistent enforcement across all contexts
- Zero tolerance for rule violations

### **Validation Enforcement**
- Automatic validation of rule compliance
- Prevention of premature success declarations
- Enforcement of courage-based work completion
- Systematic test quality assurance

### **Integration Enforcement**
- Automatic integration into all workflows
- Seamless rule application without disruption
- Consistent rule behavior across all systems
- Reliable rule enforcement mechanisms

## Framework Monitoring

### **Rule Application Monitoring**
- Track rule application frequency
- Monitor rule compliance rates
- Measure rule effectiveness
- Identify rule application gaps

### **Performance Monitoring**
- Monitor framework performance impact
- Track rule application speed
- Measure system resource usage
- Optimize rule application efficiency

### **Effectiveness Monitoring**
- Monitor rule effectiveness metrics
- Track rule violation rates
- Measure rule compliance improvements
- Validate rule application outcomes

## Framework Maintenance

### **Regular Updates**
- Update rule definitions as needed
- Enhance rule application logic
- Improve rule validation mechanisms
- Optimize rule performance

### **Continuous Improvement**
- Monitor rule effectiveness
- Identify improvement opportunities
- Implement rule enhancements
- Validate rule improvements

### **Documentation Updates**
- Keep framework documentation current
- Update usage examples
- Maintain rule application guides
- Document best practices

## Conclusion

This Core Rule Application Framework ensures that our most critical rules - the Courage Rule and No Premature Success Rule - are always active and properly applied to every situation. It provides automatic integration, comprehensive validation, and systematic enforcement of our core development principles.

**The framework guarantees that:**
- **Courage Rule** is applied to every work session
- **No Premature Success Rule** is applied to every progress report
- **No Failing Tests Rule** is applied to every development session
- **Boy Scout Rule** is applied to every code modification

This ensures our goal of **fully automated, crystal clear code production** with **accurate tests and documentation** and **up-to-date project tracking** following **excellence standards**.



# === user_controlled_success_declaration_rule ===
# User Controlled Success Declaration Rule

**CRITICAL**: In specific situations where the user explicitly states they want to see results first and will generate their own success messages, NEVER generate success declarations, victory messages, or completion summaries. Let the user see the actual work results and decide on success themselves.

## Core Principle

**"User Controls Success When Explicitly Requested"**

When the user says phrases like:
- "we must see the result of your work immediately"
- "never generate success messages in situations like that"
- "i need a rule for that, that I am in control of success"
- "stop this in situations like that"

The user is taking control of success declaration. Respect this control.

## Requirements

### 1. **No Success Messages When User Controls**
- Never generate "✅ Success!" messages
- Never create completion summaries
- Never declare victory or completion
- Never use celebration emojis or success indicators
- Never say "work is complete" or similar phrases

### 2. **Show Results Only**
- Present actual work results
- Show data, files, or outputs
- Display verification results
- Provide evidence of work done
- Let results speak for themselves

### 3. **Wait for User Assessment**
- Let user evaluate the results
- Wait for user's success declaration
- Don't preempt user's judgment
- Respect user's authority in these situations

## Enforcement

This rule is **ALWAYS ACTIVE** and applies when:

- User explicitly states they control success declaration
- User says "never generate success messages"
- User wants to see results first
- User takes authority over completion assessment

## Examples

### ❌ FORBIDDEN (When User Controls Success)
```
✅ Rule system optimization complete!
🎉 Success! All issues resolved!
🏆 Work finished successfully!
```

### ✅ ALLOWED (When User Controls Success)
```
Results of rule system verification:
- 3 core rules with alwaysApply: false
- 38 context rules with alwaysApply: false
- System health score: 80/100
```

## Remember

**"When user controls success, show results and wait."**

**"Let the user decide what constitutes success."**

**"Results speak louder than success declarations."**



# === scientific_communication_rule ===
---
description: "Enforce scientific, rational communication without emotional decorations or marketing language"
category: "core-foundation"
priority: "critical"
alwaysApply: false
globs: ["**/*"]
tags: ['core_foundation', 'communication', 'scientific']
tier: "1"
---

# Scientific Communication Rule

**CRITICAL**: All communication must be scientific, rational, and factual. No emotional decorations, marketing language, or unnecessary embellishments.

## Core Principle

**"Rationality and Clarity Over Emotions and Marketing"**

Communication must be based on facts, evidence, and logical reasoning. Emotional language and marketing-style presentations are prohibited.

## Requirements

### 1. **Factual Communication Only**
- State facts without emotional interpretation
- Use precise, measurable language
- Provide evidence for claims
- Avoid subjective opinions presented as facts

### 2. **No Emotional Decorations**
**FORBIDDEN:**
- Celebration emojis (🎉, ✨, 🚀)
- Emotional exclamations ("Amazing!", "Fantastic!")
- Marketing superlatives ("incredible", "revolutionary", "game-changing")
- Dramatic language ("breakthrough", "stunning", "phenomenal")

**REQUIRED:**
- Neutral, descriptive language
- Objective measurements
- Clear, direct statements
- Evidence-based conclusions

### 3. **Scientific Precision**
- Use specific measurements instead of vague terms
- Provide quantifiable results
- State confidence levels and uncertainty
- Document methodology and assumptions

### 4. **Rational Structure**
- Present information logically
- Separate observations from conclusions
- Show cause-and-effect relationships clearly
- Use systematic problem-solving approaches

## Examples

### ❌ FORBIDDEN (Emotional/Marketing Style)
```
🎉 Amazing breakthrough! Our revolutionary system delivers incredible results!
✨ Fantastic performance improvements that will blow your mind!
🚀 Game-changing solution with phenomenal efficiency gains!
```

### ✅ REQUIRED (Scientific Style)
```
System performance analysis:
- Rule count reduced from 33 to 5 (84.8% reduction)
- Context detection accuracy: 95% (19/20 test cases)
- File generation time: 0.3 seconds average
- Memory usage decreased by 67%
```

## Communication Standards

### 1. **Data Presentation**
- Always include specific numbers
- Show before/after comparisons
- Provide confidence intervals when applicable
- State sample sizes and test conditions

### 2. **Problem Description**
- Define problems objectively
- Quantify impact where possible
- Identify root causes systematically
- Separate symptoms from causes

### 3. **Solution Documentation**
- Describe methodology clearly
- Show implementation steps
- Provide verification methods
- Document limitations and assumptions

### 4. **Progress Reporting**
- Use measurable metrics
- Show completion percentages
- Report actual vs. expected results
- Identify remaining work objectively

## Enforcement

This rule is **ALWAYS ACTIVE** and applies to:

- All written communication
- All progress reports
- All documentation
- All code comments
- All user interactions

## Remember

**"Facts over feelings, evidence over excitement, clarity over celebration."**

**"Measure twice, communicate once."**

**"Rational discourse produces rational results."**


# === streamlined_git_operations_rule ===
---
alwaysApply: false
autoFix: false
category: git-type_0
contexts:
- GIT
dependencies:
- safety_first_principle
description: Streamlined Git Operations - type_0 layer rule
enforcement: warning
formalLayer: type_0
globs:
- '**/*'
languageGames:
- version_control_coordination
- workflow_harmony
linguisticFramework: git
logicalType: 0
priority: high
tags:
- type_0
- git
- type_0
- priority_2
- version_control_coordination
- workflow_harmony
tier: '2'
---

# Streamlined Git Operations Rule

**CRITICAL**: In standard development situations, execute the proven three-command sequence: `git add .`, `git commit`, and `git push`. Avoid unnecessary git status checks or other git operations unless explicitly requested.

## Core Principle

**"Add, Commit, Push - The Proven Workflow"**

When the user requests git operations for standard development workflow, execute the proven three-command sequence: `git add .`, `git commit`, and `git push`. This ensures all changes are captured and reduces command overhead while maintaining reliability.

## Standard Git Workflow

### 1. **Standard Commit and Push Sequence**
**REQUIRED for standard situations:**
```bash
git add .
git commit -m "descriptive commit message"
git push
```

**PROVEN SUCCESSFUL WORKFLOW:**
- `git add .` - Stage all changes (IDE staging may be incomplete)
- `git commit -m "message"` - Commit with descriptive message
- `git push` - Push to remote repository

**FORBIDDEN in standard situations:**
- `git status` (unless explicitly requested for diagnostics)
- `git branch` checks (unless troubleshooting)
- `git log` reviews (unless explicitly requested)
- Multiple status checks between commands

### 2. **When to Use Standard Workflow**
**Apply streamlined approach when:**
- User requests "commit" or "push" 
- User says "let's commit now"
- User asks "should we commit?"
- Standard development workflow context
- No specific git issues mentioned

**Do NOT use streamlined approach when:**
- User explicitly requests git status
- User mentions merge conflicts
- User asks about branches
- User requests specific git diagnostics
- Error conditions are suspected

### 3. **Commit Message Standards**
**REQUIRED format:**
- Clear, descriptive commit messages
- Present tense, imperative mood
- Include feature/fix context
- Reference user story or issue when applicable

**Examples:**
```
"Implement intelligent context-aware rule system"
"Fix rule metadata for context detection"
"Update documentation for US-E0-010 completion"
"Add comprehensive validation suite for context system"
```

### 4. **Error Handling**
**If commit fails:**
- Show the error message
- Ask user for guidance
- Do not automatically run additional git commands

**If push fails:**
- Show the error message
- Ask user for guidance
- Do not automatically attempt pull or merge

## Implementation Guidelines

### 1. **Command Execution**
```python
# REQUIRED: Proven successful approach
def standard_git_workflow(commit_message):
    run_command("git add .")
    run_command(f"git commit -m '{commit_message}'")
    run_command("git push")

# FORBIDDEN: Verbose approach with unnecessary commands
def verbose_git_workflow():
    run_command("git status")  # Unnecessary unless debugging
    run_command("git add .")   
    run_command("git status")  # Redundant
    run_command("git commit -m 'message'")
    run_command("git status")  # Unnecessary
    run_command("git push")
    run_command("git status")  # Excessive
```

### 2. **Context Detection**
**Standard situations:**
- User in normal development flow
- Files may need staging (IDE staging can be incomplete)
- No git issues mentioned
- Routine commit and push request

**Non-standard situations:**
- User mentions git problems
- User explicitly requests git status
- User asks about branches or history
- Error conditions present

### 3. **User Communication**
**REQUIRED communication:**
- Confirm commit message before executing
- Report success or failure clearly
- Ask for guidance if errors occur

**FORBIDDEN communication:**
- Verbose git status reports
- Unnecessary command explanations
- Multiple status updates during execution

## Exception Handling

### 1. **When to Break the Rule**
**Use full git workflow when:**
- User explicitly requests `git status`
- User mentions "check status" or "what's changed"
- User asks about branches, history, or conflicts
- Error conditions require diagnosis
- User is troubleshooting git issues

### 2. **Error Recovery**
**If streamlined approach fails:**
- Show the specific error
- Ask user what they want to do
- Do not automatically escalate to verbose commands
- Let user decide next steps

### 3. **User Override**
**User can override by:**
- Explicitly requesting specific git commands
- Mentioning they want to see status
- Asking for git diagnostics
- Indicating non-standard workflow needs

## Benefits

### 1. **Efficiency**
- Faster commit and push cycles
- Reduced command overhead
- Streamlined development workflow
- Less terminal output clutter

### 2. **Simplicity**
- Clear, predictable behavior
- Fewer commands to execute
- Reduced cognitive load
- Focus on development, not git mechanics

### 3. **Reliability**
- Consistent behavior in standard cases
- Predictable command sequence
- Clear error handling
- User maintains control

## Integration with Context System

### 1. **Git Context Detection**
**When @git keyword used:**
- Apply streamlined approach by default
- Execute commit and push only
- Avoid unnecessary git commands

### 2. **Other Context Integration**
**When other contexts active:**
- Still apply streamlined git when git operations requested
- Maintain context-appropriate behavior
- Keep git operations simple regardless of context

### 3. **Rule Priority**
**This rule takes precedence for:**
- Standard git operations
- Routine commit and push requests
- Normal development workflow

## Enforcement

This rule is **ALWAYS ACTIVE** and applies to:

- All git operation requests
- Standard development workflows
- Routine commit and push cycles
- Normal development contexts

## Remember

**"Commit and push - that's it. Keep git simple."**

**"Always stage, commit, and push - the proven three-step workflow."**

**"Three commands that work: add, commit, push."**


# === documentation_live_updates_rule ===
---
alwaysApply: false
autoFix: false
category: docs-type_0
contexts:
- DOCUMENTATION
dependencies:
- core_values_enforcement_rule
description: Live Documentation Updates - type_0 layer rule
enforcement: warning
formalLayer: type_0
globs:
- '**/*'
languageGames:
- documentation_coordination
- knowledge_harmony
linguisticFramework: docs
logicalType: 0
priority: high
tags:
- type_0
- docs
- type_0
- priority_2
- documentation_coordination
- knowledge_harmony
tier: '2'
---

# Live Documentation Updates Rule

**CRITICAL**: All documentation must be updated immediately when any relevant changes occur. Documentation debt is not permitted.

## Description
This rule enforces real-time documentation updates whenever changes are made to code, architecture, processes, rules, configurations, or any other documented elements. Documentation must always reflect the current state of the system.

## Core Requirements

### 1. Immediate Update Obligation
**MANDATORY**: Update documentation within the same work session as the change
# Code example removed for brevity


### 2. Documentation Triggers
**MANDATORY**: Update documentation when ANY of these events occur:
# Code example removed for brevity


### 3. Documentation Types and Update Requirements
**MANDATORY**: Keep ALL documentation types current

#### Code Documentation
# Code example removed for brevity


#### API Documentation
# Code example removed for brevity
json
{
  "current_field": "string",
  "new_field": "integer"  // Added: 2024-01-15
}
# Code example removed for brevity
json
{
  "status": "success",
  "data": {
    "updated_structure": "current_format"
  }
}
# Code example removed for brevity


#### Architecture Documentation
# Code example removed for brevity
mermaid
graph TD
    A[Client] --> B[API Gateway]
    B --> C[Auth Service - Updated]
    B --> D[User Service - New]
# Code example removed for brevity


### 4. Documentation Standards
**MANDATORY**: Follow these update standards

#### Version Information
# Code example removed for brevity


#### Change Tracking
# Code example removed for brevity


### 5. Documentation Validation
**MANDATORY**: Validate documentation accuracy

#### Accuracy Verification
# Code example removed for brevity


#### Link Verification
# Code example removed for brevity


### 6. Automated Documentation Updates
**MANDATORY**: Implement automation where possible

#### Code Comment Extraction
# Code example removed for brevity


#### Schema Documentation
# Code example removed for brevity


### 7. Documentation Review Process
**MANDATORY**: Review documentation changes

#### Pre-Commit Validation
# Code example removed for brevity


#### Documentation Completeness Check
# Code example removed for brevity


### 8. Documentation Organization
**MANDATORY**: Maintain organized documentation structure

#### File Structure
# Code example removed for brevity


#### Cross-References
# Code example removed for brevity


### 9. Documentation Quality Standards
**MANDATORY**: Maintain high documentation quality

#### Clarity Requirements
# Code example removed for brevity
bash
   pip install python-oauth2 python-jwt
   # Code example removed for brevity
bash
   export OAUTH_CLIENT_ID="your_client_id"
   export OAUTH_CLIENT_SECRET="your_client_secret"
   # Code example removed for brevity
python
   from auth import OAuthHandler
   
   handler = OAuthHandler(
       client_id=os.getenv("OAUTH_CLIENT_ID"),
       client_secret=os.getenv("OAUTH_CLIENT_SECRET"),
       redirect_uri="http://localhost:8000/callback"  # New parameter
   )
   # Code example removed for brevity


#### Accuracy Requirements
# Code example removed for brevity


### 10. Documentation Metrics and Monitoring
**MANDATORY**: Track documentation health

#### Coverage Metrics
# Code example removed for brevity


#### Freshness Tracking
# Code example removed for brevity


### 11. Integration with Development Workflow
**MANDATORY**: Integrate documentation into development process

#### Pull Request Requirements
# Code example removed for brevity


#### CI/CD Integration
# Code example removed for brevity


### 12. Emergency Documentation Procedures
**MANDATORY**: Handle urgent documentation needs

#### Hotfix Documentation
# Code example removed for brevity


#### Documentation Debt Recovery
# Code example removed for brevity


### 1. Automated Enforcement
# Code example removed for brevity


### 2. Code Review Requirements
- [ ] All code changes have corresponding documentation updates
- [ ] Documentation accurately reflects implementation
- [ ] Examples work as written
- [ ] Links are valid and current
- [ ] Change history is updated

### 3. Quality Gates
- [ ] Documentation coverage ≥ 90%
- [ ] No documentation older than 30 days from related code
- [ ] All examples execute successfully
- [ ] No broken internal links
- [ ] Changelog updated with all changes

## Benefits

- **Improved Onboarding**: New team members have current documentation
- **Reduced Support Burden**: Accurate docs reduce questions
- **Better Maintenance**: Clear documentation aids debugging
- **Compliance**: Audit requirements met with current documentation
- **Knowledge Preservation**: Institutional knowledge captured and maintained

## Monitoring

### Success Metrics:
- Documentation coverage percentage
- Average documentation age relative to code
- Number of documentation-related support tickets
- Time to resolve documentation issues
- Developer satisfaction with documentation quality

### Failure Indicators:
- Documentation coverage below 90%
- Documentation older than 30 days from related code changes
- Broken or outdated examples
- Increasing support tickets about undocumented features
- Developer complaints about stale documentation

# Live Documentation Updates Rule

**CRITICAL**: All documentation must be updated immediately when any relevant changes occur. Documentation debt is not permitted.

## Description
This rule enforces real-time documentation updates whenever changes are made to code, architecture, processes, rules, configurations, or any other documented elements. Documentation must always reflect the current state of the system.

## Core Requirements

### 1. Immediate Update Obligation
**MANDATORY**: Update documentation within the same work session as the change
# Code example removed for brevity


### 2. Documentation Triggers
**MANDATORY**: Update documentation when ANY of these events occur:
# Code example removed for brevity


### 3. Documentation Types and Update Requirements
**MANDATORY**: Keep ALL documentation types current

#### Code Documentation
# Code example removed for brevity


#### API Documentation
# Code example removed for brevity
json
{
  "current_field": "string",
  "new_field": "integer"  // Added: 2024-01-15
}
# Code example removed for brevity
json
{
  "status": "success",
  "data": {
    "updated_structure": "current_format"
  }
}
# Code example removed for brevity


#### Architecture Documentation
# Code example removed for brevity
mermaid
graph TD
    A[Client] --> B[API Gateway]
    B --> C[Auth Service - Updated]
    B --> D[User Service - New]
# Code example removed for brevity


### 4. Documentation Standards
**MANDATORY**: Follow these update standards

#### Version Information
# Code example removed for brevity


#### Change Tracking
# Code example removed for brevity


### 5. Documentation Validation
**MANDATORY**: Validate documentation accuracy

#### Accuracy Verification
# Code example removed for brevity


#### Link Verification
# Code example removed for brevity


### 6. Automated Documentation Updates
**MANDATORY**: Implement automation where possible

#### Code Comment Extraction
# Code example removed for brevity


#### Schema Documentation
# Code example removed for brevity


### 7. Documentation Review Process
**MANDATORY**: Review documentation changes

#### Pre-Commit Validation
# Code example removed for brevity


#### Documentation Completeness Check
# Code example removed for brevity


### 8. Documentation Organization
**MANDATORY**: Maintain organized documentation structure

#### File Structure
# Code example removed for brevity


#### Cross-References
# Code example removed for brevity


### 9. Documentation Quality Standards
**MANDATORY**: Maintain high documentation quality

#### Clarity Requirements
# Code example removed for brevity
bash
   pip install python-oauth2 python-jwt
   # Code example removed for brevity
bash
   export OAUTH_CLIENT_ID="your_client_id"
   export OAUTH_CLIENT_SECRET="your_client_secret"
   # Code example removed for brevity
python
   from auth import OAuthHandler
   
   handler = OAuthHandler(
       client_id=os.getenv("OAUTH_CLIENT_ID"),
       client_secret=os.getenv("OAUTH_CLIENT_SECRET"),
       redirect_uri="http://localhost:8000/callback"  # New parameter
   )
   # Code example removed for brevity


#### Accuracy Requirements
# Code example removed for brevity


### 10. Documentation Metrics and Monitoring
**MANDATORY**: Track documentation health

#### Coverage Metrics
# Code example removed for brevity


#### Freshness Tracking
# Code example removed for brevity


### 11. Integration with Development Workflow
**MANDATORY**: Integrate documentation into development process

#### Pull Request Requirements
# Code example removed for brevity


#### CI/CD Integration
# Code example removed for brevity


### 12. Emergency Documentation Procedures
**MANDATORY**: Handle urgent documentation needs

#### Hotfix Documentation
# Code example removed for brevity


#### Documentation Debt Recovery
# Code example removed for brevity


### 1. Automated Enforcement
# Code example removed for brevity


### 2. Code Review Requirements
- [ ] All code changes have corresponding documentation updates
- [ ] Documentation accurately reflects implementation
- [ ] Examples work as written
- [ ] Links are valid and current
- [ ] Change history is updated

### 3. Quality Gates
- [ ] Documentation coverage ≥ 90%
- [ ] No documentation older than 30 days from related code
- [ ] All examples execute successfully
- [ ] No broken internal links
- [ ] Changelog updated with all changes

## Benefits

- **Improved Onboarding**: New team members have current documentation
- **Reduced Support Burden**: Accurate docs reduce questions
- **Better Maintenance**: Clear documentation aids debugging
- **Compliance**: Audit requirements met with current documentation
- **Knowledge Preservation**: Institutional knowledge captured and maintained

## Monitoring

### Success Metrics:
- Documentation coverage percentage
- Average documentation age relative to code
- Number of documentation-related support tickets
- Time to resolve documentation issues
- Developer satisfaction with documentation quality

### Failure Indicators:
- Documentation coverage below 90%
- Documentation older than 30 days from related code changes
- Broken or outdated examples
- Increasing support tickets about undocumented features
- Developer complaints about stale documentation



